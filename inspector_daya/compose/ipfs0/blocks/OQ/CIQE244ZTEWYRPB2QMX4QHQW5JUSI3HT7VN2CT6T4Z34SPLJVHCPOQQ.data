ject.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct$3() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction noop() {}\n\nfunction bindMemberFunctions(inst) {\n  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n  mems.forEach(function (mem) {\n    if (typeof inst[mem] === 'function') {\n      inst[mem] = inst[mem].bind(inst);\n    }\n  });\n}\n\nvar I18n = function (_EventEmitter) {\n  _inherits(I18n, _EventEmitter);\n\n  var _super = _createSuper$3(I18n);\n\n  function I18n() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var callback = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck(this, I18n);\n\n    _this = _super.call(this);\n\n    if (isIE10) {\n      EventEmitter.call(_assertThisInitialized(_this));\n    }\n\n    _this.options = transformOptions(options);\n    _this.services = {};\n    _this.logger = baseLogger;\n    _this.modules = {\n      external: []\n    };\n    bindMemberFunctions(_assertThisInitialized(_this));\n\n    if (callback && !_this.isInitialized && !options.isClone) {\n      if (!_this.options.initImmediate) {\n        _this.init(options, callback);\n\n        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));\n      }\n\n      setTimeout(function () {\n        _this.init(options, callback);\n      }, 0);\n    }\n\n    return _this;\n  }\n\n  _createClass(I18n, [{\n    key: \"init\",\n    value: function init() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var callback = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      if (!options.defaultNS && options.ns) {\n        if (typeof options.ns === 'string') {\n          options.defaultNS = options.ns;\n        } else if (options.ns.indexOf('translation') < 0) {\n          options.defaultNS = options.ns[0];\n        }\n      }\n\n      var defOpts = get();\n      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options));\n\n      if (this.options.compatibilityAPI !== 'v1') {\n        this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation);\n      }\n\n      if (options.keySeparator !== undefined) {\n        this.options.userDefinedKeySeparator = options.keySeparator;\n      }\n\n      if (options.nsSeparator !== undefined) {\n        this.options.userDefinedNsSeparator = options.nsSeparator;\n      }\n\n      function createClassOnDemand(ClassOrObject) {\n        if (!ClassOrObject) return null;\n        if (typeof ClassOrObject === 'function') return new ClassOrObject();\n        return ClassOrObject;\n      }\n\n      if (!this.options.isClone) {\n        if (this.modules.logger) {\n          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n        } else {\n          baseLogger.init(null, this.options);\n        }\n\n        var formatter;\n\n        if (this.modules.formatter) {\n          formatter = this.modules.formatter;\n        } else if (typeof Intl !== 'undefined') {\n          formatter = Formatter;\n        }\n\n        var lu = new LanguageUtil(this.options);\n        this.store = new ResourceStore(this.options.resources, this.options);\n        var s = this.services;\n        s.logger = baseLogger;\n        s.resourceStore = this.store;\n        s.languageUtils = lu;\n        s.pluralResolver = new PluralResolver(lu, {\n          prepend: this.options.pluralSeparator,\n          compatibilityJSON: this.options.compatibilityJSON,\n          simplifyPluralSuffix: this.options.simplifyPluralSuffix\n        });\n\n        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n          s.formatter = createClassOnDemand(formatter);\n          s.formatter.init(s, this.options);\n          this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n        }\n\n        s.interpolator = new Interpolator(this.options);\n        s.utils = {\n          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n        };\n        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n        s.backendConnector.on('*', function (event) {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          _this2.emit.apply(_this2, [event].concat(args));\n        });\n\n        if (this.modules.languageDetector) {\n          s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n          s.languageDetector.init(s, this.options.detection, this.options);\n        }\n\n        if (this.modules.i18nFormat) {\n          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n          if (s.i18nFormat.init) s.i18nFormat.init(this);\n        }\n\n        this.translator = new Translator(this.services, this.options);\n        this.translator.on('*', function (event) {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          _this2.emit.apply(_this2, [event].concat(args));\n        });\n        this.modules.external.forEach(function (m) {\n          if (m.init) m.init(_this2);\n        });\n      }\n\n      this.format = this.options.interpolation.format;\n      if (!callback) callback = noop;\n\n      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n        if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];\n      }\n\n      if (!this.services.languageDetector && !this.options.lng) {\n        this.logger.warn('init: no languageDetector is used and no lng is defined');\n      }\n\n      var storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];\n      storeApi.forEach(function (fcName) {\n        _this2[fcName] = function () {\n          var _this2$store;\n\n          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);\n        };\n      });\n      var storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];\n      storeApiChained.forEach(function (fcName) {\n        _this2[fcName] = function () {\n          var _this2$store2;\n\n          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);\n\n          return _this2;\n        };\n      });\n      var deferred = defer();\n\n      var load = function load() {\n        var finish = function finish(err, t) {\n          if (_this2.isInitialized && !_this2.initializedStoreOnce) _this2.logger.warn('init: i18next is already initialized. You should call init just once!');\n          _this2.isInitialized = true;\n          if (!_this2.options.isClone) _this2.logger.log('initialized', _this2.options);\n\n          _this2.emit('initialized', _this2.options);\n\n          deferred.resolve(t);\n          callback(err, t);\n        };\n\n        if (_this2.languages && _this2.options.compatibilityAPI !== 'v1' && !_this2.isInitialized) return finish(null, _this2.t.bind(_this2));\n\n        _this2.changeLanguage(_this2.options.lng, finish);\n      };\n\n      if (this.options.resources || !this.options.initImmediate) {\n        load();\n      } else {\n        setTimeout(load, 0);\n      }\n\n      return deferred;\n    }\n  }, {\n    key: \"loadResources\",\n    value: function loadResources(language) {\n      var _this3 = this;\n\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n      var usedCallback = callback;\n      var usedLng = typeof language === 'string' ? language : this.language;\n      if (typeof language === 'function') usedCallback = language;\n\n      if (!this.options.resources || this.options.partialBundledLanguages) {\n        if (usedLng && usedLng.toLowerCase() === 'cimode') return usedCallback();\n        var toLoad = [];\n\n        var append = function append(lng) {\n          if (!lng) return;\n\n          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);\n\n          lngs.forEach(function (l) {\n            if (toLoad.indexOf(l) < 0) toLoad.push(l);\n          });\n        };\n\n        if (!usedLng) {\n          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n          fallbacks.forEach(function (l) {\n            return append(l);\n          });\n        } else {\n          append(usedLng);\n        }\n\n        if (this.options.preload) {\n          this.options.preload.forEach(function (l) {\n            return append(l);\n          });\n        }\n\n        this.services.backendConnector.load(toLoad, this.options.ns, function (e) {\n          if (!e && !_this3.resolvedLanguage && _this3.language) _this3.setResolvedLanguage(_this3.language);\n          usedCallback(e);\n        });\n      } else {\n        usedCallback(null);\n      }\n    }\n  }, {\n    key: \"reloadResources\",\n    value: function reloadResources(lngs, ns, callback) {\n      var deferred = defer();\n      if (!lngs) lngs = this.languages;\n      if (!ns) ns = this.options.ns;\n      if (!callback) callback = noop;\n      this.services.backendConnector.reload(lngs, ns, function (err) {\n        deferred.resolve();\n        callback(err);\n      });\n      return deferred;\n    }\n  }, {\n    key: \"use\",\n    value: function use(module) {\n      if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');\n      if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');\n\n      if (module.type === 'backend') {\n        this.modules.backend = module;\n      }\n\n      if (module.type === 'logger' || module.log && module.warn && module.error) {\n        this.modules.logger = module;\n      }\n\n      if (module.type === 'languageDetector') {\n        this.modules.languageDetector = module;\n      }\n\n      if (module.type === 'i18nFormat') {\n        this.modules.i18nFormat = module;\n      }\n\n      if (module.type === 'postProcessor') {\n        postProcessor.addPostProcessor(module);\n      }\n\n      if (module.type === 'formatter') {\n        this.modules.formatter = module;\n      }\n\n      if (module.type === '3rdParty') {\n        this.modules.external.push(module);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setResolvedLanguage\",\n    value: function setResolvedLanguage(l) {\n      if (!l || !this.languages) return;\n      if (['cimode', 'dev'].indexOf(l) > -1) return;\n\n      for (var li = 0; li < this.languages.length; li++) {\n        var lngInLngs = this.languages[li];\n        if (['cimode', 'dev'].indexOf(lngInLngs) > -1) continue;\n\n        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n          this.resolvedLanguage = lngInLngs;\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"changeLanguage\",\n    value: function changeLanguage(lng, callback) {\n      var _this4 = this;\n\n      this.isLanguageChangingTo = lng;\n      var deferred = defer();\n      this.emit('languageChanging', lng);\n\n      var setLngProps = function setLngProps(l) {\n        _this4.language = l;\n        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);\n        _this4.resolvedLanguage = undefined;\n\n        _this4.setResolvedLanguage(l);\n      };\n\n      var done = function done(err, l) {\n        if (l) {\n          setLngProps(l);\n\n          _this4.translator.changeLanguage(l);\n\n          _this4.isLanguageChangingTo = undefined;\n\n          _this4.emit('languageChanged', l);\n\n          _this4.logger.log('languageChanged', l);\n        } else {\n          _this4.isLanguageChangingTo = undefined;\n        }\n\n        deferred.resolve(function () {\n          return _this4.t.apply(_this4, arguments);\n        });\n        if (callback) callback(err, function () {\n          return _this4.t.apply(_this4, arguments);\n        });\n      };\n\n      var setLng = function setLng(lngs) {\n        if (!lng && !lngs && _this4.services.languageDetector) lngs = [];\n        var l = typeof lngs === 'string' ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);\n\n        if (l) {\n          if (!_this4.language) {\n            setLngProps(l);\n          }\n\n          if (!_this4.translator.language) _this4.translator.changeLanguage(l);\n          if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);\n        }\n\n        _this4.loadResources(l, function (err) {\n          done(err, l);\n        });\n      };\n\n      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n        setLng(this.services.languageDetector.detect());\n      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n        this.services.languageDetector.detect(setLng);\n      } else {\n        setLng(lng);\n      }\n\n      return deferred;\n    }\n  }, {\n    key: \"getFixedT\",\n    value: function getFixedT(lng, ns, keyPrefix) {\n      var _this5 = this;\n\n      var fixedT = function fixedT(key, opts) {\n        var options;\n\n        if (_typeof(opts) !== 'object') {\n          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n            rest[_key3 - 2] = arguments[_key3];\n          }\n\n          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));\n        } else {\n          options = _objectSpread$6({}, opts);\n        }\n\n        options.lng = options.lng || fixedT.lng;\n        options.lngs = options.lngs || fixedT.lngs;\n        options.ns = options.ns || fixedT.ns;\n        var keySeparator = _this5.options.keySeparator || '.';\n        var resultKey = keyPrefix ? \"\".concat(keyPrefix).concat(keySeparator).concat(key) : key;\n        return _this5.t(resultKey, options);\n      };\n\n      if (typeof lng === 'string') {\n        fixedT.lng = lng;\n      } else {\n        fixedT.lngs = lng;\n      }\n\n      fixedT.ns = ns;\n      fixedT.keyPrefix = keyPrefix;\n      return fixedT;\n    }\n  }, {\n    key: \"t\",\n    value: function t() {\n      var _this$translator;\n\n      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);\n    }\n  }, {\n    key: \"exists\",\n    value: function exists() {\n      var _this$translator2;\n\n      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);\n    }\n  }, {\n    key: \"setDefaultNamespace\",\n    value: function setDefaultNamespace(ns) {\n      this.options.defaultNS = ns;\n    }\n  }, {\n    key: \"hasLoadedNamespace\",\n    value: function hasLoadedNamespace(ns) {\n      var _this6 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!this.isInitialized) {\n        this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);\n        return false;\n      }\n\n      if (!this.languages || !this.languages.length) {\n        this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);\n        return false;\n      }\n\n      var lng = this.resolvedLanguage || this.languages[0];\n      var fallbackLng = this.options ? this.options.fallbackLng : false;\n      var lastLng = this.languages[this.languages.length - 1];\n      if (lng.toLowerCase() === 'cimode') return true;\n\n      var loadNotPending = function loadNotPending(l, n) {\n        var loadState = _this6.services.backendConnector.state[\"\".concat(l, \"|\").concat(n)];\n\n        return loadState === -1 || loadState === 2;\n      };\n\n      if (options.precheck) {\n        var preResult = options.precheck(this, loadNotPending);\n        if (preResult !== undefined) return preResult;\n      }\n\n      if (this.hasResourceBundle(lng, ns)) return true;\n      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n      return false;\n    }\n  }, {\n    key: \"loadNamespaces\",\n    value: function loadNamespaces(ns, callback) {\n      var _this7 = this;\n\n      var deferred = defer();\n\n      if (!this.options.ns) {\n        callback && callback();\n        return Promise.resolve();\n      }\n\n      if (typeof ns === 'string') ns = [ns];\n      ns.forEach(function (n) {\n        if (_this7.options.ns.indexOf(n) < 0) _this7.options.ns.push(n);\n      });\n      this.loadResources(function (err) {\n        deferred.resolve();\n        if (callback) callback(err);\n      });\n      return deferred;\n    }\n  }, {\n    key: \"loadLanguages\",\n    value: function loadLanguages(lngs, callback) {\n      var deferred = defer();\n      if (typeof lngs === 'string') lngs = [lngs];\n      var preloaded = this.options.preload || [];\n      var newLngs = lngs.filter(function (lng) {\n        return preloaded.indexOf(lng) < 0;\n      });\n\n      if (!newLngs.length) {\n        if (callback) callback();\n        return Promise.resolve();\n      }\n\n      this.options.preload = preloaded.concat(newLngs);\n      this.loadResources(function (err) {\n        deferred.resolve();\n        if (callback) callback(err);\n      });\n      return deferred;\n    }\n  }, {\n    key: \"dir\",\n    value: function dir(lng) {\n      if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);\n      if (!lng) return 'rtl';\n      var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'];\n      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';\n    }\n  }, {\n    key: \"cloneInstance\",\n    value: function cloneInstance() {\n      var _this8 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n\n      var mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options), {\n        isClone: true\n      });\n\n      var clone = new I18n(mergedOptions);\n      var membersToCopy = ['store', 'services', 'language'];\n      membersToCopy.forEach(function (m) {\n        clone[m] = _this8[m];\n      });\n      clone.services = _objectSpread$6({}, this.services);\n      clone.services.utils = {\n        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n      };\n      clone.translator = new Translator(clone.services, clone.options);\n      clone.translator.on('*', function (event) {\n        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n          args[_key4 - 1] = arguments[_key4];\n        }\n\n        clone.emit.apply(clone, [event].concat(args));\n      });\n      clone.init(mergedOptions, callback);\n      clone.translator.options = clone.options;\n      clone.translator.backendConnector.services.utils = {\n        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n      };\n      return clone;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        options: this.options,\n        store: this.store,\n        language: this.language,\n        languages: this.languages,\n        resolvedLanguage: this.resolvedLanguage\n      };\n    }\n  }]);\n\n  return I18n;\n}(EventEmitter);\n\n_defineProperty(I18n, \"createInstance\", function () {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var callback = arguments.length > 1 ? arguments[1] : undefined;\n  return new I18n(options, callback);\n});\n\nvar instance = I18n.createInstance();\ninstance.createInstance = I18n.createInstance;\n\nvar createInstance = instance.createInstance;\nvar init = instance.init;\nvar loadResources = instance.loadResources;\nvar reloadResources = instance.reloadResources;\nvar use = instance.use;\nvar changeLanguage = instance.changeLanguage;\nvar getFixedT = instance.getFixedT;\nvar t = instance.t;\nvar exists = instance.exists;\nvar setDefaultNamespace = instance.setDefaultNamespace;\nvar hasLoadedNamespace = instance.hasLoadedNamespace;\nvar loadNamespaces = instance.loadNamespaces;\nvar loadLanguages = instance.loadLanguages;\n\nexport default instance;\nexport { changeLanguage, createInstance, exists, getFixedT, hasLoadedNamespace, init, loadLanguages, loadNamespaces, loadResources, reloadResources, setDefaultNamespace, t, use };\n","/**\n * Implementation of the multicodec specification.\n *\n * @module multicodec\n * @example\n * const multicodec = require('multicodec')\n *\n * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)\n * // prefixedProtobuf 0x50...\n *\n */\n'use strict'\n\n/** @typedef {import('./generated-types').CodecName} CodecName */\n/** @typedef {import('./generated-types').CodecCode} CodecCode */\n\nconst varint = require('varint')\nconst uint8ArrayConcat = require('uint8arrays/concat')\nconst util = require('./util')\nconst { nameToVarint, constantToCode, nameToCode, codeToName } = require('./maps')\n\n/**\n * Prefix a buffer with a multicodec-packed.\n *\n * @param {CodecName|Uint8Array} multicodecStrOrCode\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n */\nfunction addPrefix (multicodecStrOrCode, data) {\n  let prefix\n\n  if (multicodecStrOrCode instanceof Uint8Array) {\n    prefix = util.varintUint8ArrayEncode(multicodecStrOrCode)\n  } else {\n    if (nameToVarint[multicodecStrOrCode]) {\n      prefix = nameToVarint[multicodecStrOrCode]\n    } else {\n      throw new Error('multicodec not recognized')\n    }\n  }\n\n  return uint8ArrayConcat([prefix, data], prefix.length + data.length)\n}\n\n/**\n * Decapsulate the multicodec-packed prefix from the data.\n *\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n */\nfunction rmPrefix (data) {\n  varint.decode(/** @type {Buffer} */(data))\n  return data.slice(varint.decode.bytes)\n}\n\n/**\n * Get the codec name of the prefixed data.\n *\n * @param {Uint8Array} prefixedData\n * @returns {CodecName}\n */\nfunction getNameFromData (prefixedData) {\n  const code = /** @type {CodecCode} */(varint.decode(/** @type {Buffer} */(prefixedData)))\n  const name = codeToName[code]\n  if (name === undefined) {\n    throw new Error(`Code \"${code}\" not found`)\n  }\n  return name\n}\n\n/**\n * Get the codec name from a code.\n *\n * @param {CodecCode} codec\n * @returns {CodecName}\n */\nfunction getNameFromCode (codec) {\n  return codeToName[codec]\n}\n\n/**\n * Get the code of the codec\n *\n * @param {CodecName} name\n * @returns {CodecCode}\n */\nfunction getCodeFromName (name) {\n  const code = nameToCode[name]\n  if (code === undefined) {\n    throw new Error(`Codec \"${name}\" not found`)\n  }\n  return code\n}\n\n/**\n * Get the code of the prefixed data.\n *\n * @param {Uint8Array} prefixedData\n * @returns {CodecCode}\n */\nfunction getCodeFromData (prefixedData) {\n  return /** @type {CodecCode} */(varint.decode(/** @type {Buffer} */(prefixedData)))\n}\n\n/**\n * Get the code as varint of a codec name.\n *\n * @param {CodecName} name\n * @returns {Uint8Array}\n */\nfunction getVarintFromName (name) {\n  const code = nameToVarint[name]\n  if (code === undefined) {\n    throw new Error(`Codec \"${name}\" not found`)\n  }\n  return code\n}\n\n/**\n * Get the varint of a code.\n *\n * @param {CodecCode} code\n * @returns {Uint8Array}\n */\nfunction getVarintFromCode (code) {\n  return util.varintEncode(code)\n}\n\n/**\n * Get the codec name of the prefixed data.\n *\n * @deprecated use getNameFromData instead.\n * @param {Uint8Array} prefixedData\n * @returns {CodecName}\n */\nfunction getCodec (prefixedData) {\n  return getNameFromData(prefixedData)\n}\n\n/**\n * Get the codec name from a code.\n *\n * @deprecated use getNameFromCode instead.\n * @param {CodecCode} codec\n * @returns {CodecName}\n */\nfunction getName (codec) {\n  return getNameFromCode(codec)\n}\n\n/**\n * Get the code of the codec\n *\n * @deprecated use getCodeFromName instead.\n * @param {CodecName} name\n * @returns {CodecCode}\n */\nfunction getNumber (name) {\n  return getCodeFromName(name)\n}\n\n/**\n * Get the code of the prefixed data.\n *\n * @deprecated use getCodeFromData instead.\n * @param {Uint8Array} prefixedData\n * @returns {CodecCode}\n */\nfunction getCode (prefixedData) {\n  return getCodeFromData(prefixedData)\n}\n\n/**\n * Get the code as varint of a codec name.\n *\n * @deprecated use getVarintFromName instead.\n * @param {CodecName} name\n * @returns {Uint8Array}\n */\nfunction getCodeVarint (name) {\n  return getVarintFromName(name)\n}\n\n/**\n * Get the varint of a code.\n *\n * @deprecated use getVarintFromCode instead.\n * @param {CodecCode} code\n * @returns {Array.<number>}\n */\nfunction getVarint (code) {\n  return Array.from(getVarintFromCode(code))\n}\n\nmodule.exports = {\n  addPrefix,\n  rmPrefix,\n  getNameFromData,\n  getNameFromCode,\n  getCodeFromName,\n  getCodeFromData,\n  getVarintFromName,\n  getVarintFromCode,\n  // Deprecated\n  getCodec,\n  getName,\n  getNumber,\n  getCode,\n  getCodeVarint,\n  getVarint,\n  // Make the constants top-level constants\n  ...constantToCode,\n  // Export the maps\n  nameToVarint,\n  nameToCode,\n  codeToName\n}\n","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","export function registerTarget(type, target, manager) {\n  var registry = manager.getRegistry();\n  var targetId = registry.addTarget(type, target);\n  return [targetId, function () {\n    return registry.removeTarget(targetId);\n  }];\n}\nexport function registerSource(type, source, manager) {\n  var registry = manager.getRegistry();\n  var sourceId = registry.addSource(type, source);\n  return [sourceId, function () {\n    return registry.removeSource(sourceId);\n  }];\n}","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nvar setPrototypeOf = require(\"./setPrototypeOf\");\n\nvar isNativeFunction = require(\"./isNativeFunction\");\n\nvar construct = require(\"./construct\");\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nmodule.exports = _wrapNativeSuper;","'use strict'\n\nconst CID = require('cids')\n\nconst { version } = require('../package.json')\nconst blockSymbol = Symbol.for('@ipld/js-ipld-block/block')\nconst readonly = { writable: false, configurable: false, enumerable: true }\n\n/**\n * Represents an immutable block of data that is uniquely referenced with a cid.\n *\n * @example\n * const block = new Block(Uint8Array.from([0, 1, 2, 3]), new CID('...'))\n */\nclass Block {\n  /**\n   * @param {Uint8Array} data - The data to be stored in the block as a Uint8Array.\n   * @param {CID} cid - The cid of the data\n   */\n  constructor (data, cid) {\n    if (!data || !(data instanceof Uint8Array)) {\n      throw new Error('first argument  must be a Uint8Array')\n    }\n\n    if (!cid || !CID.isCID(cid)) {\n      throw new Error('second argument must be a CID')\n    }\n\n    this.data = data\n    this.cid = cid\n\n    Object.defineProperties(this, {\n      data: readonly,\n      cid: readonly\n    })\n  }\n\n  /**\n   * The data of this block.\n   *\n   * @deprecated\n   * @type {Uint8Array}\n   */\n  get _data () {\n    deprecateData()\n    return this.data\n  }\n\n  /**\n   * The cid of the data this block represents.\n   *\n   * @deprecated\n   * @type {CID}\n   */\n  get _cid () {\n    deprecateCID()\n    return this.cid\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Block'\n  }\n\n  get [blockSymbol] () {\n    return true\n  }\n\n  /**\n   * Check if the given value is a Block.\n   *\n   * @param {any} other\n   * @returns {other is Block}\n   */\n  static isBlock (other) {\n    return Boolean(other && other[blockSymbol])\n  }\n}\n\n/**\n * @param {RegExp} range\n * @param {string} message\n * @returns {() => void}\n */\nconst deprecate = (range, message) => {\n  let warned = false\n  return () => {\n    if (range.test(version)) {\n      if (!warned) {\n        warned = true\n        // eslint-disable-next-line no-console\n        console.warn(message)\n      }\n    } else {\n      throw new Error(message)\n    }\n  }\n}\n\nconst deprecateCID = deprecate(/^0\\.10|^0\\.11/, 'block._cid is deprecated and will be removed in 0.12 release. Please use block.cid instead')\nconst deprecateData = deprecate(/^0\\.10|^0.11/, 'block._data is deprecated and will be removed in 0.12 release. Please use block.data instead')\n\nmodule.exports = Block\n","export default !!(typeof window !== 'undefined' && window.document && window.document.createElement);","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar cid = require('./cid.js');\nvar varint = require('./varint.js');\nvar bytes = require('./bytes.js');\nvar hasher = require('./hashes/hasher.js');\nvar digest = require('./hashes/digest.js');\n\n\n\nexports.CID = cid.CID;\nexports.varint = varint;\nexports.bytes = bytes;\nexports.hasher = hasher;\nexports.digest = digest;\n","import React from 'react';\nimport Loadable from '@loadable/component';\nimport ComponentLoader from '../loader/ComponentLoader.js';\nvar LoadableSettingsPage = Loadable(function () {\n  return import('./IpldGraphCytoscape');\n}, {\n  fallback: /*#__PURE__*/React.createElement(ComponentLoader, null)\n});\nexport default LoadableSettingsPage;","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from 'react';\n\nvar StrokeIpld = function StrokeIpld(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 100 100\"\n  }, props), /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M87.714 44.764c0-1.157-.45-2.245-1.269-3.062a4.304 4.304 0 0 0-3.063-1.269 4.304 4.304 0 0 0-3.062 1.269 4.337 4.337 0 0 0 0 6.125c.602.602 1.351 1 2.164 1.172v2.442l-14.686 9.276v-19.79l4.498-2.842v-3.717a4.27 4.27 0 0 0 1.827-1.067 4.337 4.337 0 0 0 0-6.125 4.337 4.337 0 0 0-6.126 0 4.304 4.304 0 0 0-1.269 3.063c0 1.157.45 2.245 1.269 3.062a4.282 4.282 0 0 0 1.963 1.107v2.391L51.236 48.627v-8.901l9.304-5.877v-7.051a4.282 4.282 0 0 0 1.986-1.114 4.336 4.336 0 0 0-.001-6.125 4.337 4.337 0 0 0-6.125 0h-.001a4.337 4.337 0 0 0 0 6.125c.52.519 1.145.859 1.804 1.059v5.818l-6.967 4.401V15.561a4.283 4.283 0 0 0 2.008-1.12 4.337 4.337 0 0 0-.001-6.126 4.337 4.337 0 0 0-6.125 0h-.001a4.337 4.337 0 0 0 .001 6.126 4.273 4.273 0 0 0 1.782 1.053v15.881l-7.229-4.566v-3.436a4.292 4.292 0 0 0 2.008-1.12 4.337 4.337 0 0 0 0-6.125 4.337 4.337 0 0 0-6.126 0 4.304 4.304 0 0 0-1.269 3.063c0 1.157.45 2.245 1.269 3.062a4.276 4.276 0 0 0 1.781 1.053v4.79l9.565 6.042v21.108l-7.708-4.226v-7.809a4.275 4.275 0 0 0 2.034-1.128 4.337 4.337 0 0 0 0-6.125 4.337 4.337 0 0 0-6.126 0 4.304 4.304 0 0 0-1.269 3.063c0 1.157.45 2.245 1.269 3.062a4.284 4.284 0 0 0 1.756 1.046v6.61L27.15 43.322v-6.217a4.28 4.28 0 0 0 1.984-1.117 4.3 4.3 0 0 0 1.27-3.063c0-1.157-.45-2.245-1.269-3.062a4.336 4.336 0 0 0-6.126 0 4.337 4.337 0 0 0 0 6.125c.51.51 1.132.858 1.804 1.062v7.621l3.646 2.004v13.632l-10.582-5.77v-2.418a4.29 4.29 0 0 0 2.051-1.133 4.337 4.337 0 0 0 0-6.125 4.304 4.304 0 0 0-3.062-1.269 4.304 4.304 0 0 0-3.063 1.269 4.337 4.337 0 0 0 0 6.125 4.285 4.285 0 0 0 1.738 1.041v3.812L48.9 74.108v11.397a4.277 4.277 0 0 0-1.783 1.053 4.337 4.337 0 0 0 0 6.125 4.32 4.32 0 0 0 3.063 1.266 4.316 4.316 0 0 0 3.063-1.267 4.337 4.337 0 0 0 0-6.125 4.29 4.29 0 0 0-2.008-1.119V73.943L84.82 52.727v-3.892a4.29 4.29 0 0 0 1.625-1.008 4.3 4.3 0 0 0 1.269-3.063zM30.586 61.468V47.844L48.9 57.91v13.542l-18.314-9.984zm34.876-19.065v19.79l-14.227 8.986v-19.79l14.227-8.986zm3.067-12.164c0-.676.264-1.312.742-1.79a2.525 2.525 0 0 1 1.79-.74c.647 0 1.296.247 1.789.74a2.536 2.536 0 0 1 0 3.581 2.535 2.535 0 0 1-3.579 0 2.516 2.516 0 0 1-.742-1.791zm-10.857-9.407a2.534 2.534 0 0 1 3.58 0 2.534 2.534 0 0 1 0 3.58 2.534 2.534 0 0 1-3.58 0 2.534 2.534 0 0 1 0-3.58zM48.389 9.589a2.536 2.536 0 0 1 3.581 0c.987.987.987 2.593.001 3.58a2.536 2.536 0 0 1-3.581 0 2.535 2.535 0 0 1-.001-3.58zM38.084 19.19c0-.676.264-1.312.742-1.79a2.525 2.525 0 0 1 1.79-.74c.647 0 1.296.247 1.789.74a2.536 2.536 0 0 1 0 3.581 2.535 2.535 0 0 1-3.579 0 2.52 2.52 0 0 1-.742-1.791zm-.453 19.832c0-.676.264-1.312.742-1.79a2.525 2.525 0 0 1 1.79-.74c.647 0 1.296.247 1.789.74a2.536 2.536 0 0 1 0 3.581 2.535 2.535 0 0 1-3.58 0 2.525 2.525 0 0 1-.741-1.791zm-13.348-7.887a2.524 2.524 0 0 1 1.789-.74 2.526 2.526 0 0 1 2.532 2.531c0 .677-.264 1.312-.742 1.79-.422.422-.984.647-1.562.696h-.456c-.577-.049-1.139-.274-1.561-.696a2.534 2.534 0 0 1 0-3.581zm-9.207 14.999a2.514 2.514 0 0 1 1.79-.742 2.534 2.534 0 0 1 1.789 4.322 2.533 2.533 0 0 1-3.579 0 2.533 2.533 0 0 1 0-3.58zM51.97 91.411a2.534 2.534 0 0 1-3.58 0 2.534 2.534 0 0 1 0-3.58 2.536 2.536 0 0 1 3.58 0 2.534 2.534 0 0 1 0 3.58zm33.202-44.857c-.955.955-2.624.957-3.579 0a2.534 2.534 0 0 1 1.789-4.322c.677 0 1.312.264 1.791.742.478.478.741 1.113.741 1.79s-.263 1.311-.742 1.79z\"\n  }));\n};\n\nexport default StrokeIpld;","function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport React from 'react';\nimport { connect } from 'redux-bundler-react';\nimport { withTranslation } from 'react-i18next';\nimport StrokeIpld from '../../icons/StrokeIpld';\n\nvar IpldExploreForm = /*#__PURE__*/function (_React$Component) {\n  _inherits(IpldExploreForm, _React$Component);\n\n  var _super = _createSuper(IpldExploreForm);\n\n  function IpldExploreForm(props) {\n    var _this;\n\n    _classCallCheck(this, IpldExploreForm);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      path: ''\n    };\n    _this.handleOnChange = _this.handleOnChange.bind(_assertThisInitialized(_this));\n    _this.handleOnSubmit = _this.handleOnSubmit.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(IpldExploreForm, [{\n    key: \"handleOnSubmit\",\n    value: function handleOnSubmit(evt) {\n      evt.preventDefault();\n      this.props.doExploreUserProvidedPath(this.state.path);\n    }\n  }, {\n    key: \"handleOnChange\",\n    value: function handleOnChange(evt) {\n      var path = evt.target.value;\n      this.setState({\n        path: path\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var t = this.props.t;\n      return /*#__PURE__*/React.createElement(\"form\", {\n        \"data-id\": \"IpldExploreForm\",\n        className: \"sans-serif black-80 flex\",\n        onSubmit: this.handleOnSubmit\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        className: \"flex-auto\"\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        className: \"relative\"\n      }, /*#__PURE__*/React.createElement(\"input\", {\n        id: \"ipfs-path\",\n        className: \"input-reset bn pa2 mb2 db w-100 f6 br-0 placeholder-light focus-outline\",\n        style: {\n          borderRadius: '3px 0 0 3px'\n        },\n        type: \"text\",\n        placeholder: \"QmHash\",\n        \"aria-describedby\": \"name-desc\",\n        onChange: this.handleOnChange,\n        value: this.state.path\n      }), /*#__PURE__*/React.createElement(\"small\", {\n        id: \"ipfs-path-desc\",\n        className: \"o-0 absolute f6 black-60 db mb2\"\n      }, \"Paste in a CID or IPFS path\"))), /*#__PURE__*/React.createElement(\"div\", {\n        className: \"flex-none\"\n      }, /*#__PURE__*/React.createElement(\"button\", {\n        type: \"submit\",\n        className: \"button-reset dib lh-copy pv1 pl2 pr3 ba f7 fw4 focus-outline white bg-aqua bn\",\n        style: {\n          borderRadius: '0 3px 3px 0'\n        }\n      }, /*#__PURE__*/React.createElement(StrokeIpld, {\n        style: {\n          height: 24\n        },\n        className: \"dib fill-current-color v-mid navy 0-100\"\n      }), /*#__PURE__*/React.createElement(\"span\", {\n        className: \"ml2 navy 0-100\"\n      }, t('IpldExploreForm.explore')))));\n    }\n  }]);\n\n  return IpldExploreForm;\n}(React.Component);\n\nexport default connect('doExploreUserProvidedPath', withTranslation('explore')(IpldExploreForm));","export default __webpack_public_path__ + \"static/media/ipld.c2e6094f.svg\";","import React from 'react';\nimport { Trans, withTranslation } from 'react-i18next';\nimport Box from '../box/Box';\nimport ipldLogoSrc from './ipld.svg';\nexport var AboutIpld = function AboutIpld(_ref) {\n  var t = _ref.t;\n  return /*#__PURE__*/React.createElement(Box, {\n    className: \"tl dib pa4 avenir measure-wide-l lh-copy dark-gray ba-l b--black-10\"\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"tc\"\n  }, /*#__PURE__*/React.createElement(\"a\", {\n    className: \"link\",\n    href: \"https://ipld.io\"\n  }, /*#__PURE__*/React.createElement(\"img\", {\n    src: ipldLogoSrc,\n    alt: \"IPLD\",\n    style: {\n      height: 60\n    }\n  }))), /*#__PURE__*/React.createElement(Trans, {\n    i18nKey: \"AboutIpld.paragraph1\",\n    t: t\n  }, /*#__PURE__*/React.createElement(\"p\", null, \"IPLD is \", /*#__PURE__*/React.createElement(\"strong\", null, \"the data model of the content-addressable web.\"), \" It allows us to treat all hash-linked data structures as subsets of a unified information space, unifying all data models that link data with hashes as instances of IPLD.\")), /*#__PURE__*/React.createElement(Trans, {\n    i18nKey: \"AboutIpld.paragraph2\",\n    t: t\n  }, /*#__PURE__*/React.createElement(\"p\", null, \"Content addressing through hashes has become a widely-used means of connecting data in distributed systems, from the blockchains that run your favorite cryptocurrencies, to the commits that back your code, to the web\\u2019s content at large. Yet, whilst all of these tools rely on some common primitives, their specific underlying data structures are not interoperable.\")), /*#__PURE__*/React.createElement(Trans, {\n    i18nKey: \"AboutIpld.paragraph3\",\n    t: t\n  }, /*#__PURE__*/React.createElement(\"p\", null, \"Enter IPLD: a single namespace for all hash-inspired protocols. Through IPLD, links can be traversed across protocols, allowing you to explore data regardless of the underlying protocol.\")));\n};\nexport default withTranslation('explore')(AboutIpld);","import React from 'react';\nimport { Helmet } from 'react-helmet';\nimport { withTranslation } from 'react-i18next';\nimport { colorForNode, nameForNode, shortNameForNode } from './object-info/ObjectInfo';\nimport IpldExploreForm from './explore/IpldExploreForm';\nimport AboutIpld from './about/AboutIpld';\nimport ReactJoyride from 'react-joyride';\nimport { projectsTour } from '../lib/tours';\n\nvar ExploreSuggestion = function ExploreSuggestion(_ref) {\n  var cid = _ref.cid,\n      name = _ref.name,\n      type = _ref.type;\n  return /*#__PURE__*/React.createElement(\"a\", {\n    className: \"flex items-center lh-copy pl3 pl0-l pv3 bb b--black-10 link focus-outline\",\n    href: \"#/explore/\".concat(cid)\n  }, /*#__PURE__*/React.createElement(\"span\", {\n    className: \"flex items-center justify-center w3 h3 flex-none br-100 tc\",\n    style: {\n      background: colorForNode(type)\n    }\n  }, /*#__PURE__*/React.createElement(\"span\", {\n    className: \"montserrat fw2 f4 snow\",\n    title: nameForNode(type)\n  }, shortNameForNode(type))), /*#__PURE__*/React.createElement(\"span\", {\n    className: \"pl3 truncate\"\n  }, /*#__PURE__*/React.createElement(\"h2\", {\n    className: \"ma0 fw4 f5 db black montserrat\"\n  }, name), /*#__PURE__*/React.createElement(\"span\", {\n    className: \"f7 db blue truncate monospace\"\n  }, cid)));\n};\n\nvar StartExploringPage = function StartExploringPage(_ref2) {\n  var t = _ref2.t,\n      embed = _ref2.embed,\n      _ref2$runTour = _ref2.runTour,\n      runTour = _ref2$runTour === void 0 ? false : _ref2$runTour,\n      joyrideCallback = _ref2.joyrideCallback;\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"mw9 center explore-sug-2\"\n  }, /*#__PURE__*/React.createElement(Helmet, null, /*#__PURE__*/React.createElement(\"title\", null, t('StartExploringPage.title'))), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"flex-l\"\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"flex-auto-l mr3-l\"\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"pl3 pl0-l pt4 pt2-l\"\n  }, /*#__PURE__*/React.createElement(\"h1\", {\n    className: \"f3 f2-l ma0 fw4 montserrat charcoal\"\n  }, t('StartExploringPage.header')), /*#__PURE__*/React.createElement(\"p\", {\n    className: \"lh-copy f5 avenir charcoal-muted\"\n  }, t('StartExploringPage.leadParagraph'))), embed ? /*#__PURE__*/React.createElement(IpldExploreForm, null) : null, /*#__PURE__*/React.createElement(\"ul\", {\n    className: \"list pl0 ma0 mt4 mt0-l bt bn-l b--black-10\"\n  }, /*#__PURE__*/React.createElement(\"li\", null, /*#__PURE__*/React.createElement(ExploreSuggestion, {\n    name: \"Project Apollo Archives\",\n    cid: \"QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D\",\n    type: \"dag-pb\"\n  })), /*#__PURE__*/React.createElement(\"li\", null, /*#__PURE__*/React.createElement(ExploreSuggestion, {\n    name: \"IGIS Git Repo\",\n    cid: \"baf4bcfg4ep767tjp5lxyanx5urpjjgx5q2volvy\",\n    type: \"git-raw\"\n  })), /*#__PURE__*/React.createElement(\"li\", null, /*#__PURE__*/React.createElement(ExploreSuggestion, {\n    name: \"An Ethereum Block\",\n    cid: \"bagiacgzah24drzou2jlkixpblbgbg6nxfrasoklzttzoht5hixhxz3rlncyq\",\n    type: \"eth-block\"\n  })), /*#__PURE__*/React.createElement(\"li\", null, /*#__PURE__*/React.createElement(ExploreSuggestion, {\n    name: \"XKCD Archives\",\n    cid: \"QmdmQXB2mzChmMeKY47C43LxUdg1NDJ5MWcKMKxDu7RgQm\",\n    type: \"dag-pb\"\n  })))), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"pt2-l\"\n  }, /*#__PURE__*/React.createElement(AboutIpld, null))), /*#__PURE__*/React.createElement(ReactJoyride, {\n    run: runTour,\n    steps: projectsTour.getSteps({\n      t: t\n    }),\n    styles: projectsTour.styles,\n    callback: joyrideCallback,\n    scrollToFirstStep: true\n  }));\n};\n/* TODO: add dag-cbor and raw block examples\n          <li>\n            <ExploreSuggestion name='DAG-CBOR Block' cid='bafyreicnokmhmrnlp2wjhyk2haep4tqxiptwfrp2rrs7rzq7uk766chqvq' type='dag-cbor' />\n          </li>\n          <li>\n            <ExploreSuggestion name='Raw Block for \"hello\"' cid='bafkreibm6jg3ux5qumhcn2b3flc3tyu6dmlb4xa7u5bf44yegnrjhc4yeq' type='raw' />\n          </li>\n*/\n\n\nexport default withTranslation('explore')(StartExploringPage);","import React from 'react';\nimport Loadable from '@loadable/component';\nimport ComponentLoader from './loader/ComponentLoader.js';\nvar LoadableExplorePage = Loadable(function () {\n  return import('./ExplorePage');\n}, {\n  fallback: /*#__PURE__*/React.createElement(ComponentLoader, null)\n});\nexport default LoadableExplorePage;","function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport React from 'react';\nimport { connect } from 'redux-bundler-react';\nimport { withTranslation } from 'react-i18next';\n\nvar IpldCarExploreForm = /*#__PURE__*/function (_React$Component) {\n  _inherits(IpldCarExploreForm, _React$Component);\n\n  var _super = _createSuper(IpldCarExploreForm);\n\n  function IpldCarExploreForm(props) {\n    var _this;\n\n    _classCallCheck(this, IpldCarExploreForm);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      file: {}\n    };\n    _this.handleOnChange = _this.handleOnChange.bind(_assertThisInitialized(_this));\n    _this.handleOnSubmit = _this.handleOnSubmit.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(IpldCarExploreForm, [{\n    key: \"handleOnSubmit\",\n    value: function handleOnSubmit(evt) {\n      evt.preventDefault();\n    }\n  }, {\n    key: \"handleOnChange\",\n    value: function handleOnChange() {\n      var spinnerImage = require('./spinner.svg')[\"default\"];\n\n      var uploadImage = require('./upload.svg')[\"default\"]; //  Change the state.\n\n\n      var imageFileLoader = document.getElementById('car-loader-image');\n      imageFileLoader.src = spinnerImage; //  Get the file, upload car.\n\n      var selectedFile = document.getElementById('car-file').files[0];\n      this.props.doUploadUserProvidedCar(selectedFile, uploadImage);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var t = this.props.t;\n      return /*#__PURE__*/React.createElement(\"form\", {\n        \"data-id\": \"IpldCarExploreForm\",\n        className: \"sans-serif black-80 flex\",\n        onSubmit: this.handleOnSubmit,\n        encType: \"multipart/form-data\"\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        className: \"flex-auto\"\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        className: \"relative\"\n      }, /*#__PURE__*/React.createElement(\"input\", {\n        id: \"car-file\",\n        type: \"file\",\n        accept: \".car\",\n        className: \"input-reset bn pa2 mb2 db w-100 f6 br-0 placeholder-light focus-outline\",\n        style: {\n          borderRadius: '3px 0 0 3px',\n          backgroundColor: 'white',\n          padding: '5px 0px 5px 5px',\n          width: '99%'\n        },\n        \"aria-describedby\": \"name-desc\",\n        onChange: this.handleOnChange\n      }), /*#__PURE__*/React.createElement(\"small\", {\n        id: \"car-file-desc\",\n        className: \"o-0 absolute f6 black-60 db mb2\"\n      }, t('IpldCarExploreForm.uploadCarFile')), /*#__PURE__*/React.createElement(\"img\", {\n        id: \"car-loader-image\",\n        alt: \"placeholder for upload and loader\",\n        src: require('./upload.svg')[\"default\"],\n        className: \"absolute\",\n        style: {\n          top: '0px',\n          right: '0px',\n          height: '30px',\n          width: '30px',\n          paddingRight: '10px'\n        }\n      }))));\n    }\n  }]);\n\n  return IpldCarExploreForm;\n}(React.Component);\n\nexport default connect('doUploadUserProvidedCar', withTranslation('explore')(IpldCarExploreForm));","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport normaliseDagNode from './normalise-dag-node';\nimport Cid from 'cids';\n/**\n * Walk an IPLD path to find all the nodes and path boundaries it traverses.\n *\n * Normalizes nodes into a common structure:\n *\n * ```js\n * { cid: String, type: 'dag-cbor' | 'dag-pb' | 'git-raw' | ..., data: *, links: [{cid, name}] }\n * ```\n *\n * Path boundaries capture the source and target cid where a path traverses a link:\n *\n * ```js\n * { linkPath: 'a/b', source: `zdpHash1` target: `zdpHash2`' }\n * ```\n *\n * Usage:\n * ```js\n * const res = resolveIpldPath(getIpfs, 'zdpuHash' '/favourites/0/a/css')\n * const {targetNode, canonicalPath, localPath, nodes, pathBoundaries} = res\n * ```\n * Where:\n * - `targetNode` is the normalised node that the path lands in.\n * - `canonicalPath` is the shortest cid + path that can be used to locate the targetNode\n * - `localPath` is the tail part of the path that is local to the targetNode. May be ''\n * - `nodes` is the array of nodes that the path traverses.\n * - `pathBoundaries` is the array of links that the path traverses.\n *\n * @param {function()} ipldGet fn that returns a promise of the ipld data for a (cid, path, options)\n * @param {string} sourceCid the root hash\n * @param {string} path everything after the hash\n * @param {Object[]} nodes accumulated node info\n * @param {Object[]} pathBoundaries accumulated path boundary info\n * @returns {{targetNode: Object, canonicalPath: String, localPath: String, nodes: Object[], pathBoundaries: Object[]}} resolved path info\n */\n\nexport default function resolveIpldPath(_x, _x2, _x3) {\n  return _resolveIpldPath.apply(this, arguments);\n}\n\nfunction _resolveIpldPath() {\n  _resolveIpldPath = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(ipld, sourceCid, path) {\n    var nodes,\n        pathBoundaries,\n        _yield$ipldGetNodeAnd,\n        value,\n        remainderPath,\n        sourceCidStr,\n        node,\n        linkPath,\n        link,\n        canonicalPath,\n        targetNode,\n        _args = arguments;\n\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            nodes = _args.length > 3 && _args[3] !== undefined ? _args[3] : [];\n            pathBoundaries = _args.length > 4 && _args[4] !== undefined ? _args[4] : [];\n            _context.next = 4;\n            return ipldGetNodeAndRemainder(ipld, sourceCid, path);\n\n          case 4:\n            _yield$ipldGetNodeAnd = _context.sent;\n            value = _yield$ipldGetNodeAnd.value;\n            remainderPath = _yield$ipldGetNodeAnd.remainderPath;\n            sourceCidStr = sourceCid.toString();\n            node = normaliseDagNode(value, sourceCidStr);\n            nodes.push(node);\n            linkPath = findLinkPath(path, remainderPath);\n            link = findLink(node, linkPath);\n\n            if (!link) {\n              _context.next = 15;\n              break;\n            }\n\n            pathBoundaries.push(link); // Go again, using the link.target as the sourceCid, and the remainderPath as the path.\n\n            return _context.abrupt(\"return\", resolveIpldPath(ipld, new Cid(link.target), remainderPath, nodes, pathBoundaries));\n\n          case 15:\n            // we made it to the containing node. Hand back the info\n            canonicalPath = path ? \"\".concat(sourceCidStr).concat(path) : sourceCidStr;\n            targetNode = node;\n            return _context.abrupt(\"return\", {\n              targetNode: targetNode,\n              canonicalPath: canonicalPath,\n              localPath: path,\n              nodes: nodes,\n              pathBoundaries: pathBoundaries\n            });\n\n          case 18:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _resolveIpldPath.apply(this, arguments);\n}\n\nexport function ipldGetNodeAndRemainder(_x4, _x5, _x6) {\n  return _ipldGetNodeAndRemainder.apply(this, arguments);\n}\n/**\n * Find the link object that matches linkPath\n *\n * @param {Object} node a `normalisedDagNode`\n * @param {Object} linkPath an IPLD path string\n * @returns {Object} the link object for `linkPath`\n */\n\nfunction _ipldGetNodeAndRemainder() {\n  _ipldGetNodeAndRemainder = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(ipld, sourceCid, path) {\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return ipld.get(sourceCid);\n\n          case 2:\n            _context2.t0 = _context2.sent;\n            _context2.next = 5;\n            return ipld.resolve(sourceCid, path || '/').first();\n\n          case 5:\n            _context2.t1 = _context2.sent.remainderPath;\n            return _context2.abrupt(\"return\", {\n              value: _context2.t0,\n              remainderPath: _context2.t1\n            });\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _ipldGetNodeAndRemainder.apply(this, arguments);\n}\n\nexport function findLink(node, linkPath) {\n  if (!linkPath) return null;\n  if (!node) return null;\n  var links = node.links;\n  var link = links.find(function (link) {\n    return link.path === linkPath;\n  });\n  return link;\n}\nexport function findLinkPath(fullPath, remainderPath) {\n  if (!fullPath || fullPath === '/') return null;\n  if (!remainderPath) return trimSlashes(fullPath);\n\n  if (!fullPath.endsWith(remainderPath)) {\n    throw new Error('Requested IPLD path should end with the remainder path', {\n      fullPath: fullPath,\n      remainderPath: remainderPath\n    });\n  } // Remove remainder path from end of full path to get link path\n\n\n  var linkPath = fullPath.substring(0, fullPath.length - remainderPath.length);\n  return trimSlashes(linkPath);\n}\nexport function trimSlashes(str) {\n  if (str.startsWith('/')) {\n    str = str.substring(1);\n  }\n\n  if (str.endsWith('/')) {\n    str = str.substring(0, str.length - 1);\n  }\n\n  return str;\n}","/*\n  Capture groups 1\n  1: ipns | ipfs | ipld\n  2: CID | fqdn\n  3: /rest\n*/\nexport var pathRegEx = /(\\/(ipns|ipfs|ipld)\\/)?([^/]+)(\\/.*)?/;\nexport default function parseIpldPath(str) {\n  var res = pathRegEx.exec(str);\n  if (!res) return null;\n  return {\n    namespace: res[2],\n    // 'ipfs'\n    cidOrFqdn: res[3],\n    // 'QmHash'\n    rest: res[4],\n    // /foo/bar\n    address: res[0] // /ipfs/QmHash/foo/bar\n\n  };\n}","function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _asyncIterator(iterable) { var method; if (typeof Symbol !== \"undefined\") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError(\"Object is not async iterable\"); }\n\nimport { createAsyncResourceBundle, createSelector } from 'redux-bundler';\nimport resolveIpldPath from '../lib/resolve-ipld-path';\nimport parseIpldPath from '../lib/parse-ipld-path';\nimport { CID } from 'multiformats/cid';\nimport Cid from 'cids';\nimport { convert } from 'blockcodec-to-ipld-format'; // Find all the nodes and path boundaries traversed along a given path\n\nvar makeBundle = function makeBundle() {\n  // Lazy load ipld because it is a large dependency\n  var IpldResolver = null;\n  var ipldFormats = null;\n  var bundle = createAsyncResourceBundle({\n    name: 'explore',\n    actionBaseType: 'EXPLORE',\n    getPromise: function () {\n      var _getPromise = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(args) {\n        var store, getIpfs, path, pathParts, cidOrFqdn, rest, _yield$getIpld, _ipld, formats, ipld, cid, _yield$resolveIpldPat, targetNode, canonicalPath, localPath, nodes, pathBoundaries;\n\n        return regeneratorRuntime.wrap(function _callee$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                store = args.store, getIpfs = args.getIpfs;\n                path = store.selectExplorePathFromHash();\n\n                if (path) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", null);\n\n              case 4:\n                pathParts = parseIpldPath(path);\n\n                if (pathParts) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", null);\n\n              case 7:\n                cidOrFqdn = pathParts.cidOrFqdn, rest = pathParts.rest;\n                _context2.prev = 8;\n\n                if (IpldResolver) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                _context2.next = 12;\n                return getIpld();\n\n              case 12:\n                _yield$getIpld = _context2.sent;\n                _ipld = _yield$getIpld.ipld;\n                formats = _yield$getIpld.formats;\n                IpldResolver = _ipld;\n                ipldFormats = formats;\n\n              case 17:\n                ipld = makeIpld(IpldResolver, ipldFormats, getIpfs); // TODO: handle ipns, which would give us a fqdn in the cid position.\n\n                cid = new Cid(cidOrFqdn);\n                _context2.next = 21;\n                return resolveIpldPath(ipld, cid, rest);\n\n              case 21:\n                _yield$resolveIpldPat = _context2.sent;\n                targetNode = _yield$resolveIpldPat.targetNode;\n                canonicalPath = _yield$resolveIpldPat.canonicalPath;\n                localPath = _yield$resolveIpldPat.localPath;\n                nodes = _yield$resolveIpldPat.nodes;\n                pathBoundaries = _yield$resolveIpldPat.pathBoundaries;\n                return _context2.abrupt(\"return\", {\n                  path: path,\n                  targetNode: targetNode,\n                  canonicalPath: canonicalPath,\n                  localPath: localPath,\n                  nodes: nodes,\n                  pathBoundaries: pathBoundaries\n                });\n\n              case 30:\n                _context2.prev = 30;\n                _context2.t0 = _context2[\"catch\"](8);\n                console.warn('Failed to resolve path', path, _context2.t0);\n                return _context2.abrupt(\"return\", {\n                  path: path,\n                  error: _context2.t0.toString()\n                });\n\n              case 34:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee, null, [[8, 30]]);\n      }));\n\n      function getPromise(_x) {\n        return _getPromise.apply(this, arguments);\n      }\n\n      return getPromise;\n    }(),\n    staleAfter: Infinity,\n    checkIfOnline: false\n  });\n  bundle.selectExplorePathFromHash = createSelector('selectRouteInfo', function (routeInfo) {\n    if (!routeInfo.url.startsWith('/explore')) return;\n    var path = routeInfo.url.slice('/explore'.length);\n    return decodeURIComponent(path);\n  }); // Fetch the explore data when the address in the url hash changes.\n\n  bundle.reactExploreFetch = createSelector('selectIpfsReady', 'selectExploreIsLoading', 'selectExploreIsWaitingToRetry', 'selectExplorePathFromHash', 'selectExplore', function (ipfsReady, isLoading, isWaitingToRetry, explorePathFromHash, obj) {\n    // Wait for ipfs or the pending request to complete\n    if (!ipfsReady || isLoading || isWaitingToRetry) return false; // Theres no url path and no data so nothing to do.\n\n    if (!explorePathFromHash && !obj) return false; // We already have the data for the path.\n\n    if (obj && explorePathFromHash === obj.path) return false;\n    return {\n      actionCreator: 'doFetchExplore'\n    };\n  }); // Unpack append a dag link target to the current path and update the url hash\n\n  bundle.doExploreLink = function (link) {\n    return function (_ref) {\n      var store = _ref.store;\n\n      var _store$selectExplore = store.selectExplore(),\n          nodes = _store$selectExplore.nodes,\n          pathBoundaries = _store$selectExplore.pathBoundaries;\n\n      var cid = nodes[0].cid;\n      var pathParts = pathBoundaries.map(function (p) {\n        return p.path;\n      }); // add the extra path step from the link to the end\n\n      if (link && link.path) {\n        pathParts.push(link.path);\n      } // add the root cid to the start\n\n\n      pathParts.unshift(cid);\n      var path = pathParts.join('/');\n      var hash = \"#/explore/\".concat(path);\n      store.doUpdateHash(hash);\n    };\n  }; // validate user submitted path and put it in url hash fragment\n\n\n  bundle.doExploreUserProvidedPath = function (path) {\n    return function (_ref2) {\n      var store = _ref2.store;\n      var hash = path ? \"#/explore\".concat(ensureLeadingSlash(path)) : '#/explore';\n      store.doUpdateHash(hash);\n    };\n  };\n\n  bundle.doUploadUserProvidedCar = function (file, uploadImage) {\n    return function (args) {\n      var store = args.store,\n          getIpfs = args.getIpfs;\n      importCar(file, getIpfs()).then(function (result) {\n        var cid = result.root.cid;\n        var hash = cid.toString() ? \"#/explore\".concat(ensureLeadingSlash(cid.toString())) : '#/explore';\n        store.doUpdateHash(hash); //  Grab the car loader image so we can change it's state\n\n        var imageFileLoader = document.getElementById('car-loader-image');\n        imageFileLoader.src = uploadImage;\n      });\n    };\n  };\n\n  return bundle;\n};\n\nfunction importCar(file, ipfs) {\n  var inStream, toIterable, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, result;\n\n  return regeneratorRuntime.async(function importCar$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          inStream = file.stream();\n          toIterable = require('stream-to-it');\n          _iteratorNormalCompletion = true;\n          _didIteratorError = false;\n          _context.prev = 4;\n          _iterator = _asyncIterator(ipfs.dag[\"import\"](toIterable.source(inStream)));\n\n        case 6:\n          _context.next = 8;\n          return regeneratorRuntime.awrap(_iterator.next());\n\n        case 8:\n          _step = _context.sent;\n          _iteratorNormalCompletion = _step.done;\n          _context.next = 12;\n          return regeneratorRuntime.awrap(_step.value);\n\n        case 12:\n          _value = _context.sent;\n\n          if (_iteratorNormalCompletion) {\n            _context.next = 19;\n            break;\n          }\n\n          result = _value;\n          return _context.abrupt(\"return\", result);\n\n        case 16:\n          _iteratorNormalCompletion = true;\n          _context.next = 6;\n          break;\n\n        case 19:\n          _context.next = 25;\n          break;\n\n        case 21:\n          _context.prev = 21;\n          _context.t0 = _context[\"catch\"](4);\n          _didIteratorError = true;\n          _iteratorError = _context.t0;\n\n        case 25:\n          _context.prev = 25;\n          _context.prev = 26;\n\n          if (!(!_iteratorNormalCompletion && _iterator[\"return\"] != null)) {\n            _context.next = 30;\n            break;\n          }\n\n          _context.next = 30;\n          return regeneratorRuntime.awrap(_iterator[\"return\"]());\n\n        case 30:\n          _context.prev = 30;\n\n          if (!_didIteratorError) {\n            _context.next = 33;\n            break;\n          }\n\n          throw _iteratorError;\n\n        case 33:\n          return _context.finish(30);\n\n        case 34:\n          return _context.finish(25);\n\n        case 35:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[4, 21, 25, 35], [26,, 30, 34]], Promise);\n}\n\nfunction ensureLeadingSlash(str) {\n  if (str.startsWith('/')) return str;\n  return \"/\".concat(str);\n}\n\nfunction makeIpld(IpldResolver, ipldFormats, getIpfs) {\n  return new IpldResolver({\n    blockService: painfullyCompatibleBlockService(getIpfs()),\n    formats: ipldFormats\n  });\n} // This wrapper ensures the new block service from js-ipfs AND js-ipfs-http-client\n// works with the legacy code present in ipld-explorer-components\n//\n// (ir)rationale: we have no bandwidth to rewrite entire IPLD Explorer\n// but thanks to it using only ipfs.block.get, making it extra compatible\n// is not very expensive. This buys us some time, but this technical debt needs\n// to be paid eventually.\n\n\nfunction painfullyCompatibleBlockService(ipfs) {\n  var blockService = new Proxy(ipfs.block, {\n    get: function get(obj, prop) {\n      if (prop === 'get') {\n        // augument ipfs.block.get()\n        return /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(cid, options) {\n            var block;\n            return regeneratorRuntime.wrap(function _callee2$(_context3) {\n              while (1) {\n                switch (_context3.prev = _context3.next) {\n                  case 0:\n                    _context3.prev = 0;\n                    _context3.next = 3;\n                    return ipfs.block.get(cid, options);\n\n                  case 3:\n                    block = _context3.sent;\n                    _context3.next = 15;\n                    break;\n\n                  case 6:\n                    _context3.prev = 6;\n                    _context3.t0 = _context3[\"catch\"](0);\n\n                    if (!_context3.t0.toString().includes('Unknown type, must be binary type')) {\n                      _context3.next = 14;\n                      break;\n                    }\n\n                    _context3.next = 11;\n                    return ipfs.block.get(CID.parse(cid.toString()), options);\n\n                  case 11:\n                    block = _context3.sent;\n                    _context3.next = 15;\n                    break;\n\n                  case 14:\n                    throw _context3.t0;\n\n                  case 15:\n                    if (!(typeof block.cid === 'undefined')) {\n                      _context3.next = 17;\n                      break;\n                    }\n\n                    return _context3.abrupt(\"return\", {\n                      cid: cid,\n                      data: block\n                    });\n\n                  case 17:\n                    return _context3.abrupt(\"return\", block);\n\n                  case 18:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }\n            }, _callee2, null, [[0, 6]]);\n          }));\n\n          return function (_x2, _x3) {\n            return _ref3.apply(this, arguments);\n          };\n        }();\n      }\n\n      return obj[prop];\n    }\n  });\n  return blockService;\n}\n\nfunction getIpld() {\n  return _getIpld.apply(this, arguments);\n}\n\nfunction _getIpld() {\n  _getIpld = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n    var ipldDeps, _ipldDeps$map, _ipldDeps$map2, ipld, formats, ipldEthereum, ipldJson;\n\n    return regeneratorRuntime.wrap(function _callee3$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return Promise.all([import(\n            /* webpackChunkName: \"ipld\" */\n            'ipld'), import(\n            /* webpackChunkName: \"ipld\" */\n            'ipld-dag-cbor'), import(\n            /* webpackChunkName: \"ipld\" */\n            'ipld-dag-pb'), import(\n            /* webpackChunkName: \"ipld\" */\n            'ipld-git'), import(\n            /* webpackChunkName: \"ipld\" */\n            'ipld-raw'), import(\n            /* webpackChunkName: \"ipld\" */\n            'ipld-ethereum')]);\n\n          case 2:\n            ipldDeps = _context4.sent;\n            // CommonJs exports object is .default when imported ESM style\n            _ipldDeps$map = ipldDeps.map(function (mod) {\n              return mod[\"default\"];\n            }), _ipldDeps$map2 = _toArray(_ipldDeps$map), ipld = _ipldDeps$map2[0], formats = _ipldDeps$map2.slice(1); // ipldEthereum is an Object, each key points to a ipld format impl\n\n            ipldEthereum = formats.pop();\n            formats.push.apply(formats, _toConsumableArray(Object.values(ipldEthereum))); // ipldJson uses the new format, use the conversion tool\n\n            _context4.next = 8;\n            return import(\n            /* webpackChunkName: \"ipld\" */\n            '@ipld/dag-json');\n\n          case 8:\n            ipldJson = _context4.sent;\n            formats.push(convert(ipldJson));\n            return _context4.abrupt(\"return\", {\n              ipld: ipld,\n              formats: formats\n            });\n\n          case 11:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getIpld.apply(this, arguments);\n}\n\nexport default makeBundle;","import CID from 'cids';\nimport multihash from 'multihashes';\nimport multibase from 'multibase';\nimport { getCodeFromName } from 'multicodec';\nexport function decodeCid(value) {\n  var cid = new CID(value).toJSON();\n\n  if (cid.version === 0) {\n    return decodeCidV0(value, cid);\n  }\n\n  if (cid.version === 1) {\n    return decodeCidV1(value, cid);\n  }\n\n  throw new Error('Unknown CID version', cid.version, cid);\n} // cidv0 ::= <multihash-content-address>\n// QmRds34t1KFiatDY6yJFj8U9VPTLvSMsR63y7qdUV3RMmT\n\nexport function decodeCidV0(value, cid) {\n  return {\n    cid: cid,\n    multibase: {\n      name: 'base58btc',\n      code: 'implicit'\n    },\n    multicodec: {\n      name: cid.codec,\n      code: 'implicit'\n    },\n    multihash: multihash.decode(cid.hash)\n  };\n} // <cidv1> ::= <multibase-prefix><cid-version><multicodec-content-type><multihash-content-address>\n// zb2rhiVd5G2DSpnbYtty8NhYHeDvNkPxjSqA7YbDPuhdihj9L\n\nexport function decodeCidV1(value, cid) {\n  return {\n    cid: cid,\n    multibase: multibase.codes[value.substring(0, 1)],\n    multicodec: {\n      name: cid.codec,\n      code: '0x' + getCodeFromName(cid.codec)\n    },\n    multihash: multihash.decode(cid.hash)\n  };\n}","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from 'react';\nimport { decodeCid } from './decode-cid';\nimport { withTranslation } from 'react-i18next';\n\nfunction extractInfo(cid) {\n  var cidInfo = decodeCid(cid);\n  var hashFn = cidInfo.multihash.name;\n  var hashFnCode = cidInfo.multihash.code.toString('16');\n  var hashLengthCode = cidInfo.multihash.length.toString('16');\n  var hashLengthInBits = cidInfo.multihash.length * 8;\n  var hashValue = toHex(cidInfo.multihash.digest);\n  var hashValueIn32CharChunks = hashValue.split('').reduce(function (resultArray, item, index) {\n    var chunkIndex = Math.floor(index / 32);\n\n    if (!resultArray[chunkIndex]) {\n      resultArray[chunkIndex] = []; // start a new chunk\n    }\n\n    resultArray[chunkIndex].push(item);\n    return resultArray;\n  }, []);\n  var humanReadable = \"\".concat(cidInfo.multibase.name, \" - cidv\").concat(cidInfo.cid.version, \" - \").concat(cidInfo.cid.codec, \" - \").concat(hashFn, \"~\").concat(hashLengthInBits, \"~\").concat(hashValue, \")\");\n  return {\n    hashFn: hashFn,\n    hashFnCode: hashFnCode,\n    hashLengthCode: hashLengthCode,\n    hashLengthInBits: hashLengthInBits,\n    hashValue: hashValue,\n    hashValueIn32CharChunks: hashValueIn32CharChunks,\n    humanReadable: humanReadable\n  };\n}\n\nvar toHex = function toHex(bytes) {\n  return Array.prototype.map.call(bytes, function (x) {\n    return x.toString(16).padStart(2, '0');\n  }).join('').toUpperCase();\n};\n\nexport var CidInfo = function CidInfo(_ref) {\n  var t = _ref.t,\n      tReady = _ref.tReady,\n      cid = _ref.cid,\n      className = _ref.className,\n      props = _objectWithoutProperties(_ref, [\"t\", \"tReady\", \"cid\", \"className\"]);\n\n  var cidErr = null;\n  var cidInfo = null;\n\n  try {\n    cidInfo = cid ? extractInfo(cid) : null;\n  } catch (err) {\n    cidErr = err;\n  }\n\n  return !cid ? null : /*#__PURE__*/React.createElement(\"section\", _extends({\n    className: \"ph3 pv4 sans-serif \".concat(className)\n  }, props), /*#__PURE__*/React.createElement(\"label\", {\n    className: \"db pb2\"\n  }, /*#__PURE__*/React.createElement(\"a\", {\n    className: \"tracked ttu f5 fw2 teal-muted hover-aqua link\",\n    href: \"https://docs.ipfs.io/concepts/glossary/#cid\",\n    rel: \"external\",\n    target: \"_external\"\n  }, t('CidInfo.header'))), !cidInfo ? null : /*#__PURE__*/React.createElement(\"div\", null, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"f7 monospace fw4 ma0 pb2 truncate mid-gray force-select\",\n    title: cid\n  }, cid), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"f6 sans-serif fw4 ma0 pb2 truncate\",\n    id: \"CidInfo-human-readable-cid\"\n  }, cidInfo.humanReadable), /*#__PURE__*/React.createElement(\"label\", {\n    htmlFor: \"CidInfo-human-readable-cid\",\n    className: \"db fw2 ma0 mid-gray ttu f7 tracked\"\n  }, t('base'), \" - \", t('version'), \" - \", t('codec'), \" - \", t('multihash')), /*#__PURE__*/React.createElement(\"a\", {\n    href: \"https://docs.ipfs.io/concepts/glossary/#multihash\",\n    rel: \"external\",\n    target: \"_external\",\n    className: \"dib tracked ttu f6 fw2 teal-muted hover-aqua link mt4\"\n  }, t('multihash')), /*#__PURE__*/React.createElement(\"div\", null, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"dib monospace f6 pt2 tr dark-gray lh-title ph2\"\n  }, /*#__PURE__*/React.createElement(\"code\", {\n    className: \"gray\"\n  }, \"0x\"), /*#__PURE__*/React.createElement(\"span\", {\n    className: \"orange force-select\"\n  }, cidInfo.hashFnCode), /*#__PURE__*/React.createElement(\"span\", {\n    className: \"green force-select\"\n  }, cidInfo.hashLengthCode), /*#__PURE__*/React.createElement(\"span\", {\n    id: \"CidInfo-multihash\",\n    className: \"force-select\"\n  }, cidInfo.hashValueIn32CharChunks.map(function (chunk) {\n    return /*#__PURE__*/React.createElement(\"span\", {\n      key: chunk.join('')\n    }, chunk.join(''), /*#__PURE__*/React.createElement(\"br\", null));\n  })), /*#__PURE__*/React.createElement(\"label\", {\n    htmlFor: \"CidInfo-multihash\",\n    className: \"sans-serif fw2 ma0 mid-gray ttu f7 tracked\"\n  }, t('CidInfo.hashDigest')), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"tl lh-copy\"\n  }, /*#__PURE__*/React.createElement(\"a\", {\n    className: \"db orange no-underline pt2\",\n    href: \"https://docs.ipfs.io/concepts/glossary/#multicodec\",\n    rel: \"external\",\n    target: \"_external\",\n    title: \"Multicodec\"\n  }, /*#__PURE__*/React.createElement(\"code\", {\n    className: \"gray\"\n  }, \"0x\"), /*#__PURE__*/React.createElement(\"code\", null, cidInfo.hashFnCode), \" = \", cidInfo.hashFn), /*#__PURE__*/React.createElement(\"div\", {\n    id: \"CidInfo-multihash\",\n    className: \"green\"\n  }, /*#__PURE__*/React.createElement(\"code\", {\n    className: \"gray\"\n  }, \"0x\"), /*#__PURE__*/React.createElement(\"code\", null, cidInfo.hashLengthCode), \" = \", cidInfo.hashLengthInBits, \" bits\"))))), !cidErr ? null : /*#__PURE__*/React.createElement(\"div\", null, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"f5 sans-serif fw5 ma0 pv2 truncate navy\"\n  }, cid), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"red fw2 ma0 f7\"\n  }, cidErr.message)));\n};\nexport default withTranslation('explore')(CidInfo);","var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","/**\n * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.\n *\n */\n'use strict'\n\nconst constants = require('./constants')\nconst { encodeText, decodeText, concat } = require('./util')\n\n/** @typedef {import('./base')} Base */\n/** @typedef {import(\"./types\").BaseNameOrCode} BaseNameOrCode */\n/** @typedef {import(\"./types\").BaseCode} BaseCode */\n/** @typedef {import(\"./types\").BaseName} BaseName */\n\n/**\n * Create a new Uint8Array with the multibase varint+code.\n *\n * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.\n * @param {Uint8Array} buf - The data to be prefixed with multibase.\n * @returns {Uint8Array}\n * @throws {Error} Will throw if the encoding is not supported\n */\nfunction multibase (nameOrCode, buf) {\n  if (!buf) {\n    throw new Error('requires an encoded Uint8Array')\n  }\n  const { name, codeBuf } = encoding(nameOrCode)\n  validEncode(name, buf)\n\n  return concat([codeBuf, buf], codeBuf.length + buf.length)\n}\n\n/**\n * Encode data with the specified base and add the multibase prefix.\n *\n * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.\n * @param {Uint8Array} buf - The data to be encoded.\n * @returns {Uint8Array}\n * @throws {Error} Will throw if the encoding is not supported\n *\n */\nfunction encode (nameOrCode, buf) {\n  const enc = encoding(nameOrCode)\n  const data = encodeText(enc.encode(buf))\n\n  return concat([enc.codeBuf, data], enc.codeBuf.length + data.length)\n}\n\n/**\n * Takes a Uint8Array or string encoded with multibase header, decodes it and\n * returns the decoded buffer\n *\n * @param {Uint8Array|string} data\n * @returns {Uint8Array}\n * @throws {Error} Will throw if the encoding is not supported\n *\n */\nfunction decode (data) {\n  if (data instanceof Uint8Array) {\n    data = decodeText(data)\n  }\n  const prefix = data[0]\n\n  // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet\n  if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {\n    data = data.toLowerCase()\n  }\n  const enc = encoding(/** @type {BaseCode} */(data[0]))\n  return enc.decode(data.substring(1))\n}\n\n/**\n * Is the given data multibase encoded?\n *\n * @param {Uint8Array|string} data\n * @returns {false | string}\n */\nfunction isEncoded (data) {\n  if (data instanceof Uint8Array) {\n    data = decodeText(data)\n  }\n\n  // Ensure bufOrString is a string\n  if (Object.prototype.toString.call(data) !== '[object String]') {\n    return false\n  }\n\n  try {\n    const enc = encoding(/** @type {BaseCode} */(data[0]))\n    return enc.name\n  } catch (err) {\n    return false\n  }\n}\n\n/**\n * Validate encoded data\n *\n * @param {BaseNameOrCode} name\n * @param {Uint8Array} buf\n * @returns {void}\n * @throws {Error} Will throw if the encoding is not supported\n */\nfunction validEncode (name, buf) {\n  const enc = encoding(name)\n  enc.decode(decodeText(buf))\n}\n\n/**\n * Get the encoding by name or code\n *\n * @param {BaseNameOrCode} nameOrCode\n * @returns {Base}\n * @throws {Error} Will throw if the encoding is not supported\n */\nfunction encoding (nameOrCode) {\n  if (Object.prototype.hasOwnProperty.call(constants.names, /** @type {BaseName} */(nameOrCode))) {\n    return constants.names[/** @type {BaseName} */(nameOrCode)]\n  } else if (Object.prototype.hasOwnProperty.call(constants.codes, /** @type {BaseCode} */(nameOrCode))) {\n    return constants.codes[/** @type {BaseCode} */(nameOrCode)]\n  } else {\n    throw new Error(`Unsupported encoding: ${nameOrCode}`)\n  }\n}\n\n/**\n * Get encoding from data\n *\n * @param {string|Uint8Array} data\n * @returns {Base}\n * @throws {Error} Will throw if the encoding is not supported\n */\nfunction encodingFromData (data) {\n  if (data instanceof Uint8Array) {\n    data = decodeText(data)\n  }\n\n  return encoding(/** @type {BaseCode} */(data[0]))\n}\n\nexports = module.exports = multibase\nexports.encode = encode\nexports.decode = decode\nexports.isEncoded = isEncoded\nexports.encoding = encoding\nexports.encodingFromData = encodingFromData\nexports.names = Object.freeze(constants.names)\nexports.codes = Object.freeze(constants.codes)\n","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","/**\n * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.\n *\n */\n'use strict'\n\nconst constants = require('./constants')\nconst { encodeText, decodeText, concat } = require('./util')\n\n/** @typedef {import('./base')} Base */\n/** @typedef {import(\"./types\").BaseNameOrCode} BaseNameOrCode */\n/** @typedef {import(\"./types\").BaseCode} BaseCode */\n/** @typedef {import(\"./types\").BaseName} BaseName */\n\n/**\n * Create a new Uint8Array with the multibase varint+code.\n *\n * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.\n * @param {Uint8Array} buf - The data to be prefixed with multibase.\n * @returns {Uint8Array}\n * @throws {Error} Will throw if the encoding is not supported\n */\nfunction multibase (nameOrCode, buf) {\n  if (!buf) {\n    throw new Error('requires an encoded Uint8Array')\n  }\n  const { name, codeBuf } = encoding(nameOrCode)\n  validEncode(name, buf)\n\n  return concat([codeBuf, buf], codeBuf.length + buf.length)\n}\n\n/**\n * Encode data with the specified base and add the multibase prefix.\n *\n * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.\n * @param {Uint8Array} buf - The data to be encoded.\n * @returns {Uint8Array}\n * @throws {Error} Will throw if the encoding is not supported\n *\n */\nfunction encode (nameOrCode, buf) {\n  const enc = encoding(nameOrCode)\n  const data = encodeText(enc.encode(buf))\n\n  return concat([enc.codeBuf, data], enc.codeBuf.length + data.length)\n}\n\n/**\n * Takes a Uint8Array or string encoded with multibase header, decodes it and\n * returns the decoded buffer\n *\n * @param {Uint8Array|string} data\n * @returns {Uint8Array}\n * @throws {Error} Will throw if the encoding is not supported\n *\n */\nfunction decode (data) {\n  if (data instanceof Uint8Array) {\n    data = decodeText(data)\n  }\n  const prefix = data[0]\n\n  // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet\n  if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {\n    data = data.toLowerCase()\n  }\n  const enc = encoding(/** @type {BaseCode} */(data[0]))\n  return enc.decode(data.substring(1))\n}\n\n/**\n * Is the given data multibase encoded?\n *\n * @param {Uint8Array|string} data\n * @returns {false | string}\n */\nfunction isEncoded (data) {\n  if (data instanceof Uint8Array) {\n    data = decodeText(data)\n  }\n\n  // Ensure bufOrString is a string\n  if (Object.prototype.toString.call(data) !== '[object String]') {\n    return false\n  }\n\n  try {\n    const enc = encoding(/** @type {BaseCode} */(data[0]))\n    return enc.name\n  } catch (err) {\n    return false\n  }\n}\n\n/**\n * Validate encoded data\n *\n * @param {BaseNameOrCode} name\n * @param {Uint8Array} buf\n * @returns {void}\n * @throws {Error} Will throw if the encoding is not supported\n */\nfunction validEncode (name, buf) {\n  const enc = encoding(name)\n  enc.decode(decodeText(buf))\n}\n\n/**\n * Get the encoding by name or code\n *\n * @param {BaseNameOrCode} nameOrCode\n * @returns {Base}\n * @throws {Error} Will throw if the encoding is not supported\n */\nfunction encoding (nameOrCode) {\n  if (constants.names[/** @type {BaseName} */(nameOrCode)]) {\n    return constants.names[/** @type {BaseName} */(nameOrCode)]\n  } else if (constants.codes[/** @type {BaseCode} */(nameOrCode)]) {\n    return constants.codes[/** @type {BaseCode} */(nameOrCode)]\n  } else {\n    throw new Error(`Unsupported encoding: ${nameOrCode}`)\n  }\n}\n\n/**\n * Get encoding from data\n *\n * @param {string|Uint8Array} data\n * @returns {Base}\n * @throws {Error} Will throw if the encoding is not supported\n */\nfunction encodingFromData (data) {\n  if (data instanceof Uint8Array) {\n    data = decodeText(data)\n  }\n\n  return encoding(/** @type {BaseCode} */(data[0]))\n}\n\nexports = module.exports = multibase\nexports.encode = encode\nexports.decode = decode\nexports.isEncoded = isEncoded\nexports.encoding = encoding\nexports.encodingFromData = encodingFromData\nexports.names = Object.freeze(constants.names)\nexports.codes = Object.freeze(constants.codes)\n","'use strict'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed ArrayLikes\n *\n * @param {Array<ArrayLike<number>>} arrays\n * @param {number} [length]\n */\nfunction concat (arrays, length) {\n  if (!length) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = new Uint8Array(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return output\n}\n\nmodule.exports = concat\n","/**\n * Multihash implementation in JavaScript.\n */\n'use strict'\n\nconst multibase = require('multibase')\nconst varint = require('varint')\nconst { names } = require('./constants')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\nconst uint8ArrayConcat = require('uint8arrays/concat')\n\nconst codes = /** @type {import('./types').CodeNameMap} */({})\n\n// eslint-disable-next-line guard-for-in\nfor (const key in names) {\n  const name = /** @type {HashName} */(key)\n  codes[names[name]] = name\n}\nObject.freeze(codes)\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toHexString (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  return uint8ArrayToString(hash, 'base16')\n}\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Uint8Array}\n */\nfunction fromHexString (hash) {\n  return uint8ArrayFromString(hash, 'base16')\n}\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toB58String (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1)\n}\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Uint8Array} hash\n * @returns {Uint8Array}\n */\nfunction fromB58String (hash) {\n  const encoded = hash instanceof Uint8Array\n    ? uint8ArrayToString(hash)\n    : hash\n\n  return multibase.decode('z' + encoded)\n}\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Uint8Array} bytes\n * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result\n */\nfunction decode (bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new Error('multihash must be a Uint8Array')\n  }\n\n  if (bytes.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.')\n  }\n\n  const code = /** @type {HashCode} */(varint.decode(bytes))\n  if (!isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\n  }\n  bytes = bytes.slice(varint.decode.bytes)\n\n  const len = varint.decode(bytes)\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`)\n  }\n  bytes = bytes.slice(varint.decode.bytes)\n\n  if (bytes.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`)\n  }\n\n  return {\n    code,\n    name: codes[code],\n    length: len,\n    digest: bytes\n  }\n}\n\n/**\n * Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Uint8Array} digest\n * @param {HashName | HashCode} code\n * @param {number} [length]\n * @returns {Uint8Array}\n */\nfunction encode (digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code')\n  }\n\n  // ensure it's a hashfunction code.\n  const hashfn = coerceCode(code)\n\n  if (!(digest instanceof Uint8Array)) {\n    throw new Error('digest should be a Uint8Array')\n  }\n\n  if (length == null) {\n    length = digest.length\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.')\n  }\n\n  const hash = varint.encode(hashfn)\n  const len = varint.encode(length)\n  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length)\n}\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n *\n * @param {HashName | number} name\n * @returns {number}\n */\nfunction coerceCode (name) {\n  let code = name\n\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`)\n    }\n    code = names[name]\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\n  }\n\n  // @ts-ignore\n  if (codes[code] === undefined && !isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`)\n  }\n\n  return code\n}\n\n/**\n * Checks if a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction isAppCode (code) {\n  return code > 0 && code < 0x10\n}\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {HashCode} code\n * @returns {boolean}\n */\nfunction isValidCode (code) {\n  if (isAppCode(code)) {\n    return true\n  }\n\n  if (codes[code]) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {void}\n * @throws {Error}\n */\nfunction validate (multihash) {\n  decode(multihash) // throws if bad.\n}\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n * @throws {Error}\n */\nfunction prefix (multihash) {\n  validate(multihash)\n\n  return multihash.subarray(0, 2)\n}\n\nmodule.exports = {\n  names,\n  codes,\n  toHexString,\n  fromHexString,\n  toB58String,\n  fromB58String,\n  decode,\n  encode,\n  coerceCode,\n  isAppCode,\n  validate,\n  prefix,\n  isValidCode\n}\n\n/**\n * @typedef { import(\"./constants\").HashCode } HashCode\n * @typedef { import(\"./constants\").HashName } HashName\n */\n","'use strict'\n\nconst { encoding: getCodec } = require('multibase')\nconst { TextEncoder } = require('web-encoding')\nconst utf8Encoder = new TextEncoder()\n\n/**\n * @typedef {import('multibase/src/types').BaseName} BaseName\n */\n\n/**\n * Interprets each character in a string as a byte and\n * returns a Uint8Array of those bytes.\n *\n * @param {string} string - The string to turn into an array\n */\nfunction asciiStringToUint8Array (string) {\n  const array = new Uint8Array(string.length)\n\n  for (let i = 0; i < string.length; i++) {\n    array[i] = string.charCodeAt(i)\n  }\n\n  return array\n}\n\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n *\n * @param {string} string\n * @param {BaseName | 'utf8' | 'utf-8' | 'ascii'} [encoding=utf8] - utf8, base16, base64, base64urlpad, etc\n * @returns {Uint8Array}\n */\nfunction fromString (string, encoding = 'utf8') {\n  if (encoding === 'utf8' || encoding === 'utf-8') {\n    return utf8Encoder.encode(string)\n  }\n\n  if (encoding === 'ascii') {\n    return asciiStringToUint8Array(string)\n  }\n\n  return getCodec(encoding).decode(string)\n}\n\nmodule.exports = fromString\n","'use strict'\n\nconst varint = require('varint')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\n\nmodule.exports = {\n  numberToUint8Array,\n  uint8ArrayToNumber,\n  varintUint8ArrayEncode,\n  varintEncode\n}\n\n/**\n * @param {Uint8Array} buf\n */\nfunction uint8ArrayToNumber (buf) {\n  return parseInt(uint8ArrayToString(buf, 'base16'), 16)\n}\n\n/**\n * @param {number} num\n */\nfunction numberToUint8Array (num) {\n  let hexString = num.toString(16)\n  if (hexString.length % 2 === 1) {\n    hexString = '0' + hexString\n  }\n  return uint8ArrayFromString(hexString, 'base16')\n}\n\n/**\n * @param {Uint8Array} input\n */\nfunction varintUint8ArrayEncode (input) {\n  return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)))\n}\n\n/**\n * @param {number} num\n */\nfunction varintEncode (num) {\n  return Uint8Array.from(varint.encode(num))\n}\n","'use strict'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed ArrayLikes\n *\n * @param {Array<ArrayLike<number>>} arrays\n * @param {Number} length\n * @returns {Uint8Array}\n */\nfunction concat (arrays, length) {\n  if (!length) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = new Uint8Array(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return output\n}\n\nmodule.exports = concat\n","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nvar isNativeReflectConstruct = require(\"./isNativeReflectConstruct\");\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct;","function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nmodule.exports = _isNativeReflectConstruct;","'use strict'\n\nconst isReactNative =\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative'\n\nfunction getDefaultBase () {\n  if (isReactNative) {\n    return 'http://localhost'\n  }\n\n  return self.location.protocol + '//' + self.location.host\n}\n\nconst URL = self.URL\nconst defaultBase = getDefaultBase()\n\nclass URLWithLegacySupport {\n  constructor (url = '', base = defaultBase) {\n    this.super = new URL(url, base)\n    this.path = this.pathname + this.search\n    this.auth =\n            this.username && this.password\n              ? this.username + ':' + this.password\n              : null\n\n    this.query =\n            this.search && this.search.startsWith('?')\n              ? this.search.slice(1)\n              : null\n  }\n\n  get hash () {\n    return this.super.hash\n  }\n\n  get host () {\n    return this.super.host\n  }\n\n  get hostname () {\n    return this.super.hostname\n  }\n\n  get href () {\n    return this.super.href\n  }\n\n  get origin () {\n    return this.super.origin\n  }\n\n  get password () {\n    return this.super.password\n  }\n\n  get pathname () {\n    return this.super.pathname\n  }\n\n  get port () {\n    return this.super.port\n  }\n\n  get protocol () {\n    return this.super.protocol\n  }\n\n  get search () {\n    return this.super.search\n  }\n\n  get searchParams () {\n    return this.super.searchParams\n  }\n\n  get username () {\n    return this.super.username\n  }\n\n  set hash (hash) {\n    this.super.hash = hash\n  }\n\n  set host (host) {\n    this.super.host = host\n  }\n\n  set hostname (hostname) {\n    this.super.hostname = hostname\n  }\n\n  set href (href) {\n    this.super.href = href\n  }\n\n  set password (password) {\n    this.super.password = password\n  }\n\n  set pathname (pathname) {\n    this.super.pathname = pathname\n  }\n\n  set port (port) {\n    this.super.port = port\n  }\n\n  set protocol (protocol) {\n    this.super.protocol = protocol\n  }\n\n  set search (search) {\n    this.super.search = search\n  }\n\n  set username (username) {\n    this.super.username = username\n  }\n\n  /**\n   * @param {any} o\n   */\n  static createObjectURL (o) {\n    return URL.createObjectURL(o)\n  }\n\n  /**\n   * @param {string} o\n   */\n  static revokeObjectURL (o) {\n    URL.revokeObjectURL(o)\n  }\n\n  toJSON () {\n    return this.super.toJSON()\n  }\n\n  toString () {\n    return this.super.toString()\n  }\n\n  format () {\n    return this.toString()\n  }\n}\n\n/**\n * @param {string | import('url').UrlObject} obj\n */\nfunction format (obj) {\n  if (typeof obj === 'string') {\n    const url = new URL(obj)\n\n    return url.toString()\n  }\n\n  if (!(obj instanceof URL)) {\n    const userPass =\n            // @ts-ignore its not supported in node but we normalise\n            obj.username && obj.password\n              // @ts-ignore its not supported in node but we normalise\n              ? `${obj.username}:${obj.password}@`\n              : ''\n    const auth = obj.auth ? obj.auth + '@' : ''\n    const port = obj.port ? ':' + obj.port : ''\n    const protocol = obj.protocol ? obj.protocol + '//' : ''\n    const host = obj.host || ''\n    const hostname = obj.hostname || ''\n    const search = obj.search || (obj.query ? '?' + obj.query : '')\n    const hash = obj.hash || ''\n    const pathname = obj.pathname || ''\n    // @ts-ignore - path is not supported in node but we normalise\n    const path = obj.path || pathname + search\n\n    return `${protocol}${userPass || auth}${\n            host || hostname + port\n        }${path}${hash}`\n  }\n}\n\nmodule.exports = {\n  URLWithLegacySupport,\n  URLSearchParams: self.URLSearchParams,\n  defaultBase,\n  format\n}\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { invariant } from '@react-dnd/invariant';\nvar isCallingCanDrop = false;\nexport var DropTargetMonitorImpl = /*#__PURE__*/function () {\n  function DropTargetMonitorImpl(manager) {\n    _classCallCheck(this, DropTargetMonitorImpl);\n\n    this.targetId = null;\n    this.internalMonitor = manager.getMonitor();\n  }\n\n  _createClass(DropTargetMonitorImpl, [{\n    key: \"receiveHandlerId\",\n    value: function receiveHandlerId(targetId) {\n      this.targetId = targetId;\n    }\n  }, {\n    key: \"getHandlerId\",\n    value: function getHandlerId() {\n      return this.targetId;\n    }\n  }, {\n    key: \"subscribeToStateChange\",\n    value: function subscribeToStateChange(listener, options) {\n      return this.internalMonitor.subscribeToStateChange(listener, options);\n    }\n  }, {\n    key: \"canDrop\",\n    value: function canDrop() {\n      // Cut out early if the target id has not been set. This should prevent errors\n      // where the user has an older version of dnd-core like in\n      // https://github.com/react-dnd/react-dnd/issues/1310\n      if (!this.targetId) {\n        return false;\n      }\n\n      invariant(!isCallingCanDrop, 'You may not call monitor.canDrop() inside your canDrop() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor');\n\n      try {\n        isCallingCanDrop = true;\n        return this.internalMonitor.canDropOnTarget(this.targetId);\n      } finally {\n        isCallingCanDrop = false;\n      }\n    }\n  }, {\n    key: \"isOver\",\n    value: function isOver(options) {\n      if (!this.targetId) {\n        return false;\n      }\n\n      return this.internalMonitor.isOverTarget(this.targetId, options);\n    }\n  }, {\n    key: \"getItemType\",\n    value: function getItemType() {\n      return this.internalMonitor.getItemType();\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem() {\n      return this.internalMonitor.getItem();\n    }\n  }, {\n    key: \"getDropResult\",\n    value: function getDropResult() {\n      return this.internalMonitor.getDropResult();\n    }\n  }, {\n    key: \"didDrop\",\n    value: function didDrop() {\n      return this.internalMonitor.didDrop();\n    }\n  }, {\n    key: \"getInitialClientOffset\",\n    value: function getInitialClientOffset() {\n      return this.internalMonitor.getInitialClientOffset();\n    }\n  }, {\n    key: \"getInitialSourceClientOffset\",\n    value: function getInitialSourceClientOffset() {\n      return this.internalMonitor.getInitialSourceClientOffset();\n    }\n  }, {\n    key: \"getSourceClientOffset\",\n    value: function getSourceClientOffset() {\n      return this.internalMonitor.getSourceClientOffset();\n    }\n  }, {\n    key: \"getClientOffset\",\n    value: function getClientOffset() {\n      return this.internalMonitor.getClientOffset();\n    }\n  }, {\n    key: \"getDifferenceFromInitialOffset\",\n    value: function getDifferenceFromInitialOffset() {\n      return this.internalMonitor.getDifferenceFromInitialOffset();\n    }\n  }]);\n\n  return DropTargetMonitorImpl;\n}();","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { shallowEqual } from '@react-dnd/shallowequal';\nimport { wrapConnectorHooks } from './wrapConnectorHooks';\nimport { isRef } from '../utils/isRef';\nexport var TargetConnector = /*#__PURE__*/function () {\n  function TargetConnector(backend) {\n    var _this = this;\n\n    _classCallCheck(this, TargetConnector);\n\n    this.hooks = wrapConnectorHooks({\n      dropTarget: function dropTarget(node, options) {\n        _this.clearDropTarget();\n\n        _this.dropTargetOptions = options;\n\n        if (isRef(node)) {\n          _this.dropTargetRef = node;\n        } else {\n          _this.dropTargetNode = node;\n        }\n\n        _this.reconnect();\n      }\n    });\n    this.handlerId = null; // The drop target may either be attached via ref or connect function\n\n    this.dropTargetRef = null;\n    this.dropTargetOptionsInternal = null;\n    this.lastConnectedHandlerId = null;\n    this.lastConnectedDropTarget = null;\n    this.lastConnectedDropTargetOptions = null;\n    this.backend = backend;\n  }\n\n  _createClass(TargetConnector, [{\n    key: \"reconnect\",\n    value: function reconnect() {\n      // if nothing has changed then don't resubscribe\n      var didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();\n\n      if (didChange) {\n        this.disconnectDropTarget();\n      }\n\n      var dropTarget = this.dropTarget;\n\n      if (!this.handlerId) {\n        return;\n      }\n\n      if (!dropTarget) {\n        this.lastConnectedDropTarget = dropTarget;\n        return;\n      }\n\n      if (didChange) {\n        this.lastConnectedHandlerId = this.handlerId;\n        this.lastConnectedDropTarget = dropTarget;\n        this.lastConnectedDropTargetOptions = this.dropTargetOptions;\n        this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);\n      }\n    }\n  }, {\n    key: \"receiveHandlerId\",\n    value: function receiveHandlerId(newHandlerId) {\n      if (newHandlerId === this.handlerId) {\n        return;\n      }\n\n      this.handlerId = newHandlerId;\n      this.reconnect();\n    }\n  }, {\n    key: \"didHandlerIdChange\",\n    value: function didHandlerIdChange() {\n      return this.lastConnectedHandlerId !== this.handlerId;\n    }\n  }, {\n    key: \"didDropTargetChange\",\n    value: function didDropTargetChange() {\n      return this.lastConnectedDropTarget !== this.dropTarget;\n    }\n  }, {\n    key: \"didOptionsChange\",\n    value: function didOptionsChange() {\n      return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);\n    }\n  }, {\n    key: \"disconnectDropTarget\",\n    value: function disconnectDropTarget() {\n      if (this.unsubscribeDropTarget) {\n        this.unsubscribeDropTarget();\n        this.unsubscribeDropTarget = undefined;\n      }\n    }\n  }, {\n    key: \"clearDropTarget\",\n    value: function clearDropTarget() {\n      this.dropTargetRef = null;\n      this.dropTargetNode = null;\n    }\n  }, {\n    key: \"connectTarget\",\n    get: function get() {\n      return this.dropTarget;\n    }\n  }, {\n    key: \"dropTargetOptions\",\n    get: function get() {\n      return this.dropTargetOptionsInternal;\n    },\n    set: function set(options) {\n      this.dropTargetOptionsInternal = options;\n    }\n  }, {\n    key: \"dropTarget\",\n    get: function get() {\n      return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;\n    }\n  }]);\n\n  return TargetConnector;\n}();","function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nexport function isRef(obj) {\n  return (// eslint-disable-next-line no-prototype-builtins\n    obj !== null && _typeof(obj) === 'object' && Object.prototype.hasOwnProperty.call(obj, 'current')\n  );\n}","/**\n * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.\n *\n */\n'use strict'\n\nconst constants = require('./constants')\nconst { encodeText, decodeText, concat } = require('./util')\n\n/** @typedef {import('./base')} Base */\n/** @typedef {import(\"./types\").BaseNameOrCode} BaseNameOrCode */\n/** @typedef {import(\"./types\").BaseCode} BaseCode */\n/** @typedef {import(\"./types\").BaseName} BaseName */\n\n/**\n * Create a new Uint8Array with the multibase varint+code.\n *\n * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.\n * @param {Uint8Array} buf - The data to be prefixed with multibase.\n * @returns {Uint8Array}\n * @throws {Error} Will throw if the encoding is not supported\n */\nfunction multibase (nameOrCode, buf) {\n  if (!buf) {\n    throw new Error('requires an encoded Uint8Array')\n  }\n  const { name, codeBuf } = encoding(nameOrCode)\n  validEncode(name, buf)\n\n  return concat([codeBuf, buf], codeBuf.length + buf.length)\n}\n\n/**\n * Encode data with the specified base and add the multibase prefix.\n *\n * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.\n * @param {Uint8Array} buf - The data to be encoded.\n * @returns {Uint8Array}\n * @throws {Error} Will throw if the encoding is not supported\n *\n */\nfunction encode (nameOrCode, buf) {\n  const enc = encoding(nameOrCode)\n  const data = encodeText(enc.encode(buf))\n\n  return concat([enc.codeBuf, data], enc.codeBuf.length + data.length)\n}\n\n/**\n * Takes a Uint8Array or string encoded with multibase header, decodes it and\n * returns the decoded buffer\n *\n * @param {Uint8Array|string} data\n * @returns {Uint8Array}\n * @throws {Error} Will throw if the encoding is not supported\n *\n */\nfunction decode (data) {\n  if (data instanceof Uint8Array) {\n    data = decodeText(data)\n  }\n  const prefix = data[0]\n\n  // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet\n  if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {\n    data = data.toLowerCase()\n  }\n  const enc = encoding(/** @type {BaseCode} */(data[0]))\n  return enc.decode(data.substring(1))\n}\n\n/**\n * Is the given data multibase encoded?\n *\n * @param {Uint8Array|string} data\n * @returns {false | string}\n */\nfunction isEncoded (data) {\n  if (data instanceof Uint8Array) {\n    data = decodeText(data)\n  }\n\n  // Ensure bufOrString is a string\n  if (Object.prototype.toString.call(data) !== '[object String]') {\n    return false\n  }\n\n  try {\n    const enc = encoding(/** @type {BaseCode} */(data[0]))\n    return enc.name\n  } catch (err) {\n    return false\n  }\n}\n\n/**\n * Validate encoded data\n *\n * @param {BaseNameOrCode} name\n * @param {Uint8Array} buf\n * @returns {void}\n * @throws {Error} Will throw if the encoding is not supported\n */\nfunction validEncode (name, buf) {\n  const enc = encoding(name)\n  enc.decode(decodeText(buf))\n}\n\n/**\n * Get the encoding by name or code\n *\n * @param {BaseNameOrCode} nameOrCode\n * @returns {Base}\n * @throws {Error} Will throw if the encoding is not supported\n */\nfunction encoding (nameOrCode) {\n  if (Object.prototype.hasOwnProperty.call(constants.names, /** @type {BaseName} */(nameOrCode))) {\n    return constants.names[/** @type {BaseName} */(nameOrCode)]\n  } else if (Object.prototype.hasOwnProperty.call(constants.codes, /** @type {BaseCode} */(nameOrCode))) {\n    return constants.codes[/** @type {BaseCode} */(nameOrCode)]\n  } else {\n    throw new Error(`Unsupported encoding: ${nameOrCode}`)\n  }\n}\n\n/**\n * Get encoding from data\n *\n * @param {string|Uint8Array} data\n * @returns {Base}\n * @throws {Error} Will throw if the encoding is not supported\n */\nfunction encodingFromData (data) {\n  if (data instanceof Uint8Array) {\n    data = decodeText(data)\n  }\n\n  return encoding(/** @type {BaseCode} */(data[0]))\n}\n\nexports = module.exports = multibase\nexports.encode = encode\nexports.decode = decode\nexports.isEncoded = isEncoded\nexports.encoding = encoding\nexports.encodingFromData = encodingFromData\nexports.names = Object.freeze(constants.names)\nexports.codes = Object.freeze(constants.codes)\n","'use strict'\n\nconst varint = require('varint')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\n\nmodule.exports = {\n  numberToUint8Array,\n  uint8ArrayToNumber,\n  varintUint8ArrayEncode,\n  varintEncode\n}\n\nfunction uint8ArrayToNumber (buf) {\n  return parseInt(uint8ArrayToString(buf, 'base16'), 16)\n}\n\nfunction numberToUint8Array (num) {\n  let hexString = num.toString(16)\n  if (hexString.length % 2 === 1) {\n    hexString = '0' + hexString\n  }\n  return uint8ArrayFromString(hexString, 'base16')\n}\n\nfunction varintUint8ArrayEncode (input) {\n  return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)))\n}\n\nfunction varintEncode (num) {\n  return Uint8Array.from(varint.encode(num))\n}\n","function _AwaitValue(value) {\n  this.wrapped = value;\n}\n\nmodule.exports = _AwaitValue;","/* eslint-disable no-undef */\n'use strict'\n\nconst { fetch, Request, Headers } = require('./http/fetch')\nconst { TimeoutError, HTTPError } = require('./http/error')\nconst merge = require('merge-options').bind({ ignoreUndefined: true })\nconst { URL, URLSearchParams } = require('iso-url')\nconst TextDecoder = require('./text-decoder')\nconst { AbortController } = require('native-abort-controller')\nconst anySignal = require('any-signal')\n\n/**\n * @typedef {import('electron-fetch').Response} Response\n * @typedef {import('stream').Readable} NodeReadableStream\n * @typedef {import('stream').Duplex} NodeDuplexStream\n * @typedef {import('./types').HTTPOptions} HTTPOptions\n */\n\n/**\n * @template TResponse\n * @param {Promise<TResponse>} promise\n * @param {number | undefined} ms\n * @param {AbortController} abortController\n * @returns {Promise<TResponse>}\n */\nconst timeout = (promise, ms, abortController) => {\n  if (ms === undefined) {\n    return promise\n  }\n\n  const start = Date.now()\n\n  const timedOut = () => {\n    const time = Date.now() - start\n\n    return time >= ms\n  }\n\n  return new Promise((resolve, reject) => {\n    const timeoutID = setTimeout(() => {\n      if (timedOut()) {\n        reject(new TimeoutError())\n        abortController.abort()\n      }\n    }, ms)\n\n    /**\n     * @param {(value: any) => void } next\n     */\n    const after = (next) => {\n      /**\n       * @param {any} res\n       */\n      const fn = (res) => {\n        clearTimeout(timeoutID)\n\n        if (timedOut()) {\n          reject(new TimeoutError())\n          return\n        }\n\n        next(res)\n      }\n      return fn\n    }\n\n    promise\n      .then(after(resolve), after(reject))\n  })\n}\n\nconst defaults = {\n  throwHttpErrors: true,\n  credentials: 'same-origin'\n}\n\nclass HTTP {\n  /**\n   *\n   * @param {HTTPOptions} options\n   */\n  constructor (options = {}) {\n    /** @type {HTTPOptions} */\n    this.opts = merge(defaults, options)\n  }\n\n  /**\n   * Fetch\n   *\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n  async fetch (resource, options = {}) {\n    /** @type {HTTPOptions} */\n    const opts = merge(this.opts, options)\n    const headers = new Headers(opts.headers)\n\n    // validate resource type\n    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {\n      throw new TypeError('`resource` must be a string, URL, or Request')\n    }\n\n    const url = new URL(resource.toString(), opts.base)\n\n    const {\n      searchParams,\n      transformSearchParams,\n      json\n    } = opts\n\n    if (searchParams) {\n      if (typeof transformSearchParams === 'function') {\n        // @ts-ignore\n        url.search = transformSearchParams(new URLSearchParams(opts.searchParams))\n      } else {\n        // @ts-ignore\n        url.search = new URLSearchParams(opts.searchParams)\n      }\n    }\n\n    if (json) {\n      opts.body = JSON.stringify(opts.json)\n      headers.set('content-type', 'application/json')\n    }\n\n    const abortController = new AbortController()\n    // @ts-ignore\n    const signal = anySignal([abortController.signal, opts.signal])\n\n    const response = await timeout(\n      fetch(\n        url.toString(),\n        {\n          ...opts,\n          signal,\n          timeout: undefined,\n          headers\n        }\n      ),\n      opts.timeout,\n      abortController\n    )\n\n    if (!response.ok && opts.throwHttpErrors) {\n      if (opts.handleError) {\n        await opts.handleError(response)\n      }\n      throw new HTTPError(response)\n    }\n\n    response.iterator = function () {\n      return fromStream(response.body)\n    }\n\n    response.ndjson = async function * () {\n      for await (const chunk of ndjson(response.iterator())) {\n        if (options.transform) {\n          yield options.transform(chunk)\n        } else {\n          yield chunk\n        }\n      }\n    }\n\n    return response\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n  post (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'POST' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n  get (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'GET' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n  put (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'PUT' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n  delete (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'DELETE' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n  options (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'OPTIONS' })\n  }\n}\n\n/**\n * Parses NDJSON chunks from an iterator\n *\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {AsyncIterable<any>}\n */\nconst ndjson = async function * (source) {\n  const decoder = new TextDecoder()\n  let buf = ''\n\n  for await (const chunk of source) {\n    buf += decoder.decode(chunk, { stream: true })\n    const lines = buf.split(/\\r?\\n/)\n\n    for (let i = 0; i < lines.length - 1; i++) {\n      const l = lines[i].trim()\n      if (l.length > 0) {\n        yield JSON.parse(l)\n      }\n    }\n    buf = lines[lines.length - 1]\n  }\n  buf += decoder.decode()\n  buf = buf.trim()\n  if (buf.length !== 0) {\n    yield JSON.parse(buf)\n  }\n}\n\n/**\n * Stream to AsyncIterable\n *\n * @template TChunk\n * @param {ReadableStream<TChunk> | NodeReadableStream | null} source\n * @returns {AsyncIterable<TChunk>}\n */\nconst fromStream = (source) => {\n  // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n  if (isNodeReadableStream(source)) {\n    const iter = source[Symbol.asyncIterator]()\n    return {\n      [Symbol.asyncIterator] () {\n        return {\n          next: iter.next.bind(iter),\n          return (value) {\n            source.destroy()\n            if (typeof iter.return === 'function') {\n              return iter.return()\n            }\n            return Promise.resolve({ done: true, value })\n          }\n        }\n      }\n    }\n  }\n\n  if (isWebReadableStream(source)) {\n    const reader = source.getReader()\n    return (async function * () {\n      try {\n        while (true) {\n          // Read from the stream\n          const { done, value } = await reader.read()\n          // Exit if we're done\n          if (done) return\n          // Else yield the chunk\n          if (value) {\n            yield value\n          }\n        }\n      } finally {\n        reader.releaseLock()\n      }\n    })()\n  }\n\n  if (isAsyncIterable(source)) {\n    return source\n  }\n\n  throw new TypeError('Body can\\'t be converted to AsyncIterable')\n}\n\n/**\n * Check if it's an AsyncIterable\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|AsyncIterable<TChunk>} value\n * @returns {value is AsyncIterable<TChunk>}\n */\nconst isAsyncIterable = (value) => {\n  return typeof value === 'object' &&\n  value !== null &&\n  typeof /** @type {any} */(value)[Symbol.asyncIterator] === 'function'\n}\n\n/**\n * Check for web readable stream\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|ReadableStream<TChunk>} value\n * @returns {value is ReadableStream<TChunk>}\n */\nconst isWebReadableStream = (value) => {\n  return value && typeof /** @type {any} */(value).getReader === 'function'\n}\n\n/**\n * @param {any} value\n * @returns {value is NodeReadableStream}\n */\nconst isNodeReadableStream = (value) =>\n  Object.prototype.hasOwnProperty.call(value, 'readable') &&\n  Object.prototype.hasOwnProperty.call(value, 'writable')\n\nHTTP.HTTPError = HTTPError\nHTTP.TimeoutError = TimeoutError\nHTTP.streamToAsyncIterator = fromStream\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\nHTTP.post = (resource, options) => new HTTP(options).post(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\nHTTP.get = (resource, options) => new HTTP(options).get(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\nHTTP.put = (resource, options) => new HTTP(options).put(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\nHTTP.delete = (resource, options) => new HTTP(options).delete(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\nHTTP.options = (resource, options) => new HTTP(options).options(resource, options)\n\nmodule.exports = HTTP\n","'use strict'\n\nclass TimeoutError extends Error {\n  constructor (message = 'Request timed out') {\n    super(message)\n    this.name = 'TimeoutError'\n  }\n}\nexports.TimeoutError = TimeoutError\n\nclass AbortError extends Error {\n  constructor (message = 'The operation was aborted.') {\n    super(message)\n    this.name = 'AbortError'\n  }\n}\nexports.AbortError = AbortError\n\nclass HTTPError extends Error {\n  /**\n   * @param {import('electron-fetch').Response} response\n   */\n  constructor (response) {\n    super(response.statusText)\n    this.name = 'HTTPError'\n    this.response = response\n  }\n}\nexports.HTTPError = HTTPError\n","'use strict'\nconst isElectron = require('is-electron')\n\nconst IS_ENV_WITH_DOM = typeof window === 'object' && typeof document === 'object' && document.nodeType === 9\nconst IS_ELECTRON = isElectron()\nconst IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON\nconst IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM\nconst IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM\nconst IS_NODE = typeof require === 'function' && typeof process !== 'undefined' && typeof process.release !== 'undefined' && process.release.name === 'node' && !IS_ELECTRON\n// @ts-ignore - we either ignore worker scope or dom scope\nconst IS_WEBWORKER = typeof importScripts === 'function' && typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope\nconst IS_TEST = typeof process !== 'undefined' && typeof process.env !== 'undefined' && process.env.NODE_ENV === 'test'\n\nmodule.exports = {\n  isTest: IS_TEST,\n  isElectron: IS_ELECTRON,\n  isElectronMain: IS_ELECTRON_MAIN,\n  isElectronRenderer: IS_ELECTRON_RENDERER,\n  isNode: IS_NODE,\n  /**\n   * Detects browser main thread  **NOT** web worker or service worker\n   */\n  isBrowser: IS_BROWSER,\n  isWebWorker: IS_WEBWORKER,\n  isEnvWithDom: IS_ENV_WITH_DOM\n}\n","'use strict';\n\nvar keys = require('object-keys');\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\n\nvar toStr = Object.prototype.toString;\nvar concat = Array.prototype.concat;\nvar origDefineProperty = Object.defineProperty;\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\n};\n\nvar hasPropertyDescriptors = require('has-property-descriptors')();\n\nvar supportsDescriptors = origDefineProperty && hasPropertyDescriptors;\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object && (!isFunction(predicate) || !predicate())) {\n\t\treturn;\n\t}\n\tif (supportsDescriptors) {\n\t\torigDefineProperty(object, name, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: value,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\tobject[name] = value; // eslint-disable-line no-param-reassign\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = keys(map);\n\tif (hasSymbols) {\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\n\t}\n\tfor (var i = 0; i < props.length; i += 1) {\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\n\t}\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nmodule.exports = defineProperties;\n","'use strict';\n\nvar toStr = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toStr.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n","/* eslint no-negated-condition: 0, no-new-func: 0 */\n\n'use strict';\n\nif (typeof self !== 'undefined') {\n\tmodule.exports = self;\n} else if (typeof window !== 'undefined') {\n\tmodule.exports = window;\n} else {\n\tmodule.exports = Function('return this')();\n}\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = function getPolyfill() {\n\tif (typeof global !== 'object' || !global || global.Math !== Math || global.Array !== Array) {\n\t\treturn implementation;\n\t}\n\treturn global;\n};\n","'use strict';\n\nconst defaultBase = self.location && self.location.protocol + '//' + self.location.host;\nconst URL = self.URL;\n\nclass URLWithLegacySupport {\n    constructor(url = '', base = defaultBase) {\n        this.super = new URL(url, base);\n        this.path = this.pathname + this.search;\n        this.auth =\n            this.username && this.password ?\n                this.username + ':' + this.password :\n                null;\n\n        this.query =\n            this.search && this.search.startsWith('?') ?\n                this.search.slice(1) :\n                null;\n    }\n\n    get hash() {\n        return this.super.hash;\n    }\n    get host() {\n        return this.super.host;\n    }\n    get hostname() {\n        return this.super.hostname;\n    }\n    get href() {\n        return this.super.href;\n    }\n    get origin() {\n        return this.super.origin;\n    }\n    get password() {\n        return this.super.password;\n    }\n    get pathname() {\n        return this.super.pathname;\n    }\n    get port() {\n        return this.super.port;\n    }\n    get protocol() {\n        return this.super.protocol;\n    }\n    get search() {\n        return this.super.search;\n    }\n    get searchParams() {\n        return this.super.searchParams;\n    }\n    get username() {\n        return this.super.username;\n    }\n\n    set hash(hash) {\n        this.super.hash = hash;\n    }\n    set host(host) {\n        this.super.host = host;\n    }\n    set hostname(hostname) {\n        this.super.hostname = hostname;\n    }\n    set href(href) {\n        this.super.href = href;\n    }\n    set origin(origin) {\n        this.super.origin = origin;\n    }\n    set password(password) {\n        this.super.password = password;\n    }\n    set pathname(pathname) {\n        this.super.pathname = pathname;\n    }\n    set port(port) {\n        this.super.port = port;\n    }\n    set protocol(protocol) {\n        this.super.protocol = protocol;\n    }\n    set search(search) {\n        this.super.search = search;\n    }\n    set searchParams(searchParams) {\n        this.super.searchParams = searchParams;\n    }\n    set username(username) {\n        this.super.username = username;\n    }\n\n    createObjectURL(o) {\n        return this.super.createObjectURL(o);\n    }\n    revokeObjectURL(o) {\n        this.super.revokeObjectURL(o);\n    }\n    toJSON() {\n        return this.super.toJSON();\n    }\n    toString() {\n        return this.super.toString();\n    }\n    format() {\n        return this.toString();\n    }\n}\n\nfunction format(obj) {\n    if (typeof obj === 'string') {\n        const url = new URL(obj);\n\n        return url.toString();\n    }\n\n    if (!(obj instanceof URL)) {\n        const userPass =\n            obj.username && obj.password ?\n                `${obj.username}:${obj.password}@` :\n                '';\n        const auth = obj.auth ? obj.auth + '@' : '';\n        const port = obj.port ? ':' + obj.port : '';\n        const protocol = obj.protocol ? obj.protocol + '//' : '';\n        const host = obj.host || '';\n        const hostname = obj.hostname || '';\n        const search = obj.search || (obj.query ? '?' + obj.query : '');\n        const hash = obj.hash || '';\n        const pathname = obj.pathname || '';\n        const path = obj.path || pathname + search;\n\n        return `${protocol}${userPass || auth}${host ||\n            hostname + port}${path}${hash}`;\n    }\n}\n\nmodule.exports = {\n    URLWithLegacySupport,\n    URLSearchParams: self.URLSearchParams,\n    defaultBase,\n    format\n};\n","const { AbortController } = require('native-abort-controller')\n\n/**\n * Takes an array of AbortSignals and returns a single signal.\n * If any signals are aborted, the returned signal will be aborted.\n * @param {Array<AbortSignal>} signals\n * @returns {AbortSignal}\n */\nfunction anySignal (signals) {\n  const controller = new AbortController()\n\n  function onAbort () {\n    controller.abort()\n\n    for (const signal of signals) {\n      if (!signal || !signal.removeEventListener) continue\n      signal.removeEventListener('abort', onAbort)\n    }\n  }\n\n  for (const signal of signals) {\n    if (!signal || !signal.addEventListener) continue\n    if (signal.aborted) {\n      onAbort()\n      break\n    }\n    signal.addEventListener('abort', onAbort)\n  }\n\n  return controller.signal\n}\n\nmodule.exports = anySignal\nmodule.exports.anySignal = anySignal\n","'use strict'\n\nconst CID = require('cids')\nconst toCamel = require('./lib/object-to-camel')\nconst configure = require('./lib/configure')\nconst multipartRequest = require('./lib/multipart-request')\nconst toUrlSearchParams = require('./lib/to-url-search-params')\nconst abortSignal = require('./lib/abort-signal')\nconst { AbortController } = require('native-abort-controller')\n\n/**\n * @typedef {import('ipfs-utils/src/types').ProgressFn} IPFSUtilsHttpUploadProgressFn\n * @typedef {import('ipfs-core-types/src/root').AddProgressFn} IPFSCoreAddProgressFn\n */\n\nmodule.exports = configure((api) => {\n  /**\n   * @type {import('.').Implements<typeof import('ipfs-core/src/components/add-all/index')>}\n   */\n  async function * addAll (source, options = {}) {\n    // allow aborting requests on body errors\n    const controller = new AbortController()\n    const signal = abortSignal(controller.signal, options.signal)\n    const { headers, body, total, parts } =\n      await multipartRequest(source, controller, options.headers)\n\n    // In browser response body only starts streaming once upload is\n    // complete, at which point all the progress updates are invalid. If\n    // length of the content is computable we can interpret progress from\n    // `{ total, loaded}` passed to `onUploadProgress` and `multipart.total`\n    // in which case we disable progress updates to be written out.\n    const [progressFn, onUploadProgress] = typeof options.progress === 'function'\n      ? createProgressHandler(total, parts, options.progress)\n      : [undefined, undefined]\n\n    const res = await api.post('add', {\n      searchParams: toUrlSearchParams({\n        'stream-channels': true,\n        ...options,\n        progress: Boolean(progressFn)\n      }),\n      timeout: options.timeout,\n      onUploadProgress,\n      signal,\n      headers,\n      body\n    })\n\n    for await (let file of res.ndjson()) {\n      file = toCamel(file)\n\n      if (file.hash !== undefined) {\n        yield toCoreInterface(file)\n      } else if (progressFn) {\n        progressFn(file.bytes || 0, file.name)\n      }\n    }\n  }\n  return addAll\n})\n\n/**\n * Returns simple progress callback when content length isn't computable or a\n * progress event handler that calculates progress from upload progress events.\n *\n * @param {number} total\n * @param {{name:string, start:number, end:number}[]|null} parts\n * @param {IPFSCoreAddProgressFn} progress\n * @returns {[IPFSCoreAddProgressFn|undefined, IPFSUtilsHttpUploadProgressFn|undefined]}\n */\nconst createProgressHandler = (total, parts, progress) =>\n  parts ? [undefined, createOnUploadProgress(total, parts, progress)] : [progress, undefined]\n\n/**\n * Creates a progress handler that interpolates progress from upload progress\n * events and total size of the content that is added.\n *\n * @param {number} size - actual content size\n * @param {{name:string, start:number, end:number}[]} parts\n * @param {IPFSCoreAddProgressFn} progress\n * @returns {IPFSUtilsHttpUploadProgressFn}\n */\nconst createOnUploadProgress = (size, parts, progress) => {\n  let index = 0\n  const count = parts.length\n  return ({ loaded, total }) => {\n    // Derive position from the current progress.\n    const position = Math.floor(loaded / total * size)\n    while (index < count) {\n      const { start, end, name } = parts[index]\n      // If within current part range report progress and break the loop\n      if (position < end) {\n        progress(position - start, name)\n        break\n      // If passed current part range report final byte for the chunk and\n      // move to next one.\n      } else {\n        progress(end - start, name)\n        index += 1\n      }\n    }\n  }\n}\n\n/**\n * @param {any} input\n * @returns {import('ipfs-core-types/src/files').UnixFSEntry}\n */\nfunction toCoreInterface ({ name, hash, size, mode, mtime, mtimeNsecs }) {\n  const output = {\n    path: name,\n    cid: new CID(hash),\n    size: parseInt(size)\n  }\n\n  if (mode != null) {\n    output.mode = parseInt(mode, 8)\n  }\n\n  if (mtime != null) {\n    output.mtime = {\n      secs: mtime,\n      nsecs: mtimeNsecs || 0\n    }\n  }\n\n  // @ts-ignore\n  return output\n}\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","'use strict'\n\n/**\n * @template T\n * @typedef {Object} Peek\n * @property {() => IteratorResult<T, void>} peek\n */\n\n/**\n * @template T\n * @typedef {Object} AsyncPeek\n * @property {() => Promise<IteratorResult<T, void>>} peek\n */\n\n/**\n * @template T\n * @typedef {Object} Push\n * @property {(value:T) => void} push\n */\n\n/**\n * @template T\n * @typedef {Iterable<T> & Peek<T> & Push<T> & Iterator<T>} Peekable<T>\n */\n\n/**\n * @template T\n * @typedef {AsyncIterable<T> & AsyncPeek<T> & Push<T> & AsyncIterator<T>} AsyncPeekable<T>\n */\n\n/**\n * @template {Iterable<any> | AsyncIterable<any>} I\n * @param {I} iterable\n * @returns {I extends Iterable<infer T>\n *  ? Peekable<T>\n *  : I extends AsyncIterable<infer T>\n *  ? AsyncPeekable<T>\n *  : never\n * }\n */\nfunction peekableIterator (iterable) {\n  // @ts-ignore\n  const [iterator, symbol] = iterable[Symbol.asyncIterator]\n    // @ts-ignore\n    ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator]\n    // @ts-ignore\n    : [iterable[Symbol.iterator](), Symbol.iterator]\n\n  /** @type {any[]} */\n  const queue = []\n\n  // @ts-ignore\n  return {\n    peek: () => {\n      return iterator.next()\n    },\n    push: (value) => {\n      queue.push(value)\n    },\n    next: () => {\n      if (queue.length) {\n        return {\n          done: false,\n          value: queue.shift()\n        }\n      }\n\n      return iterator.next()\n    },\n    [symbol] () {\n      return this\n    }\n  }\n}\n\nmodule.exports = peekableIterator\n","'use strict'\n\n/**\n * Turns a browser readable stream into an async iterable. Async iteration over\n * returned iterable will lock give stream, preventing any other consumer from\n * acquiring a reader. The lock will be released if iteration loop is broken. To\n * prevent stream cancelling optional `{ preventCancel: true }` could be passed\n * as a second argument.\n * @template T\n * @param {ReadableStream<T>} stream\n * @param {Object} [options]\n * @param {boolean} [options.preventCancel=boolean]\n * @returns {AsyncIterable<T>}\n */\nasync function * browserReadableStreamToIt (stream, options = {}) {\n  const reader = stream.getReader()\n\n  try {\n    while (true) {\n      const result = await reader.read()\n\n      if (result.done) {\n        return\n      }\n\n      yield result.value\n    }\n  } finally {\n    if (options.preventCancel !== true) {\n      reader.cancel()\n    }\n\n    reader.releaseLock()\n  }\n}\n\nmodule.exports = browserReadableStreamToIt\n","'use strict'\n\nconst { BigNumber } = require('bignumber.js')\nconst CID = require('cids')\nconst configure = require('../lib/configure')\nconst toUrlSearchParams = require('../lib/to-url-search-params')\n\nmodule.exports = configure(api => {\n  /**\n   * @type {import('..').Implements<typeof import('ipfs-core/src/components/bitswap/stat')>}\n   */\n  async function stat (options = {}) {\n    const res = await api.post('bitswap/stat', {\n      searchParams: toUrlSearchParams(options),\n      timeout: options.timeout,\n      signal: options.signal,\n      headers: options.headers\n    })\n\n    return toCoreInterface(await res.json())\n  }\n  return stat\n})\n\nfunction toCoreInterface (res) {\n  return {\n    provideBufLen: res.ProvideBufLen,\n    wantlist: (res.Wantlist || []).map(k => new CID(k['/'])),\n    peers: (res.Peers || []),\n    blocksReceived: new BigNumber(res.BlocksReceived),\n    dataReceived: new BigNumber(res.DataReceived),\n    blocksSent: new BigNumber(res.BlocksSent),\n    dataSent: new BigNumber(res.DataSent),\n    dupBlksReceived: new BigNumber(res.DupBlksReceived),\n    dupDataReceived: new BigNumber(res.DupDataReceived)\n  }\n}\n","'use strict'\n\nconst Block = require('ipld-block')\nconst CID = require('cids')\nconst configure = require('../lib/configure')\nconst toUrlSearchParams = require('../lib/to-url-search-params')\n\nmodule.exports = configure(api => {\n  /**\n   * @type {import('..').Implements<typeof import('ipfs-core/src/components/block/get')>}\n   */\n  async function get (cid, options = {}) {\n    // @ts-ignore - CID|string seems to confuse typedef\n    cid = new CID(cid)\n\n    const res = await api.post('block/get', {\n      timeout: options.timeout,\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: cid.toString(),\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    return new Block(new Uint8Array(await res.arrayBuffer()), cid)\n  }\n  return get\n})\n","'use strict'\n\nconst dagPB = require('ipld-dag-pb')\nconst dagCBOR = require('ipld-dag-cbor')\nconst raw = require('ipld-raw')\nconst multicodec = require('multicodec')\n\nconst noop = () => {}\n\n/**\n * @typedef {import('cids')} CID\n */\n\n/**\n * Return an object containing supported IPLD Formats\n *\n * @param {object} [options] - IPLD options passed to the http client constructor\n * @param {Array} [options.formats] - A list of IPLD Formats to use\n * @param {Function} [options.loadFormat] - An async function that can load a format when passed a codec number\n * @returns {Function}\n */\nmodule.exports = ({ formats = [], loadFormat = noop } = {}) => {\n  formats = formats || []\n  loadFormat = loadFormat || noop\n\n  const configuredFormats = {\n    [multicodec.DAG_PB]: dagPB,\n    [multicodec.DAG_CBOR]: dagCBOR,\n    [multicodec.RAW]: raw\n  }\n\n  formats.forEach(format => {\n    configuredFormats[format.codec] = format\n  })\n\n  /**\n   * Attempts to load an IPLD format for the passed CID\n   *\n   * @param {import('multicodec').CodecName} codec - The code to load the format for\n   * @returns {Promise<object>} - An IPLD format\n   */\n  const loadResolver = async (codec) => {\n    // @ts-ignore - codec is a string and not a CodecName\n    const number = multicodec.getNumber(codec)\n    const format = configuredFormats[number] || await loadFormat(codec)\n\n    if (!format) {\n      throw Object.assign(\n        new Error(`Missing IPLD format \"${codec}\"`),\n        { missingMulticodec: codec }\n      )\n    }\n\n    return format\n  }\n\n  return loadResolver\n}\n","'use strict'\n\nconst withIs = require('class-is')\nconst sortLinks = require('./sortLinks')\nconst DAGLink = require('../dag-link/dagLink')\nconst { serializeDAGNode } = require('../serialize.js')\nconst toDAGLink = require('./toDagLink')\nconst addLink = require('./addLink')\nconst rmLink = require('./rmLink')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\nconst uint8ArrayToString = require('uint8arrays/to-string')\n\nclass DAGNode {\n  constructor (data, links = [], serializedSize = null) {\n    if (!data) {\n      data = new Uint8Array(0)\n    }\n    if (typeof data === 'string') {\n      data = uint8ArrayFromString(data)\n    }\n\n    if (!(data instanceof Uint8Array)) {\n      throw new Error('Passed \\'data\\' is not a Uint8Array or a String!')\n    }\n\n    if (serializedSize !== null && typeof serializedSize !== 'number') {\n      throw new Error('Passed \\'serializedSize\\' must be a number!')\n    }\n\n    links = links.map((link) => {\n      return DAGLink.isDAGLink(link)\n        ? link\n        : DAGLink.util.createDagLinkFromB58EncodedHash(link)\n    })\n    sortLinks(links)\n\n    Object.defineProperties(this, {\n      Data: { value: data, writable: false, enumerable: true },\n      Links: { value: links, writable: false, enumerable: true },\n      _serializedSize: { value: serializedSize, writable: true, enumerable: false },\n      _size: { value: null, writable: true, enumerable: false }\n    })\n  }\n\n  toJSON () {\n    if (!this._json) {\n      this._json = Object.freeze({\n        data: this.Data,\n        links: this.Links.map((l) => l.toJSON()),\n        size: this.size\n      })\n    }\n\n    return Object.assign({}, this._json)\n  }\n\n  toString () {\n    return `DAGNode <data: \"${uint8ArrayToString(this.Data, 'base64urlpad')}\", links: ${this.Links.length}, size: ${this.size}>`\n  }\n\n  _invalidateCached () {\n    this._serializedSize = null\n    this._size = null\n  }\n\n  addLink (link) {\n    this._invalidateCached()\n    return addLink(this, link)\n  }\n\n  rmLink (link) {\n    this._invalidateCached()\n    return rmLink(this, link)\n  }\n\n  // @returns {Promise.<DAGLink>}\n  toDAGLink (options) {\n    return toDAGLink(this, options)\n  }\n\n  serialize () {\n    return serializeDAGNode(this)\n  }\n\n  get size () {\n    if (this._size === null) {\n      if (this._serializedSize === null) {\n        this._serializedSize = this.serialize().length\n      }\n      this._size = this.Links.reduce((sum, l) => sum + l.Tsize, this._serializedSize)\n    }\n\n    return this._size\n  }\n\n  set size (size) {\n    throw new Error(\"Can't set property: 'size' is immutable\")\n  }\n}\n\nexports = module.exports = withIs(DAGNode, { className: 'DAGNode', symbolName: '@ipld/js-ipld-dag-pb/dagnode' })\n","'use strict'\n\nconst sort = require('stable')\nconst uint8ArrayCompare = require('uint8arrays/compare')\n\nconst linkSort = (a, b) => {\n  const buf1 = a.nameAsBuffer\n  const buf2 = b.nameAsBuffer\n\n  return uint8ArrayCompare(buf1, buf2)\n}\n\n/**\n * Sorts links in place (mutating given array)\n * @param {Array} links\n * @returns {void}\n */\nconst sortLinks = (links) => {\n  sort.inplace(links, linkSort)\n}\n\nmodule.exports = sortLinks\n","'use strict'\n\nconst baseX = require('@multiformats/base-x')\nconst Base = require('./base.js')\nconst { rfc4648 } = require('./rfc4648')\nconst { decodeText, encodeText } = require('./util')\n\n/** @typedef {import('./types').CodecFactory} CodecFactory */\n/** @typedef {import('./types').Codec} Codec */\n/** @typedef {import('./types').BaseName} BaseName */\n/** @typedef {import('./types').BaseCode} BaseCode */\n\n/** @type {CodecFactory} */\nconst identity = () => {\n  return {\n    encode: decodeText,\n    decode: encodeText\n  }\n}\n\n/**\n *\n * name, code, implementation, alphabet\n *\n * @type {Array<[BaseName, BaseCode, CodecFactory, string]>}\n */\nconst constants = [\n  ['identity', '\\x00', identity, ''],\n  ['base2', '0', rfc4648(1), '01'],\n  ['base8', '7', rfc4648(3), '01234567'],\n  ['base10', '9', baseX, '0123456789'],\n  ['base16', 'f', rfc4648(4), '0123456789abcdef'],\n  ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],\n  ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],\n  ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],\n  ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],\n  ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],\n  ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],\n  ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],\n  ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],\n  ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],\n  ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],\n  ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],\n  ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],\n  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],\n  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],\n  ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],\n  ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],\n  ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],\n  ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']\n]\n\n/** @type {Record<BaseName,Base>} */\nconst names = constants.reduce((prev, tupple) => {\n  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])\n  return prev\n}, /** @type {Record<BaseName,Base>} */({}))\n\n/** @type {Record<BaseCode,Base>} */\nconst codes = constants.reduce((prev, tupple) => {\n  prev[tupple[1]] = names[tupple[0]]\n  return prev\n}, /** @type {Record<BaseCode,Base>} */({}))\n\nmodule.exports = {\n  names,\n  codes\n}\n","'use strict'\n\n// @ts-ignore\nconst { TextEncoder, TextDecoder } = require('web-encoding')\n\nconst textDecoder = new TextDecoder()\n/**\n * @param {ArrayBufferView|ArrayBuffer} bytes\n * @returns {string}\n */\nconst decodeText = (bytes) => textDecoder.decode(bytes)\n\nconst textEncoder = new TextEncoder()\n/**\n * @param {string} text\n * @returns {Uint8Array}\n */\nconst encodeText = (text) => textEncoder.encode(text)\n\n/**\n * Returns a new Uint8Array created by concatenating the passed Arrays\n *\n * @param {Array<ArrayLike<number>>} arrs\n * @param {number} length\n * @returns {Uint8Array}\n */\nfunction concat (arrs, length) {\n  const output = new Uint8Array(length)\n  let offset = 0\n\n  for (const arr of arrs) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return output\n}\n\nmodule.exports = { decodeText, encodeText, concat }\n","'use strict'\n\nconst protons = require('protons')\nconst proto = protons(require('./dag.proto.js'))\nconst DAGLink = require('./dag-link/dagLink')\n\nexports = module.exports\n\nconst toProtoBuf = (node) => {\n  const pbn = {}\n\n  if (node.Data && node.Data.byteLength > 0) {\n    pbn.Data = node.Data\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization\n    // `null !== new Uint8Array(0)`\n    pbn.Data = null\n  }\n\n  if (node.Links && node.Links.length > 0) {\n    pbn.Links = node.Links\n      .map((link) => ({\n        Hash: link.Hash.bytes,\n        Name: link.Name,\n        Tsize: link.Tsize\n      }))\n  } else {\n    pbn.Links = null\n  }\n\n  return pbn\n}\n\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {Object} node - Internal representation of a PB block\n * @returns {Uint8Array} - The encoded binary representation\n */\nconst serializeDAGNode = (node) => {\n  const data = node.Data\n  const links = node.Links || []\n\n  const serialized = proto.PBNode.encode(toProtoBuf({\n    Data: data,\n    Links: links\n  }))\n\n  return serialized\n}\n\n// Serialize an object where the `Links` might not be a `DAGLink` instance yet\nconst serializeDAGNodeLike = (data, links = []) => {\n  const node = { Data: data }\n  node.Links = links.map((link) => {\n    return DAGLink.isDAGLink(link)\n      ? link\n      : DAGLink.util.createDagLinkFromB58EncodedHash(link)\n  })\n  return serializeDAGNode(node)\n}\n\nexports.serializeDAGNode = serializeDAGNode\nexports.serializeDAGNodeLike = serializeDAGNodeLike\n","'use strict'\n\nvar schema = require('protocol-buffers-schema')\nvar compile = require('./compile')\n\nvar flatten = function (values) {\n  if (!values) return null\n  var result = {}\n  Object.keys(values).forEach(function (k) {\n    result[k] = values[k].value\n  })\n  return result\n}\n\nmodule.exports = function (proto, opts) {\n  if (!opts) opts = {}\n  if (!proto) throw new Error('Pass in a .proto string or a protobuf-schema parsed object')\n\n  var sch = (typeof proto === 'object' && !(proto instanceof Uint8Array)) ? proto : schema.parse(proto)\n\n  // to not make toString,toJSON enumarable we make a fire-and-forget prototype\n  var Messages = function () {\n    var self = this\n\n    compile(sch, opts.encodings || {}).forEach(function (m) {\n      self[m.name] = flatten(m.values) || m\n    })\n  }\n\n  Messages.prototype.toString = function () {\n    return schema.stringify(sch)\n  }\n\n  Messages.prototype.toJSON = function () {\n    return sch\n  }\n\n  return new Messages()\n}\n","'use strict'\n\nmodule.exports = `// An IPFS MerkleDAG Link\nmessage PBLink {\n\n  // multihash of the target object\n  optional bytes Hash = 1;\n\n  // utf string name. should be unique per object\n  optional string Name = 2;\n\n  // cumulative size of target object\n  optional uint64 Tsize = 3;\n}\n\n// An IPFS MerkleDAG Node\nmessage PBNode {\n\n  // refs to other objects\n  repeated PBLink Links = 2;\n\n  // opaque user data\n  optional bytes Data = 1;\n}`\n","'use strict'\n\nconst CID = require('cids')\nconst multicodec = require('multicodec')\nconst multihashing = require('multihashing-async')\n\nexports = module.exports\n\nexports.codec = multicodec.DAG_PB\nexports.defaultHashAlg = multicodec.SHA2_256\n\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Object} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {number} [userOptions.cidVersion=1] - CID version number\n * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format\n * @returns {Promise.<CID>}\n */\nconst cid = async (binaryBlob, userOptions) => {\n  const defaultOptions = { cidVersion: 1, hashAlg: exports.defaultHashAlg }\n  const options = Object.assign(defaultOptions, userOptions)\n\n  const multihash = await multihashing(binaryBlob, options.hashAlg)\n  const codecName = multicodec.print[exports.codec]\n  const cid = new CID(options.cidVersion, codecName, multihash)\n\n  return cid\n}\n\nexports.cid = cid\n","module.exports = {\n    encode: require('./encode.js')\n  , decode: require('./decode.js')\n  , encodingLength: require('./length.js')\n}\n","'use strict'\n\nconst varint = require('varint')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\n\nmodule.exports = {\n  numberToUint8Array,\n  uint8ArrayToNumber,\n  varintUint8ArrayEncode,\n  varintEncode\n}\n\nfunction uint8ArrayToNumber (buf) {\n  return parseInt(uint8ArrayToString(buf, 'base16'), 16)\n}\n\nfunction numberToUint8Array (num) {\n  let hexString = num.toString(16)\n  if (hexString.length % 2 === 1) {\n    hexString = '0' + hexString\n  }\n  return uint8ArrayFromString(hexString, 'base16')\n}\n\nfunction varintUint8ArrayEncode (input) {\n  return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)))\n}\n\nfunction varintEncode (num) {\n  return Uint8Array.from(varint.encode(num))\n}\n","/**\n * Multihash implementation in JavaScript.\n */\n'use strict'\n\nconst multibase = require('multibase')\nconst varint = require('varint')\nconst { names } = require('./constants')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\nconst uint8ArrayConcat = require('uint8arrays/concat')\n\nconst codes = /** @type {import('./types').CodeNameMap} */({})\n\n// eslint-disable-next-line guard-for-in\nfor (const key in names) {\n  const name = /** @type {HashName} */(key)\n  codes[names[name]] = name\n}\nObject.freeze(codes)\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toHexString (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  return uint8ArrayToString(hash, 'base16')\n}\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Uint8Array}\n */\nfunction fromHexString (hash) {\n  return uint8ArrayFromString(hash, 'base16')\n}\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toB58String (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1)\n}\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Uint8Array} hash\n * @returns {Uint8Array}\n */\nfunction fromB58String (hash) {\n  const encoded = hash instanceof Uint8Array\n    ? uint8ArrayToString(hash)\n    : hash\n\n  return multibase.decode('z' + encoded)\n}\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Uint8Array} bytes\n * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result\n */\nfunction decode (bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new Error('multihash must be a Uint8Array')\n  }\n\n  if (bytes.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.')\n  }\n\n  const code = /** @type {HashCode} */(varint.decode(bytes))\n  if (!isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\n  }\n  bytes = bytes.slice(varint.decode.bytes)\n\n  const len = varint.decode(bytes)\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`)\n  }\n  bytes = bytes.slice(varint.decode.bytes)\n\n  if (bytes.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`)\n  }\n\n  return {\n    code,\n    name: codes[code],\n    length: len,\n    digest: bytes\n  }\n}\n\n/**\n * Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Uint8Array} digest\n * @param {HashName | HashCode} code\n * @param {number} [length]\n * @returns {Uint8Array}\n */\nfunction encode (digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code')\n  }\n\n  // ensure it's a hashfunction code.\n  const hashfn = coerceCode(code)\n\n  if (!(digest instanceof Uint8Array)) {\n    throw new Error('digest should be a Uint8Array')\n  }\n\n  if (length == null) {\n    length = digest.length\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.')\n  }\n\n  const hash = varint.encode(hashfn)\n  const len = varint.encode(length)\n  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length)\n}\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n *\n * @param {HashName | number} name\n * @returns {number}\n */\nfunction coerceCode (name) {\n  let code = name\n\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`)\n    }\n    code = names[name]\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\n  }\n\n  // @ts-ignore\n  if (codes[code] === undefined && !isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`)\n  }\n\n  return code\n}\n\n/**\n * Checks if a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction isAppCode (code) {\n  return code > 0 && code < 0x10\n}\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {HashCode} code\n * @returns {boolean}\n */\nfunction isValidCode (code) {\n  if (isAppCode(code)) {\n    return true\n  }\n\n  if (codes[code]) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {void}\n * @throws {Error}\n */\nfunction validate (multihash) {\n  decode(multihash) // throws if bad.\n}\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n * @throws {Error}\n */\nfunction prefix (multihash) {\n  validate(multihash)\n\n  return multihash.subarray(0, 2)\n}\n\nmodule.exports = {\n  names,\n  codes,\n  toHexString,\n  fromHexString,\n  toB58String,\n  fromB58String,\n  decode,\n  encode,\n  coerceCode,\n  isAppCode,\n  validate,\n  prefix,\n  isValidCode\n}\n\n/**\n * @typedef { import(\"./constants\").HashCode } HashCode\n * @typedef { import(\"./constants\").HashName } HashName\n */\n","var ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array'\n\n// For convenience, let people hash a string, not just a Uint8Array\nfunction normalizeInput (input) {\n  var ret\n  if (input instanceof Uint8Array) {\n    ret = input\n  } else if (input instanceof Buffer) {\n    ret = new Uint8Array(input)\n  } else if (typeof (input) === 'string') {\n    ret = new Uint8Array(Buffer.from(input, 'utf8'))\n  } else {\n    throw new Error(ERROR_MSG_INPUT)\n  }\n  return ret\n}\n\n// Converts a Uint8Array to a hexadecimal string\n// For example, toHex([255, 0, 255]) returns \"ff00ff\"\nfunction toHex (bytes) {\n  return Array.prototype.map.call(bytes, function (n) {\n    return (n < 16 ? '0' : '') + n.toString(16)\n  }).join('')\n}\n\n// Converts any value in [0...2^32-1] to an 8-character hex string\nfunction uint32ToHex (val) {\n  return (0x100000000 + val).toString(16).substring(1)\n}\n\n// For debugging: prints out hash state in the same format as the RFC\n// sample computation exactly, so that you can diff\nfunction debugPrint (label, arr, size) {\n  var msg = '\\n' + label + ' = '\n  for (var i = 0; i < arr.length; i += 2) {\n    if (size === 32) {\n      msg += uint32ToHex(arr[i]).toUpperCase()\n      msg += ' '\n      msg += uint32ToHex(arr[i + 1]).toUpperCase()\n    } else if (size === 64) {\n      msg += uint32ToHex(arr[i + 1]).toUpperCase()\n      msg += uint32ToHex(arr[i]).toUpperCase()\n    } else throw new Error('Invalid size ' + size)\n    if (i % 6 === 4) {\n      msg += '\\n' + new Array(label.length + 4).join(' ')\n    } else if (i < arr.length - 2) {\n      msg += ' '\n    }\n  }\n  console.log(msg)\n}\n\n// For performance testing: generates N bytes of input, hashes M times\n// Measures and prints MB/second hash performance each time\nfunction testSpeed (hashFn, N, M) {\n  var startMs = new Date().getTime()\n\n  var input = new Uint8Array(N)\n  for (var i = 0; i < N; i++) {\n    input[i] = i % 256\n  }\n  var genMs = new Date().getTime()\n  console.log('Generated random input in ' + (genMs - startMs) + 'ms')\n  startMs = genMs\n\n  for (i = 0; i < M; i++) {\n    var hashHex = hashFn(input)\n    var hashMs = new Date().getTime()\n    var ms = hashMs - startMs\n    startMs = hashMs\n    console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...')\n    console.log(Math.round(N / (1 << 20) / (ms / 1000) * 100) / 100 + ' MB PER SECOND')\n  }\n}\n\nmodule.exports = {\n  normalizeInput: normalizeInput,\n  toHex: toHex,\n  debugPrint: debugPrint,\n  testSpeed: testSpeed\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","'use strict'\n\nexports = module.exports = require('./dagLink')\nexports.util = require('./util')\n","'use strict'\n\nconst protons = require('protons')\nconst proto = protons(require('./dag.proto'))\nconst DAGLink = require('./dag-link/dagLink')\nconst DAGNode = require('./dag-node/dagNode')\nconst { serializeDAGNodeLike } = require('./serialize')\nconst genCid = require('./genCid')\n\nexports = module.exports\n\nexports.codec = genCid.codec\nexports.defaultHashAlg = genCid.defaultHashAlg\n\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Object} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {number} [userOptions.cidVersion=1] - CID version number\n * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format\n * @returns {Promise.<CID>}\n */\nconst cid = (binaryBlob, userOptions) => {\n  return genCid.cid(binaryBlob, userOptions)\n}\n\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {Object} node - Internal representation of a CBOR block\n * @returns {Uint8Array} - The encoded binary representation\n */\nconst serialize = (node) => {\n  if (DAGNode.isDAGNode(node)) {\n    return node.serialize()\n  } else {\n    return serializeDAGNodeLike(node.Data, node.Links)\n  }\n}\n\n/**\n * Deserialize PB block into the internal representation.\n *\n * @param {Uint8Array} buffer - Binary representation of a PB block\n * @returns {Object} - An object that conforms to the IPLD Data Model\n */\nconst deserialize = (buffer) => {\n  const pbn = proto.PBNode.decode(buffer)\n\n  const links = pbn.Links.map((link) => {\n    return new DAGLink(link.Name, link.Tsize, link.Hash)\n  })\n\n  const data = pbn.Data == null ? new Uint8Array(0) : pbn.Data\n\n  return new DAGNode(data, links, buffer.byteLength)\n}\n\nexports.serialize = serialize\nexports.deserialize = deserialize\nexports.cid = cid\n","'use strict'\n\nconst cbor = require('borc')\nconst multicodec = require('multicodec')\nconst multihashing = require('multihashing-async')\nconst CID = require('cids')\nconst isCircular = require('is-circular')\nconst uint8ArrayConcat = require('uint8arrays/concat')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\nfunction tagCID (cid) {\n  if (typeof cid === 'string') {\n    cid = new CID(cid).bytes\n  } else if (CID.isCID(cid)) {\n    cid = cid.bytes\n  }\n\n  return new cbor.Tagged(CID_CBOR_TAG, uint8ArrayConcat([\n    uint8ArrayFromString('00', 'base16'), // thanks jdag\n    cid\n  ], 1 + cid.length))\n}\n\nfunction replaceCIDbyTAG (dagNode) {\n  let circular\n  try {\n    circular = isCircular(dagNode)\n  } catch (e) {\n    circular = false\n  }\n  if (circular) {\n    throw new Error('The object passed has circular references')\n  }\n\n  function transform (obj) {\n    if (!obj || obj instanceof Uint8Array || typeof obj === 'string') {\n      return obj\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(transform)\n    }\n\n    if (CID.isCID(obj)) {\n      return tagCID(obj)\n    }\n\n    const keys = Object.keys(obj)\n\n    if (keys.length > 0) {\n      // Recursive transform\n      const out = {}\n      keys.forEach((key) => {\n        if (typeof obj[key] === 'object') {\n          out[key] = transform(obj[key])\n        } else {\n          out[key] = obj[key]\n        }\n      })\n      return out\n    } else {\n      return obj\n    }\n  }\n\n  return transform(dagNode)\n}\n\nconst codec = multicodec.DAG_CBOR\nconst defaultHashAlg = multicodec.SHA2_256\n\nconst defaultTags = {\n  [CID_CBOR_TAG]: (val) => {\n    // remove that 0\n    val = val.slice(1)\n    return new CID(val)\n  }\n}\nconst defaultSize = 64 * 1024 // current decoder heap size, 64 Kb\nlet currentSize = defaultSize\nconst defaultMaxSize = 64 * 1024 * 1024 // max heap size when auto-growing, 64 Mb\nlet maxSize = defaultMaxSize\nlet decoder = null\n\n/**\n * Configure the underlying CBOR decoder.\n *\n * @param {Object} [options] - The options the decoder takes. The decoder will reset to the defaul values if no options are given.\n * @param {number} [options.size=65536] - The current heap size used in CBOR parsing, this may grow automatically as larger blocks are encountered up to `maxSize`\n * @param {number} [options.maxSize=67108864] - The maximum size the CBOR parsing heap is allowed to grow to before `dagCBOR.util.deserialize()` returns an error\n * @param {Object} [options.tags] - An object whose keys are CBOR tag numbers and values are transform functions that accept a `value` and return a decoded representation of that `value`\n */\nfunction configureDecoder (options) {\n  let tags = defaultTags\n\n  if (options) {\n    if (typeof options.size === 'number') {\n      currentSize = options.size\n    }\n    if (typeof options.maxSize === 'number') {\n      maxSize = options.maxSize\n    }\n    if (options.tags) {\n      tags = Object.assign({}, defaultTags, options && options.tags)\n    }\n  } else {\n    // no options, reset to defaults\n    currentSize = defaultSize\n    maxSize = defaultMaxSize\n  }\n\n  const decoderOptions = {\n    tags,\n    size: currentSize\n  }\n\n  decoder = new cbor.Decoder(decoderOptions)\n  // borc edits opts.size in-place so we can capture _actual_ size\n  currentSize = decoderOptions.size\n}\n\nconfigureDecoder() // Setup default cbor.Decoder\n\n/**\n * Serialize internal representation into a binary CBOR block.\n *\n * @param {Object} node - Internal representation of a CBOR block\n * @returns {Uint8Array} - The encoded binary representation\n */\nfunction serialize (node) {\n  const nodeTagged = replaceCIDbyTAG(node)\n  const serialized = cbor.encode(nodeTagged)\n\n  return serialized\n}\n\n/**\n * Deserialize CBOR block into the internal representation.\n *\n * @param {Uint8Array} data - Binary representation of a CBOR block\n * @returns {Object} - An object that conforms to the IPLD Data Model\n */\nfunction deserialize (data) {\n  if (data.length > currentSize && data.length <= maxSize) {\n    configureDecoder({ size: data.length })\n  }\n\n  if (data.length > currentSize) {\n    throw new Error('Data is too large to deserialize with current decoder')\n  }\n\n  // borc will decode back-to-back objects into an implicit top-level array, we\n  // strictly want to only see a single explicit top-level object\n  const all = decoder.decodeAll(data)\n  if (all.length !== 1) {\n    throw new Error('Extraneous CBOR data found beyond initial top-level object')\n  }\n\n  return all[0]\n}\n\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Object} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {number} [userOptions.cidVersion=1] - CID version number\n * @param {string} [userOptions.hashAlg] - Defaults to the defaultHashAlg of the format\n * @returns {Promise.<CID>}\n */\nasync function cid (binaryBlob, userOptions) {\n  const defaultOptions = { cidVersion: 1, hashAlg: defaultHashAlg }\n  const options = Object.assign(defaultOptions, userOptions)\n\n  const multihash = await multihashing(binaryBlob, options.hashAlg)\n  const codecName = multicodec.getNameFromCode(codec)\n  const cid = new CID(options.cidVersion, codecName, multihash)\n\n  return cid\n}\n\nmodule.exports = {\n  codec,\n  defaultHashAlg,\n  configureDecoder,\n  serialize,\n  deserialize,\n  cid\n}\n","'use strict'\n\nconst { Buffer } = require('buffer')\nconst ieee754 = require('ieee754')\nconst Bignumber = require('bignumber.js').BigNumber\n\nconst parser = require('./decoder.asm')\nconst utils = require('./utils')\nconst c = require('./constants')\nconst Simple = require('./simple')\nconst Tagged = require('./tagged')\nconst { URL } = require('iso-url')\n\n/**\n * Transform binary cbor data into JavaScript objects.\n */\nclass Decoder {\n  /**\n   * @param {Object} [opts={}]\n   * @param {number} [opts.size=65536] - Size of the allocated heap.\n   */\n  constructor (opts) {\n    opts = opts || {}\n\n    if (!opts.size || opts.size < 0x10000) {\n      opts.size = 0x10000\n    } else {\n      // Ensure the size is a power of 2\n      opts.size = utils.nextPowerOf2(opts.size)\n    }\n\n    // Heap use to share the input with the parser\n    this._heap = new ArrayBuffer(opts.size)\n    this._heap8 = new Uint8Array(this._heap)\n    this._buffer = Buffer.from(this._heap)\n\n    this._reset()\n\n    // Known tags\n    this._knownTags = Object.assign({\n      0: (val) => new Date(val),\n      1: (val) => new Date(val * 1000),\n      2: (val) => utils.arrayBufferToBignumber(val),\n      3: (val) => c.NEG_ONE.minus(utils.arrayBufferToBignumber(val)),\n      4: (v) => {\n        // const v = new Uint8Array(val)\n        return c.TEN.pow(v[0]).times(v[1])\n      },\n      5: (v) => {\n        // const v = new Uint8Array(val)\n        return c.TWO.pow(v[0]).times(v[1])\n      },\n      32: (val) => new URL(val),\n      35: (val) => new RegExp(val)\n    }, opts.tags)\n\n    // Initialize asm based parser\n    this.parser = parser(global, {\n      // eslint-disable-next-line no-console\n      log: console.log.bind(console),\n      pushInt: this.pushInt.bind(this),\n      pushInt32: this.pushInt32.bind(this),\n      pushInt32Neg: this.pushInt32Neg.bind(this),\n      pushInt64: this.pushInt64.bind(this),\n      pushInt64Neg: this.pushInt64Neg.bind(this),\n      pushFloat: this.pushFloat.bind(this),\n      pushFloatSingle: this.pushFloatSingle.bind(this),\n      pushFloatDouble: this.pushFloatDouble.bind(this),\n      pushTrue: this.pushTrue.bind(this),\n      pushFalse: this.pushFalse.bind(this),\n      pushUndefined: this.pushUndefined.bind(this),\n      pushNull: this.pushNull.bind(this),\n      pushInfinity: this.pushInfinity.bind(this),\n      pushInfinityNeg: this.pushInfinityNeg.bind(this),\n      pushNaN: this.pushNaN.bind(this),\n      pushNaNNeg: this.pushNaNNeg.bind(this),\n      pushArrayStart: this.pushArrayStart.bind(this),\n      pushArrayStartFixed: this.pushArrayStartFixed.bind(this),\n      pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),\n      pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),\n      pushObjectStart: this.pushObjectStart.bind(this),\n      pushObjectStartFixed: this.pushObjectStartFixed.bind(this),\n      pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),\n      pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),\n      pushByteString: this.pushByteString.bind(this),\n      pushByteStringStart: this.pushByteStringStart.bind(this),\n      pushUtf8String: this.pushUtf8String.bind(this),\n      pushUtf8StringStart: this.pushUtf8StringStart.bind(this),\n      pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),\n      pushTagUnassigned: this.pushTagUnassigned.bind(this),\n      pushTagStart: this.pushTagStart.bind(this),\n      pushTagStart4: this.pushTagStart4.bind(this),\n      pushTagStart8: this.pushTagStart8.bind(this),\n      pushBreak: this.pushBreak.bind(this)\n    }, this._heap)\n  }\n\n  get _depth () {\n    return this._parents.length\n  }\n\n  get _currentParent () {\n    return this._parents[this._depth - 1]\n  }\n\n  get _ref () {\n    return this._currentParent.ref\n  }\n\n  // Finish the current parent\n  _closeParent () {\n    var p = this._parents.pop()\n\n    if (p.length > 0) {\n      throw new Error(`Missing ${p.length} elements`)\n    }\n\n    switch (p.type) {\n      case c.PARENT.TAG:\n        this._push(\n          this.createTag(p.ref[0], p.ref[1])\n        )\n        break\n      case c.PARENT.BYTE_STRING:\n        this._push(this.createByteString(p.ref, p.length))\n        break\n      case c.PARENT.UTF8_STRING:\n        this._push(this.createUtf8String(p.ref, p.length))\n        break\n      case c.PARENT.MAP:\n        if (p.values % 2 > 0) {\n          throw new Error('Odd number of elements in the map')\n        }\n        this._push(this.createMap(p.ref, p.length))\n        break\n      case c.PARENT.OBJECT:\n        if (p.values % 2 > 0) {\n          throw new Error('Odd number of elements in the map')\n        }\n        this._push(this.createObject(p.ref, p.length))\n        break\n      case c.PARENT.ARRAY:\n        this._push(this.createArray(p.ref, p.length))\n        break\n      default:\n        break\n    }\n\n    if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {\n      this._dec()\n    }\n  }\n\n  // Reduce the expected length of the current parent by one\n  _dec () {\n    const p = this._currentParent\n    // The current parent does not know the epxected child length\n\n    if (p.length < 0) {\n      return\n    }\n\n    p.length--\n\n    // All children were seen, we can close the current parent\n    if (p.length === 0) {\n      this._closeParent()\n    }\n  }\n\n  // Push any value to the current parent\n  _push (val, hasChildren) {\n    const p = this._currentParent\n    p.values++\n\n    switch (p.type) {\n      case c.PARENT.ARRAY:\n      case c.PARENT.BYTE_STRING:\n      case c.PARENT.UTF8_STRING:\n        if (p.length > -1) {\n          this._ref[this._ref.length - p.length] = val\n        } else {\n          this._ref.push(val)\n        }\n        this._dec()\n        break\n      case c.PARENT.OBJECT:\n        if (p.tmpKey != null) {\n          this._ref[p.tmpKey] = val\n          p.tmpKey = null\n          this._dec()\n        } else {\n          p.tmpKey = val\n\n          if (typeof p.tmpKey !== 'string') {\n            // too bad, convert to a Map\n            p.type = c.PARENT.MAP\n            p.ref = utils.buildMap(p.ref)\n          }\n        }\n        break\n      case c.PARENT.MAP:\n        if (p.tmpKey != null) {\n          this._ref.set(p.tmpKey, val)\n          p.tmpKey = null\n          this._dec()\n        } else {\n          p.tmpKey = val\n        }\n        break\n      case c.PARENT.TAG:\n        this._ref.push(val)\n        if (!hasChildren) {\n          this._dec()\n        }\n        break\n      default:\n        throw new Error('Unknown parent type')\n    }\n  }\n\n  // Create a new parent in the parents list\n  _createParent (obj, type, len) {\n    this._parents[this._depth] = {\n      type: type,\n      length: len,\n      ref: obj,\n      values: 0,\n      tmpKey: null\n    }\n  }\n\n  // Reset all state back to the beginning, also used for initiatlization\n  _reset () {\n    this._res = []\n    this._parents = [{\n      type: c.PARENT.ARRAY,\n      length: -1,\n      ref: this._res,\n      values: 0,\n      tmpKey: null\n    }]\n  }\n\n  // -- Interface to customize deoding behaviour\n  createTag (tagNumber, value) {\n    const typ = this._knownTags[tagNumber]\n\n    if (!typ) {\n      return new Tagged(tagNumber, value)\n    }\n\n    return typ(value)\n  }\n\n  createMap (obj, len) {\n    return obj\n  }\n\n  createObject (obj, len) {\n    return obj\n  }\n\n  createArray (arr, len) {\n    return arr\n  }\n\n  createByteString (raw, len) {\n    return Buffer.concat(raw)\n  }\n\n  createByteStringFromHeap (start, end) {\n    if (start === end) {\n      return Buffer.alloc(0)\n    }\n\n    return Buffer.from(this._heap.slice(start, end))\n  }\n\n  createInt (val) {\n    return val\n  }\n\n  createInt32 (f, g) {\n    return utils.buildInt32(f, g)\n  }\n\n  createInt64 (f1, f2, g1, g2) {\n    return utils.buildInt64(f1, f2, g1, g2)\n  }\n\n  createFloat (val) {\n    return val\n  }\n\n  createFloatSingle (a, b, c, d) {\n    return ieee754.read([a, b, c, d], 0, false, 23, 4)\n  }\n\n  createFloatDouble (a, b, c, d, e, f, g, h) {\n    return ieee754.read([a, b, c, d, e, f, g, h], 0, false, 52, 8)\n  }\n\n  createInt32Neg (f, g) {\n    return -1 - utils.buildInt32(f, g)\n  }\n\n  createInt64Neg (f1, f2, g1, g2) {\n    const f = utils.buildInt32(f1, f2)\n    const g = utils.buildInt32(g1, g2)\n\n    if (f > c.MAX_SAFE_HIGH) {\n      return c.NEG_ONE.minus(new Bignumber(f).times(c.SHIFT32).plus(g))\n    }\n\n    return -1 - ((f * c.SHIFT32) + g)\n  }\n\n  createTrue () {\n    return true\n  }\n\n  createFalse () {\n    return false\n  }\n\n  createNull () {\n    return null\n  }\n\n  createUndefined () {\n    return undefined\n  }\n\n  createInfinity () {\n    return Infinity\n  }\n\n  createInfinityNeg () {\n    return -Infinity\n  }\n\n  createNaN () {\n    return NaN\n  }\n\n  createNaNNeg () {\n    return -NaN\n  }\n\n  createUtf8String (raw, len) {\n    return raw.join('')\n  }\n\n  createUtf8StringFromHeap (start, end) {\n    if (start === end) {\n      return ''\n    }\n\n    return this._buffer.toString('utf8', start, end)\n  }\n\n  createSimpleUnassigned (val) {\n    return new Simple(val)\n  }\n\n  // -- Interface for decoder.asm.js\n\n  pushInt (val) {\n    this._push(this.createInt(val))\n  }\n\n  pushInt32 (f, g) {\n    this._push(this.createInt32(f, g))\n  }\n\n  pushInt64 (f1, f2, g1, g2) {\n    this._push(this.createInt64(f1, f2, g1, g2))\n  }\n\n  pushFloat (val) {\n    this._push(this.createFloat(val))\n  }\n\n  pushFloatSingle (a, b, c, d) {\n    this._push(this.createFloatSingle(a, b, c, d))\n  }\n\n  pushFloatDouble (a, b, c, d, e, f, g, h) {\n    this._push(this.createFloatDouble(a, b, c, d, e, f, g, h))\n  }\n\n  pushInt32Neg (f, g) {\n    this._push(this.createInt32Neg(f, g))\n  }\n\n  pushInt64Neg (f1, f2, g1, g2) {\n    this._push(this.createInt64Neg(f1, f2, g1, g2))\n  }\n\n  pushTrue () {\n    this._push(this.createTrue())\n  }\n\n  pushFalse () {\n    this._push(this.createFalse())\n  }\n\n  pushNull () {\n    this._push(this.createNull())\n  }\n\n  pushUndefined () {\n    this._push(this.createUndefined())\n  }\n\n  pushInfinity () {\n    this._push(this.createInfinity())\n  }\n\n  pushInfinityNeg () {\n    this._push(this.createInfinityNeg())\n  }\n\n  pushNaN () {\n    this._push(this.createNaN())\n  }\n\n  pushNaNNeg () {\n    this._push(this.createNaNNeg())\n  }\n\n  pushArrayStart () {\n    this._createParent([], c.PARENT.ARRAY, -1)\n  }\n\n  pushArrayStartFixed (len) {\n    this._createArrayStartFixed(len)\n  }\n\n  pushArrayStartFixed32 (len1, len2) {\n    const len = utils.buildInt32(len1, len2)\n    this._createArrayStartFixed(len)\n  }\n\n  pushArrayStartFixed64 (len1, len2, len3, len4) {\n    const len = utils.buildInt64(len1, len2, len3, len4)\n    this._createArrayStartFixed(len)\n  }\n\n  pushObjectStart () {\n    this._createObjectStartFixed(-1)\n  }\n\n  pushObjectStartFixed (len) {\n    this._createObjectStartFixed(len)\n  }\n\n  pushObjectStartFixed32 (len1, len2) {\n    const len = utils.buildInt32(len1, len2)\n    this._createObjectStartFixed(len)\n  }\n\n  pushObjectStartFixed64 (len1, len2, len3, len4) {\n    const len = utils.buildInt64(len1, len2, len3, len4)\n    this._createObjectStartFixed(len)\n  }\n\n  pushByteStringStart () {\n    this._parents[this._depth] = {\n      type: c.PARENT.BYTE_STRING,\n      length: -1,\n      ref: [],\n      values: 0,\n      tmpKey: null\n    }\n  }\n\n  pushByteString (start, end) {\n    this._push(this.createByteStringFromHeap(start, end))\n  }\n\n  pushUtf8StringStart () {\n    this._parents[this._depth] = {\n      type: c.PARENT.UTF8_STRING,\n      length: -1,\n      ref: [],\n      values: 0,\n      tmpKey: null\n    }\n  }\n\n  pushUtf8String (start, end) {\n    this._push(this.createUtf8StringFromHeap(start, end))\n  }\n\n  pushSimpleUnassigned (val) {\n    this._push(this.createSimpleUnassigned(val))\n  }\n\n  pushTagStart (tag) {\n    this._parents[this._depth] = {\n      type: c.PARENT.TAG,\n      length: 1,\n      ref: [tag]\n    }\n  }\n\n  pushTagStart4 (f, g) {\n    this.pushTagStart(utils.buildInt32(f, g))\n  }\n\n  pushTagStart8 (f1, f2, g1, g2) {\n    this.pushTagStart(utils.buildInt64(f1, f2, g1, g2))\n  }\n\n  pushTagUnassigned (tagNumber) {\n    this._push(this.createTag(tagNumber))\n  }\n\n  pushBreak () {\n    if (this._currentParent.length > -1) {\n      throw new Error('Unexpected break')\n    }\n\n    this._closeParent()\n  }\n\n  _createObjectStartFixed (len) {\n    if (len === 0) {\n      this._push(this.createObject({}))\n      return\n    }\n\n    this._createParent({}, c.PARENT.OBJECT, len)\n  }\n\n  _createArrayStartFixed (len) {\n    if (len === 0) {\n      this._push(this.createArray([]))\n      return\n    }\n\n    this._createParent(new Array(len), c.PARENT.ARRAY, len)\n  }\n\n  _decode (input) {\n    if (input.byteLength === 0) {\n      throw new Error('Input too short')\n    }\n\n    this._reset()\n    this._heap8.set(input)\n    const code = this.parser.parse(input.byteLength)\n\n    if (this._depth > 1) {\n      while (this._currentParent.length === 0) {\n        this._closeParent()\n      }\n      if (this._depth > 1) {\n        throw new Error('Undeterminated nesting')\n      }\n    }\n\n    if (code > 0) {\n      throw new Error('Failed to parse')\n    }\n\n    if (this._res.length === 0) {\n      throw new Error('No valid result')\n    }\n  }\n\n  // -- Public Interface\n\n  decodeFirst (input) {\n    this._decode(input)\n\n    return this._res[0]\n  }\n\n  decodeAll (input) {\n    this._decode(input)\n\n    return this._res\n  }\n\n  /**\n   * Decode the first cbor object.\n   *\n   * @param {Buffer|string} input\n   * @param {string} [enc='hex'] - Encoding used if a string is passed.\n   * @returns {*}\n   */\n  static decode (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Decoder({ size: input.length })\n    return dec.decodeFirst(input)\n  }\n\n  /**\n   * Decode all cbor objects.\n   *\n   * @param {Buffer|string} input\n   * @param {string} [enc='hex'] - Encoding used if a string is passed.\n   * @returns {Array<*>}\n   */\n  static decodeAll (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Decoder({ size: input.length })\n    return dec.decodeAll(input)\n  }\n}\n\nDecoder.decodeFirst = Decoder.decode\n\nmodule.exports = Decoder\n","'use strict'\n\nconst constants = require('./constants')\nconst MT = constants.MT\nconst SIMPLE = constants.SIMPLE\nconst SYMS = constants.SYMS\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {integer} value - the simple value's integer value\n   */\n  constructor (value) {\n    if (typeof value !== 'number') {\n      throw new Error('Invalid Simple type: ' + (typeof value))\n    }\n    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {\n      throw new Error('value must be a small positive integer: ' + value)\n    }\n    this.value = value\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  toString () {\n    return 'simple(' + this.value + ')'\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  inspect () {\n    return 'simple(' + this.value + ')'\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {cbor.Encoder} gen The generator to push onto\n   * @returns {number}\n   */\n  encodeCBOR (gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT)\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj - object to test\n   * @returns {bool} - is it Simple?\n   */\n  static isSimple (obj) {\n    return obj instanceof Simple\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {Number} val - the CBOR additional info to convert\n   * @param {bool} hasParent - Does the CBOR item have a parent?\n   * @returns {(null|undefined|Boolean|Symbol)} - the decoded value\n   */\n  static decode (val, hasParent) {\n    if (hasParent == null) {\n      hasParent = true\n    }\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false\n      case SIMPLE.TRUE:\n        return true\n      case SIMPLE.NULL:\n        if (hasParent) {\n          return null\n        } else {\n          return SYMS.NULL\n        }\n      case SIMPLE.UNDEFINED:\n        if (hasParent) {\n          return undefined\n        } else {\n          return SYMS.UNDEFINED\n        }\n      case -1:\n        if (!hasParent) {\n          throw new Error('Invalid BREAK')\n        }\n        return SYMS.BREAK\n      default:\n        return new Simple(val)\n    }\n  }\n}\n\nmodule.exports = Simple\n","'use strict'\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {Number} tag - the number of the tag\n   * @param {any} value - the value inside the tag\n   * @param {Error} err - the error that was thrown parsing the tag, or null\n   */\n  constructor (tag, value, err) {\n    this.tag = tag\n    this.value = value\n    this.err = err\n    if (typeof this.tag !== 'number') {\n      throw new Error('Invalid tag type (' + (typeof this.tag) + ')')\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error('Tag must be a positive integer: ' + this.tag)\n    }\n  }\n\n  /**\n   * Convert to a String\n   *\n   * @returns {String} string of the form '1(2)'\n   */\n  toString () {\n    return `${this.tag}(${JSON.stringify(this.value)})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {cbor.Encoder} gen The generator to push onto\n   * @returns {number}\n   */\n  encodeCBOR (gen) {\n    gen._pushTag(this.tag)\n    return gen.pushAny(this.value)\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {Object} converters - keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} - the converted item\n   */\n  convert (converters) {\n    var er, f\n    f = converters != null ? converters[this.tag] : undefined\n    if (typeof f !== 'function') {\n      f = Tagged['_tag' + this.tag]\n      if (typeof f !== 'function') {\n        return this\n      }\n    }\n    try {\n      return f.call(Tagged, this.value)\n    } catch (error) {\n      er = error\n      this.err = er\n      return this\n    }\n  }\n}\n\nmodule.exports = Tagged\n","'use strict';\n\nconst {\n    URLWithLegacySupport,\n    format,\n    URLSearchParams,\n    defaultBase\n} = require('./src/url');\nconst relative = require('./src/relative');\n\nmodule.exports = {\n    URL: URLWithLegacySupport,\n    URLSearchParams,\n    format,\n    relative,\n    defaultBase\n};\n","'use strict';\n\nconst defaultBase = self.location ?\n    self.location.protocol + '//' + self.location.host :\n    '';\nconst URL = self.URL;\n\nclass URLWithLegacySupport {\n    constructor(url = '', base = defaultBase) {\n        this.super = new URL(url, base);\n        this.path = this.pathname + this.search;\n        this.auth =\n            this.username && this.password ?\n                this.username + ':' + this.password :\n                null;\n\n        this.query =\n            this.search && this.search.startsWith('?') ?\n                this.search.slice(1) :\n                null;\n    }\n\n    get hash() {\n        return this.super.hash;\n    }\n    get host() {\n        return this.super.host;\n    }\n    get hostname() {\n        return this.super.hostname;\n    }\n    get href() {\n        return this.super.href;\n    }\n    get origin() {\n        return this.super.origin;\n    }\n    get password() {\n        return this.super.password;\n    }\n    get pathname() {\n        return this.super.pathname;\n    }\n    get port() {\n        return this.super.port;\n    }\n    get protocol() {\n        return this.super.protocol;\n    }\n    get search() {\n        return this.super.search;\n    }\n    get searchParams() {\n        return this.super.searchParams;\n    }\n    get username() {\n        return this.super.username;\n    }\n\n    set hash(hash) {\n        this.super.hash = hash;\n    }\n    set host(host) {\n        this.super.host = host;\n    }\n    set hostname(hostname) {\n        this.super.hostname = hostname;\n    }\n    set href(href) {\n        this.super.href = href;\n    }\n    set origin(origin) {\n        this.super.origin = origin;\n    }\n    set password(password) {\n        this.super.password = password;\n    }\n    set pathname(pathname) {\n        this.super.pathname = pathname;\n    }\n    set port(port) {\n        this.super.port = port;\n    }\n    set protocol(protocol) {\n        this.super.protocol = protocol;\n    }\n    set search(search) {\n        this.super.search = search;\n    }\n    set searchParams(searchParams) {\n        this.super.searchParams = searchParams;\n    }\n    set username(username) {\n        this.super.username = username;\n    }\n\n    createObjectURL(o) {\n        return this.super.createObjectURL(o);\n    }\n    revokeObjectURL(o) {\n        this.super.revokeObjectURL(o);\n    }\n    toJSON() {\n        return this.super.toJSON();\n    }\n    toString() {\n        return this.super.toString();\n    }\n    format() {\n        return this.toString();\n    }\n}\n\nfunction format(obj) {\n    if (typeof obj === 'string') {\n        const url = new URL(obj);\n\n        return url.toString();\n    }\n\n    if (!(obj instanceof URL)) {\n        const userPass =\n            obj.username && obj.password ?\n                `${obj.username}:${obj.password}@` :\n                '';\n        const auth = obj.auth ? obj.auth + '@' : '';\n        const port = obj.port ? ':' + obj.port : '';\n        const protocol = obj.protocol ? obj.protocol + '//' : '';\n        const host = obj.host || '';\n        const hostname = obj.hostname || '';\n        const search = obj.search || (obj.query ? '?' + obj.query : '');\n        const hash = obj.hash || '';\n        const pathname = obj.pathname || '';\n        const path = obj.path || pathname + search;\n\n        return `${protocol}${userPass || auth}${host ||\n            hostname + port}${path}${hash}`;\n    }\n}\n\nmodule.exports = {\n    URLWithLegacySupport,\n    URLSearchParams: self.URLSearchParams,\n    defaultBase,\n    format\n};\n","'use strict'\n\nconst varint = require('varint')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\n\nmodule.exports = {\n  numberToUint8Array,\n  uint8ArrayToNumber,\n  varintUint8ArrayEncode,\n  varintEncode\n}\n\n/**\n * @param {Uint8Array} buf\n */\nfunction uint8ArrayToNumber (buf) {\n  return parseInt(uint8ArrayToString(buf, 'base16'), 16)\n}\n\n/**\n * @param {number} num\n */\nfunction numberToUint8Array (num) {\n  let hexString = num.toString(16)\n  if (hexString.length % 2 === 1) {\n    hexString = '0' + hexString\n  }\n  return uint8ArrayFromString(hexString, 'base16')\n}\n\n/**\n * @param {Uint8Array} input\n */\nfunction varintUint8ArrayEncode (input) {\n  return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)))\n}\n\n/**\n * @param {number} num\n */\nfunction varintEncode (num) {\n  return Uint8Array.from(varint.encode(num))\n}\n","'use strict'\n\nconst { encoding: getCodec } = require('multibase')\nconst { TextDecoder } = require('web-encoding')\nconst utf8Decoder = new TextDecoder('utf8')\n\n/**\n * @typedef {import('multibase/src/types').BaseName} BaseName\n */\n\n/**\n * Turns a Uint8Array of bytes into a string with each\n * character being the char code of the corresponding byte\n *\n * @param {Uint8Array} array - The array to turn into a string\n */\nfunction uint8ArrayToAsciiString (array) {\n  let string = ''\n\n  for (let i = 0; i < array.length; i++) {\n    string += String.fromCharCode(array[i])\n  }\n  return string\n}\n\n/**\n * Turns a `Uint8Array` into a string.\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n *\n * @param {Uint8Array} array - The array to turn into a string\n * @param {BaseName | 'utf8' | 'utf-8' | 'ascii'} [encoding=utf8] - The encoding to use\n * @returns {string}\n */\nfunction toString (array, encoding = 'utf8') {\n  if (encoding === 'utf8' || encoding === 'utf-8') {\n    return utf8Decoder.decode(array)\n  }\n\n  if (encoding === 'ascii') {\n    return uint8ArrayToAsciiString(array)\n  }\n\n  return getCodec(encoding).encode(array)\n}\n\nmodule.exports = toString\n","/**\n * Multihash implementation in JavaScript.\n */\n'use strict'\n\nconst multibase = require('multibase')\nconst varint = require('varint')\nconst { names } = require('./constants')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\nconst uint8ArrayConcat = require('uint8arrays/concat')\n\nconst codes = /** @type {import('./types').CodeNameMap} */({})\n\n// eslint-disable-next-line guard-for-in\nfor (const key in names) {\n  const name = /** @type {HashName} */(key)\n  codes[names[name]] = name\n}\nObject.freeze(codes)\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toHexString (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  return uint8ArrayToString(hash, 'base16')\n}\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Uint8Array}\n */\nfunction fromHexString (hash) {\n  return uint8ArrayFromString(hash, 'base16')\n}\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toB58String (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1)\n}\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Uint8Array} hash\n * @returns {Uint8Array}\n */\nfunction fromB58String (hash) {\n  const encoded = hash instanceof Uint8Array\n    ? uint8ArrayToString(hash)\n    : hash\n\n  return multibase.decode('z' + encoded)\n}\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Uint8Array} bytes\n * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result\n */\nfunction decode (bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new Error('multihash must be a Uint8Array')\n  }\n\n  if (bytes.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.')\n  }\n\n  const code = /** @type {HashCode} */(varint.decode(bytes))\n  if (!isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\n  }\n  bytes = bytes.slice(varint.decode.bytes)\n\n  const len = varint.decode(bytes)\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`)\n  }\n  bytes = bytes.slice(varint.decode.bytes)\n\n  if (bytes.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`)\n  }\n\n  return {\n    code,\n    name: codes[code],\n    length: len,\n    digest: bytes\n  }\n}\n\n/**\n * Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Uint8Array} digest\n * @param {HashName | HashCode} code\n * @param {number} [length]\n * @returns {Uint8Array}\n */\nfunction encode (digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code')\n  }\n\n  // ensure it's a hashfunction code.\n  const hashfn = coerceCode(code)\n\n  if (!(digest instanceof Uint8Array)) {\n    throw new Error('digest should be a Uint8Array')\n  }\n\n  if (length == null) {\n    length = digest.length\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.')\n  }\n\n  const hash = varint.encode(hashfn)\n  const len = varint.encode(length)\n  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length)\n}\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n *\n * @param {HashName | number} name\n * @returns {number}\n */\nfunction coerceCode (name) {\n  let code = name\n\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`)\n    }\n    code = names[name]\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\n  }\n\n  // @ts-ignore\n  if (codes[code] === undefined && !isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`)\n  }\n\n  return code\n}\n\n/**\n * Checks if a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction isAppCode (code) {\n  return code > 0 && code < 0x10\n}\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {HashCode} code\n * @returns {boolean}\n */\nfunction isValidCode (code) {\n  if (isAppCode(code)) {\n    return true\n  }\n\n  if (codes[code]) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {void}\n * @throws {Error}\n */\nfunction validate (multihash) {\n  decode(multihash) // throws if bad.\n}\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n * @throws {Error}\n */\nfunction prefix (multihash) {\n  validate(multihash)\n\n  return multihash.subarray(0, 2)\n}\n\nmodule.exports = {\n  names,\n  codes,\n  toHexString,\n  fromHexString,\n  toB58String,\n  fromB58String,\n  decode,\n  encode,\n  coerceCode,\n  isAppCode,\n  validate,\n  prefix,\n  isValidCode\n}\n\n/**\n * @typedef { import(\"./constants\").HashCode } HashCode\n * @typedef { import(\"./constants\").HashName } HashName\n */\n","/**\n * Multihash implementation in JavaScript.\n */\n'use strict'\n\nconst multibase = require('multibase')\nconst varint = require('varint')\nconst { names } = require('./constants')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\nconst uint8ArrayConcat = require('uint8arrays/concat')\n\nconst codes = /** @type {import('./types').CodeNameMap} */({})\n\n// eslint-disable-next-line guard-for-in\nfor (const key in names) {\n  const name = /** @type {HashName} */(key)\n  codes[names[name]] = name\n}\nObject.freeze(codes)\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toHexString (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  return uint8ArrayToString(hash, 'base16')\n}\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Uint8Array}\n */\nfunction fromHexString (hash) {\n  return uint8ArrayFromString(hash, 'base16')\n}\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toB58String (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1)\n}\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Uint8Array} hash\n * @returns {Uint8Array}\n */\nfunction fromB58String (hash) {\n  const encoded = hash instanceof Uint8Array\n    ? uint8ArrayToString(hash)\n    : hash\n\n  return multibase.decode('z' + encoded)\n}\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Uint8Array} bytes\n * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result\n */\nfunction decode (bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new Error('multihash must be a Uint8Array')\n  }\n\n  if (bytes.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.')\n  }\n\n  const code = /** @type {HashCode} */(varint.decode(bytes))\n  if (!isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\n  }\n  bytes = bytes.slice(varint.decode.bytes)\n\n  const len = varint.decode(bytes)\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`)\n  }\n  bytes = bytes.slice(varint.decode.bytes)\n\n  if (bytes.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`)\n  }\n\n  return {\n    code,\n    name: codes[code],\n    length: len,\n    digest: bytes\n  }\n}\n\n/**\n * Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Uint8Array} digest\n * @param {HashName | HashCode} code\n * @param {number} [length]\n * @returns {Uint8Array}\n */\nfunction encode (digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code')\n  }\n\n  // ensure it's a hashfunction code.\n  const hashfn = coerceCode(code)\n\n  if (!(digest instanceof Uint8Array)) {\n    throw new Error('digest should be a Uint8Array')\n  }\n\n  if (length == null) {\n    length = digest.length\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.')\n  }\n\n  const hash = varint.encode(hashfn)\n  const len = varint.encode(length)\n  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length)\n}\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n *\n * @param {HashName | number} name\n * @returns {number}\n */\nfunction coerceCode (name) {\n  let code = name\n\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`)\n    }\n    code = names[name]\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\n  }\n\n  // @ts-ignore\n  if (codes[code] === undefined && !isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`)\n  }\n\n  return code\n}\n\n/**\n * Checks if a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction isAppCode (code) {\n  return code > 0 && code < 0x10\n}\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {HashCode} code\n * @returns {boolean}\n */\nfunction isValidCode (code) {\n  if (isAppCode(code)) {\n    return true\n  }\n\n  if (codes[code]) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {void}\n * @throws {Error}\n */\nfunction validate (multihash) {\n  decode(multihash) // throws if bad.\n}\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n * @throws {Error}\n */\nfunction prefix (multihash) {\n  validate(multihash)\n\n  return multihash.subarray(0, 2)\n}\n\nmodule.exports = {\n  names,\n  codes,\n  toHexString,\n  fromHexString,\n  toB58String,\n  fromB58String,\n  decode,\n  encode,\n  coerceCode,\n  isAppCode,\n  validate,\n  prefix,\n  isValidCode\n}\n\n/**\n * @typedef { import(\"./constants\").HashCode } HashCode\n * @typedef { import(\"./constants\").HashName } HashName\n */\n","'use strict'\n\nconst { encoding: getCodec } = require('multibase')\nconst { TextEncoder } = require('web-encoding')\nconst utf8Encoder = new TextEncoder()\n\n/**\n * @typedef {import('multibase/src/types').BaseName} BaseName\n */\n\n/**\n * Interprets each character in a string as a byte and\n * returns a Uint8Array of those bytes.\n *\n * @param {string} string - The string to turn into an array\n */\nfunction asciiStringToUint8Array (string) {\n  const array = new Uint8Array(string.length)\n\n  for (let i = 0; i < string.length; i++) {\n    array[i] = string.charCodeAt(i)\n  }\n\n  return array\n}\n\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n *\n * @param {string} string\n * @param {BaseName | 'utf8' | 'utf-8' | 'ascii'} [encoding=utf8] - utf8, base16, base64, base64urlpad, etc\n * @returns {Uint8Array}\n */\nfunction fromString (string, encoding = 'utf8') {\n  if (encoding === 'utf8' || encoding === 'utf-8') {\n    return utf8Encoder.encode(string)\n  }\n\n  if (encoding === 'ascii') {\n    return asciiStringToUint8Array(string)\n  }\n\n  return getCodec(encoding).decode(string)\n}\n\nmodule.exports = fromString\n","'use strict'\n\nconst CID = require('cids')\nconst configure = require('../lib/configure')\nconst toUrlSearchParams = require('../lib/to-url-search-params')\n\nmodule.exports = configure(api => {\n  /**\n   * @type {import('..').Implements<typeof import('ipfs-core/src/components/dag/resolve')>}\n   */\n  const resolve = async (ipfsPath, options = {}) => {\n    const res = await api.post('dag/resolve', {\n      timeout: options.timeout,\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: `${ipfsPath}${options.path ? `/${options.path}`.replace(/\\/[/]+/g, '/') : ''}`,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    const data = await res.json()\n\n    return { cid: new CID(data.Cid['/']), remainderPath: data.RemPath }\n  }\n\n  return resolve\n})\n","'use strict'\n\nconst toCamel = require('./object-to-camel')\n\nfunction toCamelWithMetadata (entry) {\n  const file = toCamel(entry)\n\n  if (Object.prototype.hasOwnProperty.call(file, 'mode')) {\n    file.mode = parseInt(file.mode, 8)\n  }\n\n  if (Object.prototype.hasOwnProperty.call(file, 'mtime')) {\n    file.mtime = {\n      secs: file.mtime,\n      nsecs: file.mtimeNsecs || 0\n    }\n\n    delete file.mtimeNsecs\n  }\n\n  return file\n}\n\nmodule.exports = toCamelWithMetadata\n","'use strict'\n\nconst CID = require('cids')\nconst toCamelWithMetadata = require('../lib/object-to-camel-with-metadata')\nconst configure = require('../lib/configure')\nconst toUrlSearchParams = require('../lib/to-url-search-params')\n\nmodule.exports = configure(api => {\n  /**\n   * @type {import('..').Implements<typeof import('ipfs-core/src/components/files/stat')>}\n   */\n  async function stat (path, options = {}) {\n    if (typeof path !== 'string') {\n      options = path || {}\n      path = '/'\n    }\n\n    const res = await api.post('files/stat', {\n      timeout: options.timeout,\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: path,\n        ...options\n      }),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    data.WithLocality = data.WithLocality || false\n    return toCoreInterface(toCamelWithMetadata(data))\n  }\n\n  return stat\n})\n\nfunction toCoreInterface (entry) {\n  entry.cid = new CID(entry.hash)\n  delete entry.hash\n  return entry\n}\n","'use strict'\n\nconst CID = require('cids')\nconst configure = require('../lib/configure')\nconst normaliseInput = require('ipfs-core-utils/src/pins/normalise-input')\nconst toUrlSearchParams = require('../lib/to-url-search-params')\n\nmodule.exports = configure(api => {\n  return async function * addAll (source, options = {}) {\n    for await (const { path, recursive, metadata } of normaliseInput(source)) {\n      const res = await api.post('pin/add', {\n        timeout: options.timeout,\n        signal: options.signal,\n        searchParams: toUrlSearchParams({\n          ...options,\n          arg: path,\n          recursive,\n          metadata: metadata ? JSON.stringify(metadata) : undefined,\n          stream: true\n        }),\n        headers: options.headers\n      })\n\n      for await (const pin of res.ndjson()) {\n        if (pin.Pins) { // non-streaming response\n          for (const cid of pin.Pins) {\n            yield new CID(cid)\n          }\n          continue\n        }\n\n        yield new CID(pin)\n      }\n    }\n  }\n})\n","'use strict'\n\nconst errCode = require('err-code')\nconst CID = require('cids')\n\n/**\n * Transform one of:\n *\n * ```ts\n * CID\n * String\n * { cid: CID recursive, metadata }\n * { path: String recursive, metadata }\n * Iterable<CID>\n * Iterable<String>\n * Iterable<{ cid: CID recursive, metadata }>\n * Iterable<{ path: String recursive, metadata }>\n * AsyncIterable<CID>\n * AsyncIterable<String>\n * AsyncIterable<{ cid: CID recursive, metadata }>\n * AsyncIterable<{ path: String recursive, metadata }>\n * ```\n * Into:\n *\n * ```ts\n * AsyncIterable<{ path: CID|String, recursive:boolean, metadata }>\n * ```\n *\n * @param {Source} input\n * @returns {AsyncIterable<Pin>}\n */\n// eslint-disable-next-line complexity\nmodule.exports = async function * normaliseInput (input) {\n  // must give us something\n  if (input === null || input === undefined) {\n    throw errCode(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT')\n  }\n\n  // CID|String\n  if (CID.isCID(input)) {\n    yield toPin({ cid: input })\n    return\n  }\n\n  if (input instanceof String || typeof input === 'string') {\n    yield toPin({ path: input })\n    return\n  }\n\n  // { cid: CID recursive, metadata }\n  // @ts-ignore - it still could be iterable or async iterable\n  if (input.cid != null || input.path != null) {\n    // @ts-ignore\n    return yield toPin(input)\n  }\n\n  // Iterable<?>\n  if (input[Symbol.iterator]) {\n    const iterator = input[Symbol.iterator]()\n    const first = iterator.next()\n    if (first.done) return iterator\n\n    // Iterable<CID|String>\n    if (CID.isCID(first.value) || first.value instanceof String || typeof first.value === 'string') {\n      yield toPin({ cid: first.value })\n      for (const cid of iterator) {\n        yield toPin({ cid })\n      }\n      return\n    }\n\n    // Iterable<{ cid: CID recursive, metadata }>\n    if (first.value.cid != null || first.value.path != null) {\n      yield toPin(first.value)\n      for (const obj of iterator) {\n        yield toPin(obj)\n      }\n      return\n    }\n\n    throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n  }\n\n  // AsyncIterable<?>\n  if (input[Symbol.asyncIterator]) {\n    const iterator = input[Symbol.asyncIterator]()\n    const first = await iterator.next()\n    if (first.done) return iterator\n\n    // AsyncIterable<CID|String>\n    if (CID.isCID(first.value) || first.value instanceof String || typeof first.value === 'string') {\n      yield toPin({ cid: first.value })\n      for await (const cid of iterator) {\n        yield toPin({ cid })\n      }\n      return\n    }\n\n    // AsyncIterable<{ cid: CID|String recursive, metadata }>\n    if (first.value.cid != null || first.value.path != null) {\n      yield toPin(first.value)\n      for await (const obj of iterator) {\n        yield toPin(obj)\n      }\n      return\n    }\n\n    throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n  }\n\n  throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n}\n\n/**\n * @param {ToPinWithPath|ToPinWithCID} input\n * @returns {Pin}\n */\nfunction toPin (input) {\n  const pin = {\n    path: input.path == null ? input.cid : `${input.path}`,\n    recursive: input.recursive !== false\n  }\n\n  if (input.metadata != null) {\n    pin.metadata = input.metadata\n  }\n\n  return pin\n}\n\n/**\n * @typedef {Object} ToPinWithPath\n * @property {string | InstanceType<typeof window.String> | CID} path\n * @property {undefined} [cid]\n * @property {boolean} [recursive]\n * @property {any} [metadata]\n *\n * @typedef {Object} ToPinWithCID\n * @property {undefined} [path]\n * @property {CID} cid\n * @property {boolean} [recursive]\n * @property {any} [metadata]\n *\n * @typedef {CID|string|InstanceType<typeof window.String>|ToPinWithPath|ToPinWithPath} ToPin\n * @typedef {ToPin|Iterable<ToPin>|AsyncIterable<ToPin>} Source\n *\n * @typedef {Object} Pin\n * @property {string|CID} path\n * @property {boolean} recursive\n * @property {any} [metadata]\n */\n","'use strict'\n\nconst CID = require('cids')\nconst configure = require('../lib/configure')\nconst normaliseInput = require('ipfs-core-utils/src/pins/normalise-input')\nconst toUrlSearchParams = require('../lib/to-url-search-params')\n\nmodule.exports = configure(api => {\n  return async function * rmAll (source, options = {}) {\n    for await (const { path, recursive } of normaliseInput(source)) {\n      const searchParams = new URLSearchParams(options.searchParams)\n      searchParams.append('arg', `${path}`)\n\n      if (recursive != null) searchParams.set('recursive', String(recursive))\n\n      const res = await api.post('pin/rm', {\n        timeout: options.timeout,\n        signal: options.signal,\n        headers: options.headers,\n        searchParams: toUrlSearchParams({\n          ...options,\n          arg: `${path}`,\n          recursive\n        })\n      })\n\n      for await (const pin of res.ndjson()) {\n        if (pin.Pins) { // non-streaming response\n          yield * pin.Pins.map(cid => new CID(cid))\n          continue\n        }\n        yield new CID(pin)\n      }\n    }\n  }\n})\n","'use strict'\n\nconst { AbortController } = require('native-abort-controller')\n\nclass SubscriptionTracker {\n  constructor () {\n    this._subs = new Map()\n  }\n\n  static singleton () {\n    if (SubscriptionTracker.instance) return SubscriptionTracker.instance\n    SubscriptionTracker.instance = new SubscriptionTracker()\n    return SubscriptionTracker.instance\n  }\n\n  subscribe (topic, handler, signal) {\n    const topicSubs = this._subs.get(topic) || []\n\n    if (topicSubs.find(s => s.handler === handler)) {\n      throw new Error(`Already subscribed to ${topic} with this handler`)\n    }\n\n    // Create controller so a call to unsubscribe can cancel the request\n    const controller = new AbortController()\n\n    this._subs.set(topic, [{ handler, controller }].concat(topicSubs))\n\n    // If there is an external signal, forward the abort event\n    if (signal) {\n      signal.addEventListener('abort', () => this.unsubscribe(topic, handler))\n    }\n\n    return controller.signal\n  }\n\n  unsubscribe (topic, handler) {\n    const subs = this._subs.get(topic) || []\n    let unsubs\n\n    if (handler) {\n      this._subs.set(topic, subs.filter(s => s.handler !== handler))\n      unsubs = subs.filter(s => s.handler === handler)\n    } else {\n      this._subs.set(topic, [])\n      unsubs = subs\n    }\n\n    unsubs.forEach(s => s.controller.abort())\n  }\n}\n\nSubscriptionTracker.instance = null\n\nmodule.exports = SubscriptionTracker\n","'use strict'\n\nconst { BigNumber } = require('bignumber.js')\nconst configure = require('../lib/configure')\nconst toUrlSearchParams = require('../lib/to-url-search-params')\n\nmodule.exports = configure(api => {\n  return async (options = {}) => {\n    const res = await api.post('repo/stat', {\n      timeout: options.timeout,\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    return {\n      numObjects: new BigNumber(data.NumObjects),\n      repoSize: new BigNumber(data.RepoSize),\n      repoPath: data.RepoPath,\n      version: data.Version,\n      storageMax: new BigNumber(data.StorageMax)\n    }\n  }\n})\n","'use strict'\n\nconst configure = require('./lib/configure')\nconst toUrlSearchParams = require('./lib/to-url-search-params')\n\nmodule.exports = configure(api => {\n  return async (options = {}) => {\n    const res = await api.post('shutdown', {\n      timeout: options.timeout,\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    await res.text()\n  }\n})\n","'use strict'\n\nconst isReactNative =\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative'\n\nfunction getDefaultBase () {\n  if (isReactNative) {\n    return 'http://localhost'\n  }\n\n  return self.location.protocol + '//' + self.location.host\n}\n\nconst URL = self.URL\nconst defaultBase = getDefaultBase()\n\nclass URLWithLegacySupport {\n  constructor (url = '', base = defaultBase) {\n    this.super = new URL(url, base)\n    this.path = this.pathname + this.search\n    this.auth =\n            this.username && this.password\n              ? this.username + ':' + this.password\n              : null\n\n    this.query =\n            this.search && this.search.startsWith('?')\n              ? this.search.slice(1)\n              : null\n  }\n\n  get hash () {\n    return this.super.hash\n  }\n\n  get host () {\n    return this.super.host\n  }\n\n  get hostname () {\n    return this.super.hostname\n  }\n\n  get href () {\n    return this.super.href\n  }\n\n  get origin () {\n    return this.super.origin\n  }\n\n  get password () {\n    return this.super.password\n  }\n\n  get pathname () {\n    return this.super.pathname\n  }\n\n  get port () {\n    return this.super.port\n  }\n\n  get 
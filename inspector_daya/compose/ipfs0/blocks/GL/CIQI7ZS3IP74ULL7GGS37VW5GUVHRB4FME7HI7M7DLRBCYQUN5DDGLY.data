ow exiting early\n\n    }\n  }\n};\n\nvar makeEventObj = function makeEventObj(self, obj) {\n  self.addEventFields(self.context, obj);\n  return new Event(obj.type, obj);\n};\n\nvar forEachEventObj = function forEachEventObj(self, handler, events) {\n  if (event(events)) {\n    handler(self, events);\n    return;\n  } else if (plainObject(events)) {\n    handler(self, makeEventObj(self, events));\n    return;\n  }\n\n  var eventList = array(events) ? events : events.split(/\\s+/);\n\n  for (var i = 0; i < eventList.length; i++) {\n    var evt = eventList[i];\n\n    if (emptyString(evt)) {\n      continue;\n    }\n\n    var match = evt.match(eventRegex); // type[.namespace]\n\n    if (match) {\n      var type = match[1];\n      var namespace = match[2] ? match[2] : null;\n      var eventObj = makeEventObj(self, {\n        type: type,\n        namespace: namespace,\n        target: self.context\n      });\n      handler(self, eventObj);\n    }\n  }\n};\n\np.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {\n  forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {\n    if (fn(callback)) {\n      self.listeners.push({\n        event: event,\n        // full event string\n        callback: callback,\n        // callback to run\n        type: type,\n        // the event type (e.g. 'click')\n        namespace: namespace,\n        // the event namespace (e.g. \".foo\")\n        qualifier: qualifier,\n        // a restriction on whether to match this emitter\n        conf: conf // additional configuration\n\n      });\n    }\n  }, events, qualifier, callback, conf, confOverrides);\n  return this;\n};\n\np.one = function (events, qualifier, callback, conf) {\n  return this.on(events, qualifier, callback, conf, {\n    one: true\n  });\n};\n\np.removeListener = p.off = function (events, qualifier, callback, conf) {\n  var _this = this;\n\n  if (this.emitting !== 0) {\n    this.listeners = copyArray(this.listeners);\n  }\n\n  var listeners = this.listeners;\n\n  var _loop = function _loop(i) {\n    var listener = listeners[i];\n    forEachEvent(_this, function (self, event, type, namespace, qualifier, callback\n    /*, conf*/\n    ) {\n      if ((listener.type === type || events === '*') && (!namespace && listener.namespace !== '.*' || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {\n        listeners.splice(i, 1);\n        return false;\n      }\n    }, events, qualifier, callback, conf);\n  };\n\n  for (var i = listeners.length - 1; i >= 0; i--) {\n    _loop(i);\n  }\n\n  return this;\n};\n\np.removeAllListeners = function () {\n  return this.removeListener('*');\n};\n\np.emit = p.trigger = function (events, extraParams, manualCallback) {\n  var listeners = this.listeners;\n  var numListenersBeforeEmit = listeners.length;\n  this.emitting++;\n\n  if (!array(extraParams)) {\n    extraParams = [extraParams];\n  }\n\n  forEachEventObj(this, function (self, eventObj) {\n    if (manualCallback != null) {\n      listeners = [{\n        event: eventObj.event,\n        type: eventObj.type,\n        namespace: eventObj.namespace,\n        callback: manualCallback\n      }];\n      numListenersBeforeEmit = listeners.length;\n    }\n\n    var _loop2 = function _loop2(i) {\n      var listener = listeners[i];\n\n      if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {\n        var args = [eventObj];\n\n        if (extraParams != null) {\n          push(args, extraParams);\n        }\n\n        self.beforeEmit(self.context, listener, eventObj);\n\n        if (listener.conf && listener.conf.one) {\n          self.listeners = self.listeners.filter(function (l) {\n            return l !== listener;\n          });\n        }\n\n        var context = self.callbackContext(self.context, listener, eventObj);\n        var ret = listener.callback.apply(context, args);\n        self.afterEmit(self.context, listener, eventObj);\n\n        if (ret === false) {\n          eventObj.stopPropagation();\n          eventObj.preventDefault();\n        }\n      } // if listener matches\n\n    };\n\n    for (var i = 0; i < numListenersBeforeEmit; i++) {\n      _loop2(i);\n    } // for listener\n\n\n    if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {\n      self.parent(self.context).emit(eventObj, extraParams);\n    }\n  }, events);\n  this.emitting--;\n  return this;\n};\n\nvar emitterOptions = {\n  qualifierCompare: function qualifierCompare(selector1, selector2) {\n    if (selector1 == null || selector2 == null) {\n      return selector1 == null && selector2 == null;\n    } else {\n      return selector1.sameText(selector2);\n    }\n  },\n  eventMatches: function eventMatches(ele, listener, eventObj) {\n    var selector = listener.qualifier;\n\n    if (selector != null) {\n      return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n    }\n\n    return true;\n  },\n  addEventFields: function addEventFields(ele, evt) {\n    evt.cy = ele.cy();\n    evt.target = ele;\n  },\n  callbackContext: function callbackContext(ele, listener, eventObj) {\n    return listener.qualifier != null ? eventObj.target : ele;\n  },\n  beforeEmit: function beforeEmit(context, listener\n  /*, eventObj*/\n  ) {\n    if (listener.conf && listener.conf.once) {\n      listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);\n    }\n  },\n  bubble: function bubble() {\n    return true;\n  },\n  parent: function parent(ele) {\n    return ele.isChild() ? ele.parent() : ele.cy();\n  }\n};\n\nvar argSelector = function argSelector(arg) {\n  if (string(arg)) {\n    return new Selector(arg);\n  } else {\n    return arg;\n  }\n};\n\nvar elesfn$m = {\n  createEmitter: function createEmitter() {\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var _p = ele._private;\n\n      if (!_p.emitter) {\n        _p.emitter = new Emitter(emitterOptions, ele);\n      }\n    }\n\n    return this;\n  },\n  emitter: function emitter() {\n    return this._private.emitter;\n  },\n  on: function on(events, selector, callback) {\n    var argSel = argSelector(selector);\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().on(events, argSel, callback);\n    }\n\n    return this;\n  },\n  removeListener: function removeListener(events, selector, callback) {\n    var argSel = argSelector(selector);\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().removeListener(events, argSel, callback);\n    }\n\n    return this;\n  },\n  removeAllListeners: function removeAllListeners() {\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().removeAllListeners();\n    }\n\n    return this;\n  },\n  one: function one(events, selector, callback) {\n    var argSel = argSelector(selector);\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().one(events, argSel, callback);\n    }\n\n    return this;\n  },\n  once: function once(events, selector, callback) {\n    var argSel = argSelector(selector);\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().on(events, argSel, callback, {\n        once: true,\n        onceCollection: this\n      });\n    }\n  },\n  emit: function emit(events, extraParams) {\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().emit(events, extraParams);\n    }\n\n    return this;\n  },\n  emitAndNotify: function emitAndNotify(event, extraParams) {\n    // for internal use only\n    if (this.length === 0) {\n      return;\n    } // empty collections don't need to notify anything\n    // notify renderer\n\n\n    this.cy().notify(event, this);\n    this.emit(event, extraParams);\n    return this;\n  }\n};\ndefine$3.eventAliasesOn(elesfn$m);\n\nvar elesfn$n = {\n  nodes: function nodes(selector) {\n    return this.filter(function (ele) {\n      return ele.isNode();\n    }).filter(selector);\n  },\n  edges: function edges(selector) {\n    return this.filter(function (ele) {\n      return ele.isEdge();\n    }).filter(selector);\n  },\n  // internal helper to get nodes and edges as separate collections with single iteration over elements\n  byGroup: function byGroup() {\n    var nodes = this.spawn();\n    var edges = this.spawn();\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n\n      if (ele.isNode()) {\n        nodes.push(ele);\n      } else {\n        edges.push(ele);\n      }\n    }\n\n    return {\n      nodes: nodes,\n      edges: edges\n    };\n  },\n  filter: function filter(_filter, thisArg) {\n    if (_filter === undefined) {\n      // check this first b/c it's the most common/performant case\n      return this;\n    } else if (string(_filter) || elementOrCollection(_filter)) {\n      return new Selector(_filter).filter(this);\n    } else if (fn(_filter)) {\n      var filterEles = this.spawn();\n      var eles = this;\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);\n\n        if (include) {\n          filterEles.push(ele);\n        }\n      }\n\n      return filterEles;\n    }\n\n    return this.spawn(); // if not handled by above, give 'em an empty collection\n  },\n  not: function not(toRemove) {\n    if (!toRemove) {\n      return this;\n    } else {\n      if (string(toRemove)) {\n        toRemove = this.filter(toRemove);\n      }\n\n      var elements = this.spawn();\n\n      for (var i = 0; i < this.length; i++) {\n        var element = this[i];\n        var remove = toRemove.has(element);\n\n        if (!remove) {\n          elements.push(element);\n        }\n      }\n\n      return elements;\n    }\n  },\n  absoluteComplement: function absoluteComplement() {\n    var cy = this.cy();\n    return cy.mutableElements().not(this);\n  },\n  intersect: function intersect(other) {\n    // if a selector is specified, then filter by it instead\n    if (string(other)) {\n      var selector = other;\n      return this.filter(selector);\n    }\n\n    var elements = this.spawn();\n    var col1 = this;\n    var col2 = other;\n    var col1Smaller = this.length < other.length;\n    var colS = col1Smaller ? col1 : col2;\n    var colL = col1Smaller ? col2 : col1;\n\n    for (var i = 0; i < colS.length; i++) {\n      var ele = colS[i];\n\n      if (colL.has(ele)) {\n        elements.push(ele);\n      }\n    }\n\n    return elements;\n  },\n  xor: function xor(other) {\n    var cy = this._private.cy;\n\n    if (string(other)) {\n      other = cy.$(other);\n    }\n\n    var elements = this.spawn();\n    var col1 = this;\n    var col2 = other;\n\n    var add = function add(col, other) {\n      for (var i = 0; i < col.length; i++) {\n        var ele = col[i];\n        var id = ele._private.data.id;\n        var inOther = other.hasElementWithId(id);\n\n        if (!inOther) {\n          elements.push(ele);\n        }\n      }\n    };\n\n    add(col1, col2);\n    add(col2, col1);\n    return elements;\n  },\n  diff: function diff(other) {\n    var cy = this._private.cy;\n\n    if (string(other)) {\n      other = cy.$(other);\n    }\n\n    var left = this.spawn();\n    var right = this.spawn();\n    var both = this.spawn();\n    var col1 = this;\n    var col2 = other;\n\n    var add = function add(col, other, retEles) {\n      for (var i = 0; i < col.length; i++) {\n        var ele = col[i];\n        var id = ele._private.data.id;\n        var inOther = other.hasElementWithId(id);\n\n        if (inOther) {\n          both.merge(ele);\n        } else {\n          retEles.push(ele);\n        }\n      }\n    };\n\n    add(col1, col2, left);\n    add(col2, col1, right);\n    return {\n      left: left,\n      right: right,\n      both: both\n    };\n  },\n  add: function add(toAdd) {\n    var cy = this._private.cy;\n\n    if (!toAdd) {\n      return this;\n    }\n\n    if (string(toAdd)) {\n      var selector = toAdd;\n      toAdd = cy.mutableElements().filter(selector);\n    }\n\n    var elements = this.spawnSelf();\n\n    for (var i = 0; i < toAdd.length; i++) {\n      var ele = toAdd[i];\n      var add = !this.has(ele);\n\n      if (add) {\n        elements.push(ele);\n      }\n    }\n\n    return elements;\n  },\n  // in place merge on calling collection\n  merge: function merge(toAdd) {\n    var _p = this._private;\n    var cy = _p.cy;\n\n    if (!toAdd) {\n      return this;\n    }\n\n    if (toAdd && string(toAdd)) {\n      var selector = toAdd;\n      toAdd = cy.mutableElements().filter(selector);\n    }\n\n    var map = _p.map;\n\n    for (var i = 0; i < toAdd.length; i++) {\n      var toAddEle = toAdd[i];\n      var id = toAddEle._private.data.id;\n      var add = !map.has(id);\n\n      if (add) {\n        var index = this.length++;\n        this[index] = toAddEle;\n        map.set(id, {\n          ele: toAddEle,\n          index: index\n        });\n      }\n    }\n\n    return this; // chaining\n  },\n  unmergeAt: function unmergeAt(i) {\n    var ele = this[i];\n    var id = ele.id();\n    var _p = this._private;\n    var map = _p.map; // remove ele\n\n    this[i] = undefined;\n    map[\"delete\"](id);\n    var unmergedLastEle = i === this.length - 1; // replace empty spot with last ele in collection\n\n    if (this.length > 1 && !unmergedLastEle) {\n      var lastEleI = this.length - 1;\n      var lastEle = this[lastEleI];\n      var lastEleId = lastEle._private.data.id;\n      this[lastEleI] = undefined;\n      this[i] = lastEle;\n      map.set(lastEleId, {\n        ele: lastEle,\n        index: i\n      });\n    } // the collection is now 1 ele smaller\n\n\n    this.length--;\n    return this;\n  },\n  // remove single ele in place in calling collection\n  unmergeOne: function unmergeOne(ele) {\n    ele = ele[0];\n    var _p = this._private;\n    var id = ele._private.data.id;\n    var map = _p.map;\n    var entry = map.get(id);\n\n    if (!entry) {\n      return this; // no need to remove\n    }\n\n    var i = entry.index;\n    this.unmergeAt(i);\n    return this;\n  },\n  // remove eles in place on calling collection\n  unmerge: function unmerge(toRemove) {\n    var cy = this._private.cy;\n\n    if (!toRemove) {\n      return this;\n    }\n\n    if (toRemove && string(toRemove)) {\n      var selector = toRemove;\n      toRemove = cy.mutableElements().filter(selector);\n    }\n\n    for (var i = 0; i < toRemove.length; i++) {\n      this.unmergeOne(toRemove[i]);\n    }\n\n    return this; // chaining\n  },\n  unmergeBy: function unmergeBy(toRmFn) {\n    for (var i = this.length - 1; i >= 0; i--) {\n      var ele = this[i];\n\n      if (toRmFn(ele)) {\n        this.unmergeAt(i);\n      }\n    }\n\n    return this;\n  },\n  map: function map(mapFn, thisArg) {\n    var arr = [];\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);\n      arr.push(ret);\n    }\n\n    return arr;\n  },\n  reduce: function reduce(fn, initialValue) {\n    var val = initialValue;\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      val = fn(val, eles[i], i, eles);\n    }\n\n    return val;\n  },\n  max: function max(valFn, thisArg) {\n    var max = -Infinity;\n    var maxEle;\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);\n\n      if (val > max) {\n        max = val;\n        maxEle = ele;\n      }\n    }\n\n    return {\n      value: max,\n      ele: maxEle\n    };\n  },\n  min: function min(valFn, thisArg) {\n    var min = Infinity;\n    var minEle;\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);\n\n      if (val < min) {\n        min = val;\n        minEle = ele;\n      }\n    }\n\n    return {\n      value: min,\n      ele: minEle\n    };\n  }\n}; // aliases\n\nvar fn$5 = elesfn$n;\nfn$5['u'] = fn$5['|'] = fn$5['+'] = fn$5.union = fn$5.or = fn$5.add;\nfn$5['\\\\'] = fn$5['!'] = fn$5['-'] = fn$5.difference = fn$5.relativeComplement = fn$5.subtract = fn$5.not;\nfn$5['n'] = fn$5['&'] = fn$5['.'] = fn$5.and = fn$5.intersection = fn$5.intersect;\nfn$5['^'] = fn$5['(+)'] = fn$5['(-)'] = fn$5.symmetricDifference = fn$5.symdiff = fn$5.xor;\nfn$5.fnFilter = fn$5.filterFn = fn$5.stdFilter = fn$5.filter;\nfn$5.complement = fn$5.abscomp = fn$5.absoluteComplement;\n\nvar elesfn$o = {\n  isNode: function isNode() {\n    return this.group() === 'nodes';\n  },\n  isEdge: function isEdge() {\n    return this.group() === 'edges';\n  },\n  isLoop: function isLoop() {\n    return this.isEdge() && this.source()[0] === this.target()[0];\n  },\n  isSimple: function isSimple() {\n    return this.isEdge() && this.source()[0] !== this.target()[0];\n  },\n  group: function group() {\n    var ele = this[0];\n\n    if (ele) {\n      return ele._private.group;\n    }\n  }\n};\n\n/**\n *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),\n *  and z-index (low to high).  These styles affect how this applies:\n *\n *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the\n *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from\n *      root to leaves of the compound graph.  The last drawn is `top`.\n *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.\n *      `manual` ignores this convention and draws based on the `z-index` value setting.\n *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher\n *      `z-index` will be drawn on top of an element with a lower `z-index`.\n */\n\nvar zIndexSort = function zIndexSort(a, b) {\n  var cy = a.cy();\n  var hasCompoundNodes = cy.hasCompoundNodes();\n\n  function getDepth(ele) {\n    var style = ele.pstyle('z-compound-depth');\n\n    if (style.value === 'auto') {\n      return hasCompoundNodes ? ele.zDepth() : 0;\n    } else if (style.value === 'bottom') {\n      return -1;\n    } else if (style.value === 'top') {\n      return MAX_INT;\n    } // 'orphan'\n\n\n    return 0;\n  }\n\n  var depthDiff = getDepth(a) - getDepth(b);\n\n  if (depthDiff !== 0) {\n    return depthDiff;\n  }\n\n  function getEleDepth(ele) {\n    var style = ele.pstyle('z-index-compare');\n\n    if (style.value === 'auto') {\n      return ele.isNode() ? 1 : 0;\n    } // 'manual'\n\n\n    return 0;\n  }\n\n  var eleDiff = getEleDepth(a) - getEleDepth(b);\n\n  if (eleDiff !== 0) {\n    return eleDiff;\n  }\n\n  var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;\n\n  if (zDiff !== 0) {\n    return zDiff;\n  } // compare indices in the core (order added to graph w/ last on top)\n\n\n  return a.poolIndex() - b.poolIndex();\n};\n\nvar elesfn$p = {\n  forEach: function forEach(fn$1, thisArg) {\n    if (fn(fn$1)) {\n      var N = this.length;\n\n      for (var i = 0; i < N; i++) {\n        var ele = this[i];\n        var ret = thisArg ? fn$1.apply(thisArg, [ele, i, this]) : fn$1(ele, i, this);\n\n        if (ret === false) {\n          break;\n        } // exit each early on return false\n\n      }\n    }\n\n    return this;\n  },\n  toArray: function toArray() {\n    var array = [];\n\n    for (var i = 0; i < this.length; i++) {\n      array.push(this[i]);\n    }\n\n    return array;\n  },\n  slice: function slice(start, end) {\n    var array = [];\n    var thisSize = this.length;\n\n    if (end == null) {\n      end = thisSize;\n    }\n\n    if (start == null) {\n      start = 0;\n    }\n\n    if (start < 0) {\n      start = thisSize + start;\n    }\n\n    if (end < 0) {\n      end = thisSize + end;\n    }\n\n    for (var i = start; i >= 0 && i < end && i < thisSize; i++) {\n      array.push(this[i]);\n    }\n\n    return this.spawn(array);\n  },\n  size: function size() {\n    return this.length;\n  },\n  eq: function eq(i) {\n    return this[i] || this.spawn();\n  },\n  first: function first() {\n    return this[0] || this.spawn();\n  },\n  last: function last() {\n    return this[this.length - 1] || this.spawn();\n  },\n  empty: function empty() {\n    return this.length === 0;\n  },\n  nonempty: function nonempty() {\n    return !this.empty();\n  },\n  sort: function sort(sortFn) {\n    if (!fn(sortFn)) {\n      return this;\n    }\n\n    var sorted = this.toArray().sort(sortFn);\n    return this.spawn(sorted);\n  },\n  sortByZIndex: function sortByZIndex() {\n    return this.sort(zIndexSort);\n  },\n  zDepth: function zDepth() {\n    var ele = this[0];\n\n    if (!ele) {\n      return undefined;\n    } // let cy = ele.cy();\n\n\n    var _p = ele._private;\n    var group = _p.group;\n\n    if (group === 'nodes') {\n      var depth = _p.data.parent ? ele.parents().size() : 0;\n\n      if (!ele.isParent()) {\n        return MAX_INT - 1; // childless nodes always on top\n      }\n\n      return depth;\n    } else {\n      var src = _p.source;\n      var tgt = _p.target;\n      var srcDepth = src.zDepth();\n      var tgtDepth = tgt.zDepth();\n      return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent\n    }\n  }\n};\nelesfn$p.each = elesfn$p.forEach;\n\nvar defineSymbolIterator = function defineSymbolIterator() {\n  var typeofUndef =  \"undefined\" ;\n  var isIteratorSupported = (typeof Symbol === \"undefined\" ? \"undefined\" : _typeof(Symbol)) != typeofUndef && _typeof(Symbol.iterator) != typeofUndef; // eslint-disable-line no-undef\n\n  if (isIteratorSupported) {\n    elesfn$p[Symbol.iterator] = function () {\n      var _this = this;\n\n      // eslint-disable-line no-undef\n      var entry = {\n        value: undefined,\n        done: false\n      };\n      var i = 0;\n      var length = this.length;\n      return _defineProperty({\n        next: function next() {\n          if (i < length) {\n            entry.value = _this[i++];\n          } else {\n            entry.value = undefined;\n            entry.done = true;\n          }\n\n          return entry;\n        }\n      }, Symbol.iterator, function () {\n        // eslint-disable-line no-undef\n        return this;\n      });\n    };\n  }\n};\n\ndefineSymbolIterator();\n\nvar getLayoutDimensionOptions = defaults({\n  nodeDimensionsIncludeLabels: false\n});\nvar elesfn$q = {\n  // Calculates and returns node dimensions { x, y } based on options given\n  layoutDimensions: function layoutDimensions(options) {\n    options = getLayoutDimensionOptions(options);\n    var dims;\n\n    if (!this.takesUpSpace()) {\n      dims = {\n        w: 0,\n        h: 0\n      };\n    } else if (options.nodeDimensionsIncludeLabels) {\n      var bbDim = this.boundingBox();\n      dims = {\n        w: bbDim.w,\n        h: bbDim.h\n      };\n    } else {\n      dims = {\n        w: this.outerWidth(),\n        h: this.outerHeight()\n      };\n    } // sanitise the dimensions for external layouts (avoid division by zero)\n\n\n    if (dims.w === 0 || dims.h === 0) {\n      dims.w = dims.h = 1;\n    }\n\n    return dims;\n  },\n  // using standard layout options, apply position function (w/ or w/o animation)\n  layoutPositions: function layoutPositions(layout, options, fn) {\n    var nodes = this.nodes().filter(function (n) {\n      return !n.isParent();\n    });\n    var cy = this.cy();\n    var layoutEles = options.eles; // nodes & edges\n\n    var getMemoizeKey = function getMemoizeKey(node) {\n      return node.id();\n    };\n\n    var fnMem = memoize(fn, getMemoizeKey); // memoized version of position function\n\n    layout.emit({\n      type: 'layoutstart',\n      layout: layout\n    });\n    layout.animations = [];\n\n    var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {\n      var center = {\n        x: nodesBb.x1 + nodesBb.w / 2,\n        y: nodesBb.y1 + nodesBb.h / 2\n      };\n      var spacingVector = {\n        // scale from center of bounding box (not necessarily 0,0)\n        x: (pos.x - center.x) * spacing,\n        y: (pos.y - center.y) * spacing\n      };\n      return {\n        x: center.x + spacingVector.x,\n        y: center.y + spacingVector.y\n      };\n    };\n\n    var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;\n\n    var spacingBb = function spacingBb() {\n      if (!useSpacingFactor) {\n        return null;\n      }\n\n      var bb = makeBoundingBox();\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var pos = fnMem(node, i);\n        expandBoundingBoxByPoint(bb, pos.x, pos.y);\n      }\n\n      return bb;\n    };\n\n    var bb = spacingBb();\n    var getFinalPos = memoize(function (node, i) {\n      var newPos = fnMem(node, i);\n\n      if (useSpacingFactor) {\n        var spacing = Math.abs(options.spacingFactor);\n        newPos = calculateSpacing(spacing, bb, newPos);\n      }\n\n      if (options.transform != null) {\n        newPos = options.transform(node, newPos);\n      }\n\n      return newPos;\n    }, getMemoizeKey);\n\n    if (options.animate) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var newPos = getFinalPos(node, i);\n        var animateNode = options.animateFilter == null || options.animateFilter(node, i);\n\n        if (animateNode) {\n          var ani = node.animation({\n            position: newPos,\n            duration: options.animationDuration,\n            easing: options.animationEasing\n          });\n          layout.animations.push(ani);\n        } else {\n          node.position(newPos);\n        }\n      }\n\n      if (options.fit) {\n        var fitAni = cy.animation({\n          fit: {\n            boundingBox: layoutEles.boundingBoxAt(getFinalPos),\n            padding: options.padding\n          },\n          duration: options.animationDuration,\n          easing: options.animationEasing\n        });\n        layout.animations.push(fitAni);\n      } else if (options.zoom !== undefined && options.pan !== undefined) {\n        var zoomPanAni = cy.animation({\n          zoom: options.zoom,\n          pan: options.pan,\n          duration: options.animationDuration,\n          easing: options.animationEasing\n        });\n        layout.animations.push(zoomPanAni);\n      }\n\n      layout.animations.forEach(function (ani) {\n        return ani.play();\n      });\n      layout.one('layoutready', options.ready);\n      layout.emit({\n        type: 'layoutready',\n        layout: layout\n      });\n      Promise$1.all(layout.animations.map(function (ani) {\n        return ani.promise();\n      })).then(function () {\n        layout.one('layoutstop', options.stop);\n        layout.emit({\n          type: 'layoutstop',\n          layout: layout\n        });\n      });\n    } else {\n      nodes.positions(getFinalPos);\n\n      if (options.fit) {\n        cy.fit(options.eles, options.padding);\n      }\n\n      if (options.zoom != null) {\n        cy.zoom(options.zoom);\n      }\n\n      if (options.pan) {\n        cy.pan(options.pan);\n      }\n\n      layout.one('layoutready', options.ready);\n      layout.emit({\n        type: 'layoutready',\n        layout: layout\n      });\n      layout.one('layoutstop', options.stop);\n      layout.emit({\n        type: 'layoutstop',\n        layout: layout\n      });\n    }\n\n    return this; // chaining\n  },\n  layout: function layout(options) {\n    var cy = this.cy();\n    return cy.makeLayout(extend({}, options, {\n      eles: this\n    }));\n  }\n}; // aliases:\n\nelesfn$q.createLayout = elesfn$q.makeLayout = elesfn$q.layout;\n\nfunction styleCache(key, fn, ele) {\n  var _p = ele._private;\n  var cache = _p.styleCache = _p.styleCache || [];\n  var val;\n\n  if ((val = cache[key]) != null) {\n    return val;\n  } else {\n    val = cache[key] = fn(ele);\n    return val;\n  }\n}\n\nfunction cacheStyleFunction(key, fn) {\n  key = hashString(key);\n  return function cachedStyleFunction(ele) {\n    return styleCache(key, fn, ele);\n  };\n}\n\nfunction cachePrototypeStyleFunction(key, fn) {\n  key = hashString(key);\n\n  var selfFn = function selfFn(ele) {\n    return fn.call(ele);\n  };\n\n  return function cachedPrototypeStyleFunction() {\n    var ele = this[0];\n\n    if (ele) {\n      return styleCache(key, selfFn, ele);\n    }\n  };\n}\n\nvar elesfn$r = {\n  recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {\n    var cy = this.cy();\n    var renderer = cy.renderer();\n    var styleEnabled = cy.styleEnabled();\n\n    if (renderer && styleEnabled) {\n      renderer.recalculateRenderedStyle(this, useCache);\n    }\n\n    return this;\n  },\n  dirtyStyleCache: function dirtyStyleCache() {\n    var cy = this.cy();\n\n    var dirty = function dirty(ele) {\n      return ele._private.styleCache = null;\n    };\n\n    if (cy.hasCompoundNodes()) {\n      var eles;\n      eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n      eles.merge(eles.connectedEdges());\n      eles.forEach(dirty);\n    } else {\n      this.forEach(function (ele) {\n        dirty(ele);\n        ele.connectedEdges().forEach(dirty);\n      });\n    }\n\n    return this;\n  },\n  // fully updates (recalculates) the style for the elements\n  updateStyle: function updateStyle(notifyRenderer) {\n    var cy = this._private.cy;\n\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n\n    if (cy.batching()) {\n      var bEles = cy._private.batchStyleEles;\n      bEles.merge(this);\n      return this; // chaining and exit early when batching\n    }\n\n    var hasCompounds = cy.hasCompoundNodes();\n    var updatedEles = this;\n    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\n    if (hasCompounds) {\n      // then add everything up and down for compound selector checks\n      updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n    } // let changedEles = style.apply( updatedEles );\n\n\n    var changedEles = updatedEles;\n\n    if (notifyRenderer) {\n      changedEles.emitAndNotify('style'); // let renderer know we changed style\n    } else {\n      changedEles.emit('style'); // just fire the event\n    }\n\n    updatedEles.forEach(function (ele) {\n      return ele._private.styleDirty = true;\n    });\n    return this; // chaining\n  },\n  // private: clears dirty flag and recalculates style\n  cleanStyle: function cleanStyle() {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return;\n    }\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n\n      if (ele._private.styleDirty) {\n        // n.b. this flag should be set before apply() to avoid potential infinite recursion\n        ele._private.styleDirty = false;\n        cy.style().apply(ele);\n      }\n    }\n  },\n  // get the internal parsed style object for the specified property\n  parsedStyle: function parsedStyle(property) {\n    var includeNonDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var ele = this[0];\n    var cy = ele.cy();\n\n    if (!cy.styleEnabled()) {\n      return;\n    }\n\n    if (ele) {\n      this.cleanStyle();\n      var overriddenStyle = ele._private.style[property];\n\n      if (overriddenStyle != null) {\n        return overriddenStyle;\n      } else if (includeNonDefault) {\n        return cy.style().getDefaultProperty(property);\n      } else {\n        return null;\n      }\n    }\n  },\n  numericStyle: function numericStyle(property) {\n    var ele = this[0];\n\n    if (!ele.cy().styleEnabled()) {\n      return;\n    }\n\n    if (ele) {\n      var pstyle = ele.pstyle(property);\n      return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;\n    }\n  },\n  numericStyleUnits: function numericStyleUnits(property) {\n    var ele = this[0];\n\n    if (!ele.cy().styleEnabled()) {\n      return;\n    }\n\n    if (ele) {\n      return ele.pstyle(property).units;\n    }\n  },\n  // get the specified css property as a rendered value (i.e. on-screen value)\n  // or get the whole rendered style if no property specified (NB doesn't allow setting)\n  renderedStyle: function renderedStyle(property) {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n\n    var ele = this[0];\n\n    if (ele) {\n      return cy.style().getRenderedStyle(ele, property);\n    }\n  },\n  // read the calculated css style of the element or override the style (via a bypass)\n  style: function style(name, value) {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n\n    var updateTransitions = false;\n    var style = cy.style();\n\n    if (plainObject(name)) {\n      // then extend the bypass\n      var props = name;\n      style.applyBypass(this, props, updateTransitions);\n      this.emitAndNotify('style'); // let the renderer know we've updated style\n    } else if (string(name)) {\n      if (value === undefined) {\n        // then get the property from the style\n        var ele = this[0];\n\n        if (ele) {\n          return style.getStylePropertyValue(ele, name);\n        } else {\n          // empty collection => can't get any value\n          return;\n        }\n      } else {\n        // then set the bypass with the property value\n        style.applyBypass(this, name, value, updateTransitions);\n        this.emitAndNotify('style'); // let the renderer know we've updated style\n      }\n    } else if (name === undefined) {\n      var _ele = this[0];\n\n      if (_ele) {\n        return style.getRawStyle(_ele);\n      } else {\n        // empty collection => can't get any value\n        return;\n      }\n    }\n\n    return this; // chaining\n  },\n  removeStyle: function removeStyle(names) {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n\n    var updateTransitions = false;\n    var style = cy.style();\n    var eles = this;\n\n    if (names === undefined) {\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        style.removeAllBypasses(ele, updateTransitions);\n      }\n    } else {\n      names = names.split(/\\s+/);\n\n      for (var _i = 0; _i < eles.length; _i++) {\n        var _ele2 = eles[_i];\n        style.removeBypasses(_ele2, names, updateTransitions);\n      }\n    }\n\n    this.emitAndNotify('style'); // let the renderer know we've updated style\n\n    return this; // chaining\n  },\n  show: function show() {\n    this.css('display', 'element');\n    return this; // chaining\n  },\n  hide: function hide() {\n    this.css('display', 'none');\n    return this; // chaining\n  },\n  effectiveOpacity: function effectiveOpacity() {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return 1;\n    }\n\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var ele = this[0];\n\n    if (ele) {\n      var _p = ele._private;\n      var parentOpacity = ele.pstyle('opacity').value;\n\n      if (!hasCompoundNodes) {\n        return parentOpacity;\n      }\n\n      var parents = !_p.data.parent ? null : ele.parents();\n\n      if (parents) {\n        for (var i = 0; i < parents.length; i++) {\n          var parent = parents[i];\n          var opacity = parent.pstyle('opacity').value;\n          parentOpacity = opacity * parentOpacity;\n        }\n      }\n\n      return parentOpacity;\n    }\n  },\n  transparent: function transparent() {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return false;\n    }\n\n    var ele = this[0];\n    var hasCompoundNodes = ele.cy().hasCompoundNodes();\n\n    if (ele) {\n      if (!hasCompoundNodes) {\n        return ele.pstyle('opacity').value === 0;\n      } else {\n        return ele.effectiveOpacity() === 0;\n      }\n    }\n  },\n  backgrounding: function backgrounding() {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return false;\n    }\n\n    var ele = this[0];\n    return ele._private.backgrounding ? true : false;\n  }\n};\n\nfunction checkCompound(ele, parentOk) {\n  var _p = ele._private;\n  var parents = _p.data.parent ? ele.parents() : null;\n\n  if (parents) {\n    for (var i = 0; i < parents.length; i++) {\n      var parent = parents[i];\n\n      if (!parentOk(parent)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction defineDerivedStateFunction(specs) {\n  var ok = specs.ok;\n  var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;\n  var parentOk = specs.parentOk || specs.ok;\n  return function () {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return true;\n    }\n\n    var ele = this[0];\n    var hasCompoundNodes = cy.hasCompoundNodes();\n\n    if (ele) {\n      var _p = ele._private;\n\n      if (!ok(ele)) {\n        return false;\n      }\n\n      if (ele.isNode()) {\n        return !hasCompoundNodes || checkCompound(ele, parentOk);\n      } else {\n        var src = _p.source;\n        var tgt = _p.target;\n        return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));\n      }\n    }\n  };\n}\n\nvar eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {\n  return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);\n});\nelesfn$r.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({\n  ok: eleTakesUpSpace\n}));\nvar eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {\n  return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);\n});\nvar parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {\n  return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);\n});\nelesfn$r.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({\n  ok: eleInteractive,\n  parentOk: parentInteractive,\n  edgeOkViaNode: eleTakesUpSpace\n}));\n\nelesfn$r.noninteractive = function () {\n  var ele = this[0];\n\n  if (ele) {\n    return !ele.interactive();\n  }\n};\n\nvar eleVisible = cacheStyleFunction('eleVisible', function (ele) {\n  return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);\n});\nvar edgeVisibleViaNode = eleTakesUpSpace;\nelesfn$r.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({\n  ok: eleVisible,\n  edgeOkViaNode: edgeVisibleViaNode\n}));\n\nelesfn$r.hidden = function () {\n  var ele = this[0];\n\n  if (ele) {\n    return !ele.visible();\n  }\n};\n\nelesfn$r.isBundledBezier = cachePrototypeStyleFunction('isBundledBezier', function () {\n  if (!this.cy().styleEnabled()) {\n    return false;\n  }\n\n  return !this.removed() && this.pstyle('curve-style').value === 'bezier' && this.takesUpSpace();\n});\nelesfn$r.bypass = elesfn$r.css = elesfn$r.style;\nelesfn$r.renderedCss = elesfn$r.renderedStyle;\nelesfn$r.removeBypass = elesfn$r.removeCss = elesfn$r.removeStyle;\nelesfn$r.pstyle = elesfn$r.parsedStyle;\n\nvar elesfn$s = {};\n\nfunction defineSwitchFunction(params) {\n  return function () {\n    var args = arguments;\n    var changedEles = []; // e.g. cy.nodes().select( data, handler )\n\n    if (args.length === 2) {\n      var data = args[0];\n      var handler = args[1];\n      this.on(params.event, data, handler);\n    } // e.g. cy.nodes().select( handler )\n    else if (args.length === 1 && fn(args[0])) {\n        var _handler = args[0];\n        this.on(params.event, _handler);\n      } // e.g. cy.nodes().select()\n      // e.g. (private) cy.nodes().select(['tapselect'])\n      else if (args.length === 0 || args.length === 1 && array(args[0])) {\n          var addlEvents = args.length === 1 ? args[0] : null;\n\n          for (var i = 0; i < this.length; i++) {\n            var ele = this[i];\n            var able = !params.ableField || ele._private[params.ableField];\n            var changed = ele._private[params.field] != params.value;\n\n            if (params.overrideAble) {\n              var overrideAble = params.overrideAble(ele);\n\n              if (overrideAble !== undefined) {\n                able = overrideAble;\n\n                if (!overrideAble) {\n                  return this;\n                } // to save cycles assume not able for all on override\n\n              }\n            }\n\n            if (able) {\n              ele._private[params.field] = params.value;\n\n              if (changed) {\n                changedEles.push(ele);\n              }\n            }\n          }\n\n          var changedColl = this.spawn(changedEles);\n          changedColl.updateStyle(); // change of state => possible change of style\n\n          changedColl.emit(params.event);\n\n          if (addlEvents) {\n            changedColl.emit(addlEvents);\n          }\n        }\n\n    return this;\n  };\n}\n\nfunction defineSwitchSet(params) {\n  elesfn$s[params.field] = function () {\n    var ele = this[0];\n\n    if (ele) {\n      if (params.overrideField) {\n        var val = params.overrideField(ele);\n\n        if (val !== undefined) {\n          return val;\n        }\n      }\n\n      return ele._private[params.field];\n    }\n  };\n\n  elesfn$s[params.on] = defineSwitchFunction({\n    event: params.on,\n    field: params.field,\n    ableField: params.ableField,\n    overrideAble: params.overrideAble,\n    value: true\n  });\n  elesfn$s[params.off] = defineSwitchFunction({\n    event: params.off,\n    field: params.field,\n    ableField: params.ableField,\n    overrideAble: params.overrideAble,\n    value: false\n  });\n}\n\ndefineSwitchSet({\n  field: 'locked',\n  overrideField: function overrideField(ele) {\n    return ele.cy().autolock() ? true : undefined;\n  },\n  on: 'lock',\n  off: 'unlock'\n});\ndefineSwitchSet({\n  field: 'grabbable',\n  overrideField: function overrideField(ele) {\n    return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;\n  },\n  on: 'grabify',\n  off: 'ungrabify'\n});\ndefineSwitchSet({\n  field: 'selected',\n  ableField: 'selectable',\n  overrideAble: function overrideAble(ele) {\n    return ele.cy().autounselectify() ? false : undefined;\n  },\n  on: 'select',\n  off: 'unselect'\n});\ndefineSwitchSet({\n  field: 'selectable',\n  overrideField: function overrideField(ele) {\n    return ele.cy().autounselectify() ? false : undefined;\n  },\n  on: 'selectify',\n  off: 'unselectify'\n});\nelesfn$s.deselect = elesfn$s.unselect;\n\nelesfn$s.grabbed = function () {\n  var ele = this[0];\n\n  if (ele) {\n    return ele._private.grabbed;\n  }\n};\n\ndefineSwitchSet({\n  field: 'active',\n  on: 'activate',\n  off: 'unactivate'\n});\ndefineSwitchSet({\n  field: 'pannable',\n  on: 'panify',\n  off: 'unpanify'\n});\n\nelesfn$s.inactive = function () {\n  var ele = this[0];\n\n  if (ele) {\n    return !ele._private.active;\n  }\n};\n\nvar elesfn$t = {}; // DAG functions\n////////////////\n\nvar defineDagExtremity = function defineDagExtremity(params) {\n  return function dagExtremityImpl(selector) {\n    var eles = this;\n    var ret = [];\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n\n      if (!ele.isNode()) {\n        continue;\n      }\n\n      var disqualified = false;\n      var edges = ele.connectedEdges();\n\n      for (var j = 0; j < edges.length; j++) {\n        var edge = edges[j];\n        var src = edge.source();\n        var tgt = edge.target();\n\n        if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {\n          disqualified = true;\n          break;\n        }\n      }\n\n      if (!disqualified) {\n        ret.push(ele);\n      }\n    }\n\n    return this.spawn(ret, true).filter(selector);\n  };\n};\n\nvar defineDagOneHop = function defineDagOneHop(params) {\n  return function (selector) {\n    var eles = this;\n    var oEles = [];\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n\n      if (!ele.isNode()) {\n        continue;\n      }\n\n      var edges = ele.connectedEdges();\n\n      for (var j = 0; j < edges.length; j++) {\n        var edge = edges[j];\n        var src = edge.source();\n        var tgt = edge.target();\n\n        if (params.outgoing && src === ele) {\n          oEles.push(edge);\n          oEles.push(tgt);\n        } else if (params.incoming && tgt === ele) {\n          oEles.push(edge);\n          oEles.push(src);\n        }\n      }\n    }\n\n    return this.spawn(oEles, true).filter(selector);\n  };\n};\n\nvar defineDagAllHops = function defineDagAllHops(params) {\n  return function (selector) {\n    var eles = this;\n    var sEles = [];\n    var sElesIds = {};\n\n    for (;;) {\n      var next = params.outgoing ? eles.outgoers() : eles.incomers();\n\n      if (next.length === 0) {\n        break;\n      } // done if none left\n\n\n      var newNext = false;\n\n      for (var i = 0; i < next.length; i++) {\n        var n = next[i];\n        var nid = n.id();\n\n        if (!sElesIds[nid]) {\n          sElesIds[nid] = true;\n          sEles.push(n);\n          newNext = true;\n        }\n      }\n\n      if (!newNext) {\n        break;\n      } // done if touched all outgoers already\n\n\n      eles = next;\n    }\n\n    return this.spawn(sEles, true).filter(selector);\n  };\n};\n\nelesfn$t.clearTraversalCache = function () {\n  for (var i = 0; i < this.length; i++) {\n    this[i]._private.traversalCache = null;\n  }\n};\n\nextend(elesfn$t, {\n  // get the root nodes in the DAG\n  roots: defineDagExtremity({\n    noIncomingEdges: true\n  }),\n  // get the leaf nodes in the DAG\n  leaves: defineDagExtremity({\n    noOutgoingEdges: true\n  }),\n  // normally called children in graph theory\n  // these nodes =edges=> outgoing nodes\n  outgoers: cache(defineDagOneHop({\n    outgoing: true\n  }), 'outgoers'),\n  // aka DAG descendants\n  successors: defineDagAllHops({\n    outgoing: true\n  }),\n  // normally called parents in graph theory\n  // these nodes <=edges= incoming nodes\n  incomers: cache(defineDagOneHop({\n    incoming: true\n  }), 'incomers'),\n  // aka DAG ancestors\n  predecessors: defineDagAllHops({\n    incoming: true\n  })\n}); // Neighbourhood functions\n//////////////////////////\n\nextend(elesfn$t, {\n  neighborhood: cache(function (selector) {\n    var elements = [];\n    var nodes = this.nodes();\n\n    for (var i = 0; i < nodes.length; i++) {\n      // for all nodes\n      var node = nodes[i];\n      var connectedEdges = node.connectedEdges(); // for each connected edge, add the edge and the other node\n\n      for (var j = 0; j < connectedEdges.length; j++) {\n        var edge = connectedEdges[j];\n        var src = edge.source();\n        var tgt = edge.target();\n        var otherNode = node === src ? tgt : src; // need check in case of loop\n\n        if (otherNode.length > 0) {\n          elements.push(otherNode[0]); // add node 1 hop away\n        } // add connected edge\n\n\n        elements.push(edge[0]);\n      }\n    }\n\n    return this.spawn(elements, true).filter(selector);\n  }, 'neighborhood'),\n  closedNeighborhood: function closedNeighborhood(selector) {\n    return this.neighborhood().add(this).filter(selector);\n  },\n  openNeighborhood: function openNeighborhood(selector) {\n    return this.neighborhood(selector);\n  }\n}); // aliases\n\nelesfn$t.neighbourhood = elesfn$t.neighborhood;\nelesfn$t.closedNeighbourhood = elesfn$t.closedNeighborhood;\nelesfn$t.openNeighbourhood = elesfn$t.openNeighborhood; // Edge functions\n/////////////////\n\nextend(elesfn$t, {\n  source: cache(function sourceImpl(selector) {\n    var ele = this[0];\n    var src;\n\n    if (ele) {\n      src = ele._private.source || ele.cy().collection();\n    }\n\n    return src && selector ? src.filter(selector) : src;\n  }, 'source'),\n  target: cache(function targetImpl(selector) {\n    var ele = this[0];\n    var tgt;\n\n    if (ele) {\n      tgt = ele._private.target || ele.cy().collection();\n    }\n\n    return tgt && selector ? tgt.filter(selector) : tgt;\n  }, 'target'),\n  sources: defineSourceFunction({\n    attr: 'source'\n  }),\n  targets: defineSourceFunction({\n    attr: 'target'\n  })\n});\n\nfunction defineSourceFunction(params) {\n  return function sourceImpl(selector) {\n    var sources = [];\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var src = ele._private[params.attr];\n\n      if (src) {\n        sources.push(src);\n      }\n    }\n\n    return this.spawn(sources, true).filter(selector);\n  };\n}\n\nextend(elesfn$t, {\n  edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),\n  edgesTo: cache(defineEdgesWithFunction({\n    thisIsSrc: true\n  }), 'edgesTo')\n});\n\nfunction defineEdgesWithFunction(params) {\n  return function edgesWithImpl(otherNodes) {\n    var elements = [];\n    var cy = this._private.cy;\n    var p = params || {}; // get elements if a selector is specified\n\n    if (string(otherNodes)) {\n      otherNodes = cy.$(otherNodes);\n    }\n\n    for (var h = 0; h < otherNodes.length; h++) {\n      var edges = otherNodes[h]._private.edges;\n\n      for (var i = 0; i < edges.length; i++) {\n        var edge = edges[i];\n        var edgeData = edge._private.data;\n        var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);\n        var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);\n        var edgeConnectsThisAndOther = thisToOther || otherToThis;\n\n        if (!edgeConnectsThisAndOther) {\n          continue;\n        }\n\n        if (p.thisIsSrc || p.thisIsTgt) {\n          if (p.thisIsSrc && !thisToOther) {\n            continue;\n          }\n\n          if (p.thisIsTgt && !otherToThis) {\n            continue;\n          }\n        }\n\n        elements.push(edge);\n      }\n    }\n\n    return this.spawn(elements, true);\n  };\n}\n\nextend(elesfn$t, {\n  connectedEdges: cache(function (selector) {\n    var retEles = [];\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var node = eles[i];\n\n      if (!node.isNode()) {\n        continue;\n      }\n\n      var edges = node._private.edges;\n\n      for (var j = 0; j < edges.length; j++) {\n        var edge = edges[j];\n        retEles.push(edge);\n      }\n    }\n\n    return this.spawn(retEles, true).filter(selector);\n  }, 'connectedEdges'),\n  connectedNodes: cache(function (selector) {\n    var retEles = [];\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var edge = eles[i];\n\n      if (!edge.isEdge()) {\n        continue;\n      }\n\n      retEles.push(edge.source()[0]);\n      retEles.push(edge.target()[0]);\n    }\n\n    return this.spawn(retEles, true).filter(selector);\n  }, 'connectedNodes'),\n  parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),\n  codirectedEdges: cache(defineParallelEdgesFunction({\n    codirected: true\n  }), 'codirectedEdges')\n});\n\nfunction defineParallelEdgesFunction(params) {\n  var defaults = {\n    codirected: false\n  };\n  params = extend({}, defaults, params);\n  return function parallelEdgesImpl(selector) {\n    // micro-optimised for renderer\n    var elements = [];\n    var edges = this.edges();\n    var p = params; // look at all the edges in the collection\n\n    for (var i = 0; i < edges.length; i++) {\n      var edge1 = edges[i];\n      var edge1_p = edge1._private;\n      var src1 = edge1_p.source;\n      var srcid1 = src1._private.data.id;\n      var tgtid1 = edge1_p.data.target;\n      var srcEdges1 = src1._private.edges; // look at edges connected to the src node of this edge\n\n      for (var j = 0; j < srcEdges1.length; j++) {\n        var edge2 = srcEdges1[j];\n        var edge2data = edge2._private.data;\n        var tgtid2 = edge2data.target;\n        var srcid2 = edge2data.source;\n        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;\n        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;\n\n        if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {\n          elements.push(edge2);\n        }\n      }\n    }\n\n    return this.spawn(elements, true).filter(selector);\n  };\n} // Misc functions\n/////////////////\n\n\nextend(elesfn$t, {\n  components: function components(root) {\n    var self = this;\n    var cy = self.cy();\n    var visited = cy.collection();\n    var unvisited = root == null ? self.nodes() : root.nodes();\n    var components = [];\n\n    if (root != null && unvisited.empty()) {\n      // root may contain only edges\n      unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides\n    }\n\n    var visitInComponent = function visitInComponent(node, component) {\n      visited.merge(node);\n      unvisited.unmerge(node);\n      component.merge(node);\n    };\n\n    if (unvisited.empty()) {\n      return self.spawn();\n    }\n\n    var _loop = function _loop() {\n      // each iteration yields a component\n      var cmpt = cy.collection();\n      components.push(cmpt);\n      var root = unvisited[0];\n      visitInComponent(root, cmpt);\n      self.bfs({\n        directed: false,\n        roots: root,\n        visit: function visit(v) {\n          return visitInComponent(v, cmpt);\n        }\n      });\n      cmpt.forEach(function (node) {\n        node.connectedEdges().forEach(function (e) {\n          // connectedEdges() usually cached\n          if (self.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) {\n            // has() is cheap\n            cmpt.merge(e); // forEach() only considers nodes -- sets N at call time\n          }\n        });\n      });\n    };\n\n    do {\n      _loop();\n    } while (unvisited.length > 0);\n\n    return components;\n  },\n  component: function component() {\n    var ele = this[0];\n    return ele.cy().mutableElements().components(ele)[0];\n  }\n});\nelesfn$t.componentsOf = elesfn$t.components;\n\nvar Collection = function Collection(cy, elements) {\n  var unique = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (cy === undefined) {\n    error('A collection must have a reference to the core');\n    return;\n  }\n\n  var map = new Map$1();\n  var createdElements = false;\n\n  if (!elements) {\n    elements = [];\n  } else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {\n    createdElements = true; // make elements from json and restore all at once later\n\n    var eles = [];\n    var elesIds = new Set$1();\n\n    for (var i = 0, l = elements.length; i < l; i++) {\n      var json = elements[i];\n\n      if (json.data == null) {\n        json.data = {};\n      }\n\n      var _data = json.data; // make sure newly created elements have valid ids\n\n      if (_data.id == null) {\n        _data.id = uuid();\n      } else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {\n        continue; // can't create element if prior id already exists\n      }\n\n      var ele = new Element(cy, json, false);\n      eles.push(ele);\n      elesIds.add(_data.id);\n    }\n\n    elements = eles;\n  }\n\n  this.length = 0;\n\n  for (var _i = 0, _l = elements.length; _i < _l; _i++) {\n    var element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements\n\n    if (element$1 == null) {\n      continue;\n    }\n\n    var id = element$1._private.data.id;\n\n    if (!unique || !map.has(id)) {\n      if (unique) {\n        map.set(id, {\n          index: this.length,\n          ele: element$1\n        });\n      }\n\n      this[this.length] = element$1;\n      this.length++;\n    }\n  }\n\n  this._private = {\n    eles: this,\n    cy: cy,\n\n    get map() {\n      if (this.lazyMap == null) {\n        this.rebuildMap();\n      }\n\n      return this.lazyMap;\n    },\n\n    set map(m) {\n      this.lazyMap = m;\n    },\n\n    rebuildMap: function rebuildMap() {\n      var m = this.lazyMap = new Map$1();\n      var eles = this.eles;\n\n      for (var _i2 = 0; _i2 < eles.length; _i2++) {\n        var _ele = eles[_i2];\n        m.set(_ele.id(), {\n          index: _i2,\n          ele: _ele\n        });\n      }\n    }\n  };\n\n  if (unique) {\n    this._private.map = map;\n  } // restore the elements if we created them from json\n\n\n  if (createdElements) {\n    this.restore();\n  }\n}; // Functions\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// keep the prototypes in sync (an element has the same functions as a collection)\n// and use elefn and elesfn as shorthands to the prototypes\n\n\nvar elesfn$u = Element.prototype = Collection.prototype = Object.create(Array.prototype);\n\nelesfn$u.instanceString = function () {\n  return 'collection';\n};\n\nelesfn$u.spawn = function (eles, unique) {\n  return new Collection(this.cy(), eles, unique);\n};\n\nelesfn$u.spawnSelf = function () {\n  return this.spawn(this);\n};\n\nelesfn$u.cy = function () {\n  return this._private.cy;\n};\n\nelesfn$u.renderer = function () {\n  return this._private.cy.renderer();\n};\n\nelesfn$u.element = function () {\n  return this[0];\n};\n\nelesfn$u.collection = function () {\n  if (collection(this)) {\n    return this;\n  } else {\n    // an element\n    return new Collection(this._private.cy, [this]);\n  }\n};\n\nelesfn$u.unique = function () {\n  return new Collection(this._private.cy, this, true);\n};\n\nelesfn$u.hasElementWithId = function (id) {\n  id = '' + id; // id must be string\n\n  return this._private.map.has(id);\n};\n\nelesfn$u.getElementById = function (id) {\n  id = '' + id; // id must be string\n\n  var cy = this._private.cy;\n\n  var entry = this._private.map.get(id);\n\n  return entry ? entry.ele : new Collection(cy); // get ele or empty collection\n};\n\nelesfn$u.$id = elesfn$u.getElementById;\n\nelesfn$u.poolIndex = function () {\n  var cy = this._private.cy;\n  var eles = cy._private.elements;\n  var id = this[0]._private.data.id;\n  return eles._private.map.get(id).index;\n};\n\nelesfn$u.indexOf = function (ele) {\n  var id = ele[0]._private.data.id;\n  return this._private.map.get(id).index;\n};\n\nelesfn$u.indexOfId = function (id) {\n  id = '' + id; // id must be string\n\n  return this._private.map.get(id).index;\n};\n\nelesfn$u.json = function (obj) {\n  var ele = this.element();\n  var cy = this.cy();\n\n  if (ele == null && obj) {\n    return this;\n  } // can't set to no eles\n\n\n  if (ele == null) {\n    return undefined;\n  } // can't get from no eles\n\n\n  var p = ele._private;\n\n  if (plainObject(obj)) {\n    // set\n    cy.startBatch();\n\n    if (obj.data) {\n      ele.data(obj.data);\n      var _data2 = p.data;\n\n      if (ele.isEdge()) {\n        // source and target are immutable via data()\n        var move = false;\n        var spec = {};\n        var src = obj.data.source;\n        var tgt = obj.data.target;\n\n        if (src != null && src != _data2.source) {\n          spec.source = '' + src; // id must be string\n\n          move = true;\n        }\n\n        if (tgt != null && tgt != _data2.target) {\n          spec.target = '' + tgt; // id must be string\n\n          move = true;\n        }\n\n        if (move) {\n          ele = ele.move(spec);\n        }\n      } else {\n        // parent is immutable via data()\n        var newParentValSpecd = 'parent' in obj.data;\n        var parent = obj.data.parent;\n\n        if (newParentValSpecd && (parent != null || _data2.parent != null) && parent != _data2.parent) {\n          if (parent === undefined) {\n            // can't set undefined imperatively, so use null\n            parent = null;\n          }\n\n          if (parent != null) {\n            parent = '' + parent; // id must be string\n          }\n\n          ele = ele.move({\n            parent: parent\n          });\n        }\n      }\n    }\n\n    if (obj.position) {\n      ele.position(obj.position);\n    } // ignore group -- immutable\n\n\n    var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {\n      var obj_k = obj[k];\n\n      if (obj_k != null && obj_k !== p[k]) {\n        if (obj_k) {\n          ele[trueFnName]();\n        } else {\n          ele[falseFnName]();\n        }\n      }\n    };\n\n    checkSwitch('removed', 'remove', 'restore');\n    checkSwitch('selected', 'select', 'unselect');\n    checkSwitch('selectable', 'selectify', 'unselectify');\n    checkSwitch('locked', 'lock', 'unlock');\n    checkSwitch('grabbable', 'grabify', 'ungrabify');\n    checkSwitch('pannable', 'panify', 'unpanify');\n\n    if (obj.classes != null) {\n      ele.classes(obj.classes);\n    }\n\n    cy.endBatch();\n    return this;\n  } else if (obj === undefined) {\n    // get\n    var json = {\n      data: copy(p.data),\n      position: copy(p.position),\n      group: p.group,\n      removed: p.removed,\n      selected: p.selected,\n      selectable: p.selectable,\n      locked: p.locked,\n      grabbable: p.grabbable,\n      pannable: p.pannable,\n      classes: null\n    };\n    json.classes = '';\n    var i = 0;\n    p.classes.forEach(function (cls) {\n      return json.classes += i++ === 0 ? cls : ' ' + cls;\n    });\n    return json;\n  }\n};\n\nelesfn$u.jsons = function () {\n  var jsons = [];\n\n  for (var i = 0; i < this.length; i++) {\n    var ele = this[i];\n    var json = ele.json();\n    jsons.push(json);\n  }\n\n  return jsons;\n};\n\nelesfn$u.clone = function () {\n  var cy = this.cy();\n  var elesArr = [];\n\n  for (var i = 0; i < this.length; i++) {\n    var ele = this[i];\n    var json = ele.json();\n    var clone = new Element(cy, json, false); // NB no restore\n\n    elesArr.push(clone);\n  }\n\n  return new Collection(cy, elesArr);\n};\n\nelesfn$u.copy = elesfn$u.clone;\n\nelesfn$u.restore = function () {\n  var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var addToPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var self = this;\n  var cy = self.cy();\n  var cy_p = cy._private; // create arrays of nodes and edges, since we need to\n  // restore the nodes first\n\n  var nodes = [];\n  var edges = [];\n  var elements;\n\n  for (var _i3 = 0, l = self.length; _i3 < l; _i3++) {\n    var ele = self[_i3];\n\n    if (addToPool && !ele.removed()) {\n      // don't need to handle this ele\n      continue;\n    } // keep nodes first in the array and edges after\n\n\n    if (ele.isNode()) {\n      // put to front of array if node\n      nodes.push(ele);\n    } else {\n      // put to end of array if edge\n      edges.push(ele);\n    }\n  }\n\n  elements = nodes.concat(edges);\n  var i;\n\n  var removeFromElements = function removeFromElements() {\n    elements.splice(i, 1);\n    i--;\n  }; // now, restore each element\n\n\n  for (i = 0; i < elements.length; i++) {\n    var _ele2 = elements[i];\n    var _private = _ele2._private;\n    var _data3 = _private.data; // the traversal cache should start fresh when ele is added\n\n    _ele2.clearTraversalCache(); // set id and validate\n\n\n    if (!addToPool && !_private.removed) ; else if (_data3.id === undefined) {\n      _data3.id = uuid();\n    } else if (number(_data3.id)) {\n      _data3.id = '' + _data3.id; // now it's a string\n    } else if (emptyString(_data3.id) || !string(_data3.id)) {\n      error('Can not create element with invalid string ID `' + _data3.id + '`'); // can't create element if it has empty string as id or non-string id\n\n      removeFromElements();\n      continue;\n    } else if (cy.hasElementWithId(_data3.id)) {\n      error('Can not create second element with ID `' + _data3.id + '`'); // can't create element if one already has that id\n\n      removeFromElements();\n      continue;\n    }\n\n    var id = _data3.id; // id is finalised, now let's keep a ref\n\n    if (_ele2.isNode()) {\n      // extra checks for nodes\n      var pos = _private.position; // make sure the nodes have a defined position\n\n      if (pos.x == null) {\n        pos.x = 0;\n      }\n\n      if (pos.y == null) {\n        pos.y = 0;\n      }\n    }\n\n    if (_ele2.isEdge()) {\n      // extra checks for edges\n      var edge = _ele2;\n      var fields = ['source', 'target'];\n      var fieldsLength = fields.length;\n      var badSourceOrTarget = false;\n\n      for (var j = 0; j < fieldsLength; j++) {\n        var field = fields[j];\n        var val = _data3[field];\n\n        if (number(val)) {\n          val = _data3[field] = '' + _data3[field]; // now string\n        }\n\n        if (val == null || val === '') {\n          // can't create if source or target is not defined properly\n          error('Can not create edge `' + id + '` with unspecified ' + field);\n          badSourceOrTarget = true;\n        } else if (!cy.hasElementWithId(val)) {\n          // can't create edge if one of its nodes doesn't exist\n          error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');\n          badSourceOrTarget = true;\n        }\n      }\n\n      if (badSourceOrTarget) {\n        removeFromElements();\n        continue;\n      } // can't create this\n\n\n      var src = cy.getElementById(_data3.source);\n      var tgt = cy.getElementById(_data3.target); // only one edge in node if loop\n\n      if (src.same(tgt)) {\n        src._private.edges.push(edge);\n      } else {\n        src._private.edges.push(edge);\n\n        tgt._private.edges.push(edge);\n      }\n\n      edge._private.source = src;\n      edge._private.target = tgt;\n    } // if is edge\n    // create mock ids / indexes maps for element so it can be used like collections\n\n\n    _private.map = new Map$1();\n\n    _private.map.set(id, {\n      ele: _ele2,\n      index: 0\n    });\n\n    _private.removed = false;\n\n    if (addToPool) {\n      cy.addToPool(_ele2);\n    }\n  } // for each element\n  // do compound node sanity checks\n\n\n  for (var _i4 = 0; _i4 < nodes.length; _i4++) {\n    // each node\n    var node = nodes[_i4];\n    var _data4 = node._private.data;\n\n    if (number(_data4.parent)) {\n      // then automake string\n      _data4.parent = '' + _data4.parent;\n    }\n\n    var parentId = _data4.parent;\n    var specifiedParent = parentId != null;\n\n    if (specifiedParent) {\n      var parent = cy.getElementById(parentId);\n\n      if (parent.empty()) {\n        // non-existant parent; just remove it\n        _data4.parent = undefined;\n      } else {\n        var selfAsParent = false;\n        var ancestor = parent;\n\n        while (!ancestor.empty()) {\n          if (node.same(ancestor)) {\n            // mark self as parent and remove from data\n            selfAsParent = true;\n            _data4.parent = undefined; // remove parent reference\n            // exit or we loop forever\n\n            break;\n          }\n\n          ancestor = ancestor.parent();\n        }\n\n        if (!selfAsParent) {\n          // connect with children\n          parent[0]._private.children.push(node);\n\n          node._private.parent = parent[0]; // let the core know we have a compound graph\n\n          cy_p.hasCompoundNodes = true;\n        }\n      } // else\n\n    } // if specified parent\n\n  } // for each node\n\n\n  if (elements.length > 0) {\n    var restored = elements.length === self.length ? self : new Collection(cy, elements);\n\n    for (var _i5 = 0; _i5 < restored.length; _i5++) {\n      var _ele3 = restored[_i5];\n\n      if (_ele3.isNode()) {\n        continue;\n      } // adding an edge invalidates the traversal caches for the parallel edges\n\n\n      _ele3.parallelEdges().clearTraversalCache(); // adding an edge invalidates the traversal cache for the connected nodes\n\n\n      _ele3.source().clearTraversalCache();\n\n      _ele3.target().clearTraversalCache();\n    }\n\n    var toUpdateStyle;\n\n    if (cy_p.hasCompoundNodes) {\n      toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());\n    } else {\n      toUpdateStyle = restored;\n    }\n\n    toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);\n\n    if (notifyRenderer) {\n      restored.emitAndNotify('add');\n    } else if (addToPool) {\n      restored.emit('add');\n    }\n  }\n\n  return self; // chainability\n};\n\nelesfn$u.removed = function () {\n  var ele = this[0];\n  return ele && ele._private.removed;\n};\n\nelesfn$u.inside = function () {\n  var ele = this[0];\n  return ele && !ele._private.removed;\n};\n\nelesfn$u.remove = function () {\n  var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var removeFromPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var self = this;\n  var elesToRemove = [];\n  var elesToRemoveIds = {};\n  var cy = self._private.cy; // add connected edges\n\n  function addConnectedEdges(node) {\n    var edges = node._private.edges;\n\n    for (var i = 0; i < edges.length; i++) {\n      add(edges[i]);\n    }\n  } // add descendant nodes\n\n\n  function addChildren(node) {\n    var children = node._private.children;\n\n    for (var i = 0; i < children.length; i++) {\n      add(children[i]);\n    }\n  }\n\n  function add(ele) {\n    var alreadyAdded = elesToRemoveIds[ele.id()];\n\n    if (removeFromPool && ele.removed() || alreadyAdded) {\n      return;\n    } else {\n      elesToRemoveIds[ele.id()] = true;\n    }\n\n    if (ele.isNode()) {\n      elesToRemove.push(ele); // nodes are removed last\n\n      addConnectedEdges(ele);\n      addChildren(ele);\n    } else {\n      elesToRemove.unshift(ele); // edges are removed first\n    }\n  } // make the list of elements to remove\n  // (may be removing more than specified due to connected edges etc)\n\n\n  for (var i = 0, l = self.length; i < l; i++) {\n    var ele = self[i];\n    add(ele);\n  }\n\n  function removeEdgeRef(node, edge) {\n    var connectedEdges = node._private.edges;\n    removeFromArray(connectedEdges, edge); // removing an edges invalidates the traversal cache for its nodes\n\n    node.clearTraversalCache();\n  }\n\n  function removeParallelRef(pllEdge) {\n    // removing an edge invalidates the traversal caches for the parallel edges\n    pllEdge.clearTraversalCache();\n  }\n\n  var alteredParents = [];\n  alteredParents.ids = {};\n\n  function removeChildRef(parent, ele) {\n    ele = ele[0];\n    parent = parent[0];\n    var children = parent._private.children;\n    var pid = parent.id();\n    removeFromArray(children, ele); // remove parent => child ref\n\n    ele._private.parent = null; // remove child => parent ref\n\n    if (!alteredParents.ids[pid]) {\n      alteredParents.ids[pid] = true;\n      alteredParents.push(parent);\n    }\n  }\n\n  self.dirtyCompoundBoundsCache();\n\n  if (removeFromPool) {\n    cy.removeFromPool(elesToRemove); // remove from core pool\n  }\n\n  for (var _i6 = 0; _i6 < elesToRemove.length; _i6++) {\n    var _ele4 = elesToRemove[_i6];\n\n    if (_ele4.isEdge()) {\n      // remove references to this edge in its connected nodes\n      var src = _ele4.source()[0];\n\n      var tgt = _ele4.target()[0];\n\n      removeEdgeRef(src, _ele4);\n      removeEdgeRef(tgt, _ele4);\n\n      var pllEdges = _ele4.parallelEdges();\n\n      for (var j = 0; j < pllEdges.length; j++) {\n        var pllEdge = pllEdges[j];\n        removeParallelRef(pllEdge);\n\n        if (pllEdge.isBundledBezier()) {\n          pllEdge.dirtyBoundingBoxCache();\n        }\n      }\n    } else {\n      // remove reference to parent\n      var parent = _ele4.parent();\n\n      if (parent.length !== 0) {\n        removeChildRef(parent, _ele4);\n      }\n    }\n\n    if (removeFromPool) {\n      // mark as removed\n      _ele4._private.removed = true;\n    }\n  } // check to see if we have a compound graph or not\n\n\n  var elesStillInside = cy._private.elements;\n  cy._private.hasCompoundNodes = false;\n\n  for (var _i7 = 0; _i7 < elesStillInside.length; _i7++) {\n    var _ele5 = elesStillInside[_i7];\n\n    if (_ele5.isParent()) {\n      cy._private.hasCompoundNodes = true;\n      break;\n    }\n  }\n\n  var removedElements = new Collection(this.cy(), elesToRemove);\n\n  if (removedElements.size() > 0) {\n    // must manually notify since trigger won't do this automatically once removed\n    if (notifyRenderer) {\n      removedElements.emitAndNotify('remove');\n    } else if (removeFromPool) {\n      removedElements.emit('remove');\n    }\n  } // the parents who were modified by the removal need their style updated\n\n\n  for (var _i8 = 0; _i8 < alteredParents.length; _i8++) {\n    var _ele6 = alteredParents[_i8];\n\n    if (!removeFromPool || !_ele6.removed()) {\n      _ele6.updateStyle();\n    }\n  }\n\n  return removedElements;\n};\n\nelesfn$u.move = function (struct) {\n  var cy = this._private.cy;\n  var eles = this; // just clean up refs, caches, etc. in the same way as when removing and then restoring\n  // (our calls to remove/restore do not remove from the graph or make events)\n\n  var notifyRenderer = false;\n  var modifyPool = false;\n\n  var toString = function toString(id) {\n    return id == null ? id : '' + id;\n  }; // id must be string\n\n\n  if (struct.source !== undefined || struct.target !== undefined) {\n    var srcId = toString(struct.source);\n    var tgtId = toString(struct.target);\n    var srcExists = srcId != null && cy.hasElementWithId(srcId);\n    var tgtExists = tgtId != null && cy.hasElementWithId(tgtId);\n\n    if (srcExists || tgtExists) {\n      cy.batch(function () {\n        // avoid duplicate style updates\n        eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n\n        eles.emitAndNotify('moveout');\n\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          var _data5 = ele._private.data;\n\n          if (ele.isEdge()) {\n            if (srcExists) {\n              _data5.source = srcId;\n            }\n\n            if (tgtExists) {\n              _data5.target = tgtId;\n            }\n          }\n        }\n\n        eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n      });\n      eles.emitAndNotify('move');\n    }\n  } else if (struct.parent !== undefined) {\n    // move node to new parent\n    var parentId = toString(struct.parent);\n    var parentExists = parentId === null || cy.hasElementWithId(parentId);\n\n    if (parentExists) {\n      var pidToAssign = parentId === null ? undefined : parentId;\n      cy.batch(function () {\n        // avoid duplicate style updates\n        var updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n\n        updated.emitAndNotify('moveout');\n\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          var _data6 = ele._private.data;\n\n          if (ele.isNode()) {\n            _data6.parent = pidToAssign;\n          }\n        }\n\n        updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n      });\n      eles.emitAndNotify('move');\n    }\n  }\n\n  return this;\n};\n\n[elesfn$c, elesfn$d, elesfn$e, elesfn$f, elesfn$g, data$1, elesfn$i, dimensions, elesfn$m, elesfn$n, elesfn$o, elesfn$p, elesfn$q, elesfn$r, elesfn$s, elesfn$t].forEach(function (props) {\n  extend(elesfn$u, props);\n});\n\nvar corefn = {\n  add: function add(opts) {\n    var elements;\n    var cy = this; // add the elements\n\n    if (elementOrCollection(opts)) {\n      var eles = opts;\n\n      if (eles._private.cy === cy) {\n        // same instance => just restore\n        elements = eles.restore();\n      } else {\n        // otherwise, copy from json\n        var jsons = [];\n\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          jsons.push(ele.json());\n        }\n\n        elements = new Collection(cy, jsons);\n      }\n    } // specify an array of options\n    else if (array(opts)) {\n        var _jsons = opts;\n        elements = new Collection(cy, _jsons);\n      } // specify via opts.nodes and opts.edges\n      else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {\n          var elesByGroup = opts;\n          var _jsons2 = [];\n          var grs = ['nodes', 'edges'];\n\n          for (var _i = 0, il = grs.length; _i < il; _i++) {\n            var group = grs[_i];\n            var elesArray = elesByGroup[group];\n\n            if (array(elesArray)) {\n              for (var j = 0, jl = elesArray.length; j < jl; j++) {\n                var json = extend({\n                  group: group\n                }, elesArray[j]);\n\n                _jsons2.push(json);\n              }\n            }\n          }\n\n          elements = new Collection(cy, _jsons2);\n        } // specify options for one element\n        else {\n            var _json = opts;\n            elements = new Element(cy, _json).collection();\n          }\n\n    return elements;\n  },\n  remove: function remove(collection) {\n    if (elementOrCollection(collection)) ; else if (string(collection)) {\n      var selector = collection;\n      collection = this.$(selector);\n    }\n\n    return collection.remove();\n  }\n};\n\n/* global Float32Array */\n\n/*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */\nfunction generateCubicBezier(mX1, mY1, mX2, mY2) {\n  var NEWTON_ITERATIONS = 4,\n      NEWTON_MIN_SLOPE = 0.001,\n      SUBDIVISION_PRECISION = 0.0000001,\n      SUBDIVISION_MAX_ITERATIONS = 10,\n      kSplineTableSize = 11,\n      kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),\n      float32ArraySupported = typeof Float32Array !== 'undefined';\n  /* Must contain four arguments. */\n\n  if (arguments.length !== 4) {\n    return false;\n  }\n  /* Arguments must be numbers. */\n\n\n  for (var i = 0; i < 4; ++i) {\n    if (typeof arguments[i] !== \"number\" || isNaN(arguments[i]) || !isFinite(arguments[i])) {\n      return false;\n    }\n  }\n  /* X values must be in the [0, 1] range. */\n\n\n  mX1 = Math.min(mX1, 1);\n  mX2 = Math.min(mX2, 1);\n  mX1 = Math.max(mX1, 0);\n  mX2 = Math.max(mX2, 0);\n  var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  function A(aA1, aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n  }\n\n  function B(aA1, aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n  }\n\n  function C(aA1) {\n    return 3.0 * aA1;\n  }\n\n  function calcBezier(aT, aA1, aA2) {\n    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n  }\n\n  function getSlope(aT, aA1, aA2) {\n    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n  }\n\n  function newtonRaphsonIterate(aX, aGuessT) {\n    for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {\n      var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n      if (currentSlope === 0.0) {\n        return aGuessT;\n      }\n\n      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n      aGuessT -= currentX / currentSlope;\n    }\n\n    return aGuessT;\n  }\n\n  function calcSampleValues() {\n    for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {\n      mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  function binarySubdivide(aX, aA, aB) {\n    var currentX,\n        currentT,\n        i = 0;\n\n    do {\n      currentT = aA + (aB - aA) / 2.0;\n      currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n      if (currentX > 0.0) {\n        aB = currentT;\n      } else {\n        aA = currentT;\n      }\n    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n    return currentT;\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0,\n        currentSample = 1,\n        lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample;\n    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),\n        guessForT = intervalStart + dist * kSampleStepSize,\n        initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\n    }\n  }\n\n  var _precomputed = false;\n\n  function precompute() {\n    _precomputed = true;\n\n    if (mX1 !== mY1 || mX2 !== mY2) {\n      calcSampleValues();\n    }\n  }\n\n  var f = function f(aX) {\n    if (!_precomputed) {\n      precompute();\n    }\n\n    if (mX1 === mY1 && mX2 === mY2) {\n      return aX;\n    }\n\n    if (aX === 0) {\n      return 0;\n    }\n\n    if (aX === 1) {\n      return 1;\n    }\n\n    return calcBezier(getTForX(aX), mY1, mY2);\n  };\n\n  f.getControlPoints = function () {\n    return [{\n      x: mX1,\n      y: mY1\n    }, {\n      x: mX2,\n      y: mY2\n    }];\n  };\n\n  var str = \"generateBezier(\" + [mX1, mY1, mX2, mY2] + \")\";\n\n  f.toString = function () {\n    return str;\n  };\n\n  return f;\n}\n\n/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */\n\n/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass\n   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */\nvar generateSpringRK4 = function () {\n  function springAccelerationForState(state) {\n    return -state.tension * state.x - state.friction * state.v;\n  }\n\n  function springEvaluateStateWithDerivative(initialState, dt, derivative) {\n    var state = {\n      x: initialState.x + derivative.dx * dt,\n      v: initialState.v + derivative.dv * dt,\n      tension: initialState.tension,\n      friction: initialState.friction\n    };\n    return {\n      dx: state.v,\n      dv: springAccelerationForState(state)\n    };\n  }\n\n  function springIntegrateState(state, dt) {\n    var a = {\n      dx: state.v,\n      dv: springAccelerationForState(state)\n    },\n        b = springEvaluateStateWithDerivative(state, dt * 0.5, a),\n        c = springEvaluateStateWithDerivative(state, dt * 0.5, b),\n        d = springEvaluateStateWithDerivative(state, dt, c),\n        dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),\n        dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);\n    state.x = state.x + dxdt * dt;\n    state.v = state.v + dvdt * dt;\n    return state;\n  }\n\n  return function springRK4Factory(tension, friction, duration) {\n    var initState = {\n      x: -1,\n      v: 0,\n      tension: null,\n      friction: null\n    },\n        path = [0],\n        time_lapsed = 0,\n        tolerance = 1 / 10000,\n        DT = 16 / 1000,\n        have_duration,\n        dt,\n        last_state;\n    tension = parseFloat(tension) || 500;\n    friction = parseFloat(friction) || 20;\n    duration = duration || null;\n    initState.tension = tension;\n    initState.friction = friction;\n    have_duration = duration !== null;\n    /* Calculate the actual time it takes for this animation to complete with the provided conditions. */\n\n    if (have_duration) {\n      /* Run the simulation without a duration. */\n      time_lapsed = springRK4Factory(tension, friction);\n      /* Compute the adjusted time delta. */\n\n      dt = time_lapsed / duration * DT;\n    } else {\n      dt = DT;\n    }\n\n    for (;;) {\n      /* Next/step function .*/\n      last_state = springIntegrateState(last_state || initState, dt);\n      /* Store the position. */\n\n      path.push(1 + last_state.x);\n      time_lapsed += 16;\n      /* If the change threshold is reached, break. */\n\n      if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {\n        break;\n      }\n    }\n    /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the\n       computed path and returns a snapshot of the position according to a given percentComplete. */\n\n\n    return !have_duration ? time_lapsed : function (percentComplete) {\n      return path[percentComplete * (path.length - 1) | 0];\n    };\n  };\n}();\n\nvar cubicBezier = function cubicBezier(t1, p1, t2, p2) {\n  var bezier = generateCubicBezier(t1, p1, t2, p2);\n  return function (start, end, percent) {\n    return start + (end - start) * bezier(percent);\n  };\n};\n\nvar easings = {\n  'linear': function linear(start, end, percent) {\n    return start + (end - start) * percent;\n  },\n  // default easings\n  'ease': cubicBezier(0.25, 0.1, 0.25, 1),\n  'ease-in': cubicBezier(0.42, 0, 1, 1),\n  'ease-out': cubicBezier(0, 0, 0.58, 1),\n  'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),\n  // sine\n  'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),\n  'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),\n  'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),\n  // quad\n  'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),\n  'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),\n  'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),\n  // cubic\n  'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),\n  'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),\n  'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),\n  // quart\n  'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),\n  'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),\n  'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),\n  // quint\n  'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),\n  'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),\n  'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),\n  // expo\n  'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),\n  'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),\n  'ease-in-out-expo': cubicBezier(1, 0, 0, 1),\n  // circ\n  'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),\n  'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),\n  'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),\n  // user param easings...\n  'spring': function spring(tension, friction, duration) {\n    if (duration === 0) {\n      // can't get a spring w/ duration 0\n      return easings.linear; // duration 0 => jump to end so impl doesn't matter\n    }\n\n    var spring = generateSpringRK4(tension, friction, duration);\n    return function (start, end, percent) {\n      return start + (end - start) * spring(percent);\n    };\n  },\n  'cubic-bezier': cubicBezier\n};\n\nfunction getEasedValue(type, start, end, percent, easingFn) {\n  if (percent === 1) {\n    return end;\n  }\n\n  if (start === end) {\n    return end;\n  }\n\n  var val = easingFn(start, end, percent);\n\n  if (type == null) {\n    return val;\n  }\n\n  if (type.roundValue || type.color) {\n    val = Math.round(val);\n  }\n\n  if (type.min !== undefined) {\n    val = Math.max(val, type.min);\n  }\n\n  if (type.max !== undefined) {\n    val = Math.min(val, type.max);\n  }\n\n  return val;\n}\n\nfunction getValue(prop, spec) {\n  if (prop.pfValue != null || prop.value != null) {\n    if (prop.pfValue != null && (spec == null || spec.type.units !== '%')) {\n      return prop.pfValue;\n    } else {\n      return prop.value;\n    }\n  } else {\n    return prop;\n  }\n}\n\nfunction ease(startProp, endProp, percent, easingFn, propSpec) {\n  var type = propSpec != null ? propSpec.type : null;\n\n  if (percent < 0) {\n    percent = 0;\n  } else if (percent > 1) {\n    percent = 1;\n  }\n\n  var start = getValue(startProp, propSpec);\n  var end = getValue(endProp, propSpec);\n\n  if (number(start) && number(end)) {\n    return getEasedValue(type, start, end, percent, easingFn);\n  } else if (array(start) && array(end)) {\n    var easedArr = [];\n\n    for (var i = 0; i < end.length; i++) {\n      var si = start[i];\n      var ei = end[i];\n\n      if (si != null && ei != null) {\n        var val = getEasedValue(type, si, ei, percent, easingFn);\n        easedArr.push(val);\n      } else {\n        easedArr.push(ei);\n      }\n    }\n\n    return easedArr;\n  }\n\n  return undefined;\n}\n\nfunction step(self, ani, now, isCore) {\n  var isEles = !isCore;\n  var _p = self._private;\n  var ani_p = ani._private;\n  var pEasing = ani_p.easing;\n  var startTime = ani_p.startTime;\n  var cy = isCore ? self : self.cy();\n  var style = cy.style();\n\n  if (!ani_p.easingImpl) {\n    if (pEasing == null) {\n      // use default\n      ani_p.easingImpl = easings['linear'];\n    } else {\n      // then define w/ name\n      var easingVals;\n\n      if (string(pEasing)) {\n        var easingProp = style.parse('transition-timing-function', pEasing);\n        easingVals = easingProp.value;\n      } else {\n        // then assume preparsed array\n        easingVals = pEasing;\n      }\n\n      var name, args;\n\n      if (string(easingVals)) {\n        name = easingVals;\n        args = [];\n      } else {\n        name = easingVals[1];\n        args = easingVals.slice(2).map(function (n) {\n          return +n;\n        });\n      }\n\n      if (args.length > 0) {\n        // create with args\n        if (name === 'spring') {\n          args.push(ani_p.duration); // need duration to generate spring\n        }\n\n        ani_p.easingImpl = easings[name].apply(null, args);\n      } else {\n        // static impl by name\n        ani_p.easingImpl = easings[name];\n      }\n    }\n  }\n\n  var easing = ani_p.easingImpl;\n  var percent;\n\n  if (ani_p.duration === 0) {\n    percent = 1;\n  } else {\n    percent = (now - startTime) / ani_p.duration;\n  }\n\n  if (ani_p.applying) {\n    percent = ani_p.progress;\n  }\n\n  if (percent < 0) {\n    percent = 0;\n  } else if (percent > 1) {\n    percent = 1;\n  }\n\n  if (ani_p.delay == null) {\n    // then update\n    var startPos = ani_p.startPosition;\n    var endPos = ani_p.position;\n\n    if (endPos && isEles && !self.locked()) {\n      var newPos = {};\n\n      if (valid(startPos.x, endPos.x)) {\n        newPos.x = ease(startPos.x, endPos.x, percent, easing);\n      }\n\n      if (valid(startPos.y, endPos.y)) {\n        newPos.y = ease(startPos.y, endPos.y, percent, easing);\n      }\n\n      self.position(newPos);\n    }\n\n    var startPan = ani_p.startPan;\n    var endPan = ani_p.pan;\n    var pan = _p.pan;\n    var animatingPan = endPan != null && isCore;\n\n    if (animatingPan) {\n      if (valid(startPan.x, endPan.x)) {\n        pan.x = ease(startPan.x, endPan.x, percent, easing);\n      }\n\n      if (valid(startPan.y, endPan.y)) {\n        pan.y = ease(startPan.y, endPan.y, percent, easing);\n      }\n\n      self.emit('pan');\n    }\n\n    var startZoom = ani_p.startZoom;\n    var endZoom = ani_p.zoom;\n    var animatingZoom = endZoom != null && isCore;\n\n    if (animatingZoom) {\n      if (valid(startZoom, endZoom)) {\n        _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);\n      }\n\n      self.emit('zoom');\n    }\n\n    if (animatingPan || animatingZoom) {\n      self.emit('viewport');\n    }\n\n    var props = ani_p.style;\n\n    if (props && props.length > 0 && isEles) {\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        var _name = prop.name;\n        var end = prop;\n        var start = ani_p.startStyle[_name];\n        var propSpec = style.properties[start.name];\n        var easedVal = ease(start, end, percent, easing, propSpec);\n        style.overrideBypass(self, _name, easedVal);\n      } // for props\n\n\n      self.emit('style');\n    } // if\n\n  }\n\n  ani_p.progress = percent;\n  return percent;\n}\n\nfunction valid(start, end) {\n  if (start == null || end == null) {\n    return false;\n  }\n\n  if (number(start) && number(end)) {\n    return true;\n  } else if (start && end) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction startAnimation(self, ani, now, isCore) {\n  var ani_p = ani._private;\n  ani_p.started = true;\n  ani_p.startTime = now - ani_p.progress * ani_p.duration;\n}\n\nfunction stepAll(now, cy) {\n  var eles = cy._private.aniEles;\n  var doneEles = [];\n\n  function stepOne(ele, isCore) {\n    var _p = ele._private;\n    var current = _p.animation.current;\n    var queue = _p.animation.queue;\n    var ranAnis = false; // if nothing currently animating, get something from the queue\n\n    if (current.length === 0) {\n      var next = queue.shift();\n\n      if (next) {\n        current.push(next);\n      }\n    }\n\n    var callbacks = function callbacks(_callbacks) {\n      for (var j = _callbacks.length - 1; j >= 0; j--) {\n        var cb = _callbacks[j];\n        cb();\n      }\n\n      _callbacks.splice(0, _callbacks.length);\n    }; // step and remove if done\n\n\n    for (var i = current.length - 1; i >= 0; i--) {\n      var ani = current[i];\n      var ani_p = ani._private;\n\n      if (ani_p.stopped) {\n        current.splice(i, 1);\n        ani_p.hooked = false;\n        ani_p.playing = false;\n        ani_p.started = false;\n        callbacks(ani_p.frames);\n        continue;\n      }\n\n      if (!ani_p.playing && !ani_p.applying) {\n        continue;\n      } // an apply() while playing shouldn't do anything\n\n\n      if (ani_p.playing && ani_p.applying) {\n        ani_p.applying = false;\n      }\n\n      if (!ani_p.started) {\n        startAnimation(ele, ani, now);\n      }\n\n      step(ele, ani, now, isCore);\n\n      if (ani_p.applying) {\n        ani_p.applying = false;\n      }\n\n      callbacks(ani_p.frames);\n\n      if (ani_p.step != null) {\n        ani_p.step(now);\n      }\n\n      if (ani.completed()) {\n        current.splice(i, 1);\n        ani_p.hooked = false;\n        ani_p.playing = false;\n        ani_p.started = false;\n        callbacks(ani_p.completes);\n      }\n\n      ranAnis = true;\n    }\n\n    if (!isCore && current.length === 0 && queue.length === 0) {\n      doneEles.push(ele);\n    }\n\n    return ranAnis;\n  } // stepElement\n  // handle all eles\n\n\n  var ranEleAni = false;\n\n  for (var e = 0; e < eles.length; e++) {\n    var ele = eles[e];\n    var handledThisEle = stepOne(ele);\n    ranEleAni = ranEleAni || handledThisEle;\n  } // each element\n\n\n  var ranCoreAni = stepOne(cy, true); // notify renderer\n\n  if (ranEleAni || ranCoreAni) {\n    if (eles.length > 0) {\n      cy.notify('draw', eles);\n    } else {\n      cy.notify('draw');\n    }\n  } // remove elements from list of currently animating if its queues are empty\n\n\n  eles.unmerge(doneEles);\n  cy.emit('step');\n} // stepAll\n\nvar corefn$1 = {\n  // pull in animation functions\n  animate: define$3.animate(),\n  animation: define$3.animation(),\n  animated: define$3.animated(),\n  clearQueue: define$3.clearQueue(),\n  delay: define$3.delay(),\n  delayAnimation: define$3.delayAnimation(),\n  stop: define$3.stop(),\n  addToAnimationPool: function addToAnimationPool(eles) {\n    var cy = this;\n\n    if (!cy.styleEnabled()) {\n      return;\n    } // save cycles when no style used\n\n\n    cy._private.aniEles.merge(eles);\n  },\n  stopAnimationLoop: function stopAnimationLoop() {\n    this._private.animationsRunning = false;\n  },\n  startAnimationLoop: function startAnimationLoop() {\n    var cy = this;\n    cy._private.animationsRunning = true;\n\n    if (!cy.styleEnabled()) {\n      return;\n    } // save cycles when no style used\n    // NB the animation loop will exec in headless environments if style enabled\n    // and explicit cy.destroy() is necessary to stop the loop\n\n\n    function headlessStep() {\n      if (!cy._private.animationsRunning) {\n        return;\n      }\n\n      requestAnimationFrame(function animationStep(now) {\n        stepAll(now, cy);\n        headlessStep();\n      });\n    }\n\n    var renderer = cy.renderer();\n\n    if (renderer && renderer.beforeRender) {\n      // let the renderer schedule animations\n      renderer.beforeRender(function rendererAnimationStep(willDraw, now) {\n        stepAll(now, cy);\n      }, renderer.beforeRenderPriorities.animations);\n    } else {\n      // manage the animation loop ourselves\n      headlessStep(); // first call\n    }\n  }\n};\n\nvar emitterOptions$1 = {\n  qualifierCompare: function qualifierCompare(selector1, selector2) {\n    if (selector1 == null || selector2 == null) {\n      return selector1 == null && selector2 == null;\n    } else {\n      return selector1.sameText(selector2);\n    }\n  },\n  eventMatches: function eventMatches(cy, listener, eventObj) {\n    var selector = listener.qualifier;\n\n    if (selector != null) {\n      return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n    }\n\n    return true;\n  },\n  addEventFields: function addEventFields(cy, evt) {\n    evt.cy = cy;\n    evt.target = cy;\n  },\n  callbackContext: function callbackContext(cy, listener, eventObj) {\n    return listener.qualifier != null ? eventObj.target : cy;\n  }\n};\n\nvar argSelector$1 = function argSelector(arg) {\n  if (string(arg)) {\n    return new Selector(arg);\n  } else {\n    return arg;\n  }\n};\n\nvar elesfn$v = {\n  createEmitter: function createEmitter() {\n    var _p = this._private;\n\n    if (!_p.emitter) {\n      _p.emitter = new Emitter(emitterOptions$1, this);\n    }\n\n    return this;\n  },\n  emitter: function emitter() {\n    return this._private.emitter;\n  },\n  on: function on(events, selector, callback) {\n    this.emitter().on(events, argSelector$1(selector), callback);\n    return this;\n  },\n  removeListener: function removeListener(events, selector, callback) {\n    this.emitter().removeListener(events, argSelector$1(selector), callback);\n    return this;\n  },\n  removeAllListeners: function removeAllListeners() {\n    this.emitter().removeAllListeners();\n    return this;\n  },\n  one: function one(events, selector, callback) {\n    this.emitter().one(events, argSelector$1(selector), callback);\n    return this;\n  },\n  once: function once(events, selector, callback) {\n    this.emitter().one(events, argSelector$1(selector), callback);\n    return this;\n  },\n  emit: function emit(events, extraParams) {\n    this.emitter().emit(events, extraParams);\n    return this;\n  },\n  emitAndNotify: function emitAndNotify(event, eles) {\n    this.emit(event);\n    this.notify(event, eles);\n    return this;\n  }\n};\ndefine$3.eventAliasesOn(elesfn$v);\n\nvar corefn$2 = {\n  png: function png(options) {\n    var renderer = this._private.renderer;\n    options = options || {};\n    return renderer.png(options);\n  },\n  jpg: function jpg(options) {\n    var renderer = this._private.renderer;\n    options = options || {};\n    options.bg = options.bg || '#fff';\n    return renderer.jpg(options);\n  }\n};\ncorefn$2.jpeg = corefn$2.jpg;\n\nvar corefn$3 = {\n  layout: function layout(options) {\n    var cy = this;\n\n    if (options == null) {\n      error('Layout options must be specified to make a layout');\n      return;\n    }\n\n    if (options.name == null) {\n      error('A `name` must be specified to make a layout');\n      return;\n    }\n\n    var name = options.name;\n    var Layout = cy.extension('layout', name);\n\n    if (Layout == null) {\n      error('No such layout `' + name + '` found.  Did you forget to import it and `cytoscape.use()` it?');\n      return;\n    }\n\n    var eles;\n\n    if (string(options.eles)) {\n      eles = cy.$(options.eles);\n    } else {\n      eles = options.eles != null ? options.eles : cy.$();\n    }\n\n    var layout = new Layout(extend({}, options, {\n      cy: cy,\n      eles: eles\n    }));\n    return layout;\n  }\n};\ncorefn$3.createLayout = corefn$3.makeLayout = corefn$3.layout;\n\nvar corefn$4 = {\n  notify: function notify(eventName, eventEles) {\n    var _p = this._private;\n\n    if (this.batching()) {\n      _p.batchNotifications = _p.batchNotifications || {};\n      var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();\n\n      if (eventEles != null) {\n        eles.merge(eventEles);\n      }\n\n      return; // notifications are disabled during batching\n    }\n\n    if (!_p.notificationsEnabled) {\n      return;\n    } // exit on disabled\n\n\n    var renderer = this.renderer(); // exit if destroy() called on core or renderer in between frames #1499 #1528\n\n    if (this.destroyed() || !renderer) {\n      return;\n    }\n\n    renderer.notify(eventName, eventEles);\n  },\n  notifications: function notifications(bool) {\n    var p = this._private;\n\n    if (bool === undefined) {\n      return p.notificationsEnabled;\n    } else {\n      p.notificationsEnabled = bool ? true : false;\n    }\n\n    return this;\n  },\n  noNotifications: function noNotifications(callback) {\n    this.notifications(false);\n    callback();\n    this.notifications(true);\n  },\n  batching: function batching() {\n    return this._private.batchCount > 0;\n  },\n  startBatch: function startBatch() {\n    var _p = this._private;\n\n    if (_p.batchCount == null) {\n      _p.batchCount = 0;\n    }\n\n    if (_p.batchCount === 0) {\n      _p.batchStyleEles = this.collection();\n      _p.batchNotifications = {};\n    }\n\n    _p.batchCount++;\n    return this;\n  },\n  endBatch: function endBatch() {\n    var _p = this._private;\n\n    if (_p.batchCount === 0) {\n      return this;\n    }\n\n    _p.batchCount--;\n\n    if (_p.batchCount === 0) {\n      // update style for dirty eles\n      _p.batchStyleEles.updateStyle();\n\n      var renderer = this.renderer(); // notify the renderer of queued eles and event types\n\n      Object.keys(_p.batchNotifications).forEach(function (eventName) {\n        var eles = _p.batchNotifications[eventName];\n\n        if (eles.empty()) {\n          renderer.notify(eventName);\n        } else {\n          renderer.notify(eventName, eles);\n        }\n      });\n    }\n\n    return this;\n  },\n  batch: function batch(callback) {\n    this.startBatch();\n    callback();\n    this.endBatch();\n    return this;\n  },\n  // for backwards compatibility\n  batchData: function batchData(map) {\n    var cy = this;\n    return this.batch(function () {\n      var ids = Object.keys(map);\n\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var data = map[id];\n        var ele = cy.getElementById(id);\n        ele.data(data);\n      }\n    });\n  }\n};\n\nvar rendererDefaults = defaults({\n  hideEdgesOnViewport: false,\n  textureOnViewport: false,\n  motionBlur: false,\n  motionBlurOpacity: 0.05,\n  pixelRatio: undefined,\n  desktopTapThreshold: 4,\n  touchTapThreshold: 8,\n  wheelSensitivity: 1,\n  debug: false,\n  showFps: false\n});\nvar corefn$5 = {\n  renderTo: function renderTo(context, zoom, pan, pxRatio) {\n    var r = this._private.renderer;\n    r.renderTo(context, zoom, pan, pxRatio);\n    return this;\n  },\n  renderer: function renderer() {\n    return this._private.renderer;\n  },\n  forceRender: function forceRender() {\n    this.notify('draw');\n    return this;\n  },\n  resize: function resize() {\n    this.invalidateSize();\n    this.emitAndNotify('resize');\n    return this;\n  },\n  initRenderer: function initRenderer(options) {\n    var cy = this;\n    var RendererProto = cy.extension('renderer', options.name);\n\n    if (RendererProto == null) {\n      error(\"Can not initialise: No such renderer `\".concat(options.name, \"` found. Did you forget to import it and `cytoscape.use()` it?\"));\n      return;\n    }\n\n    if (options.wheelSensitivity !== undefined) {\n      warn(\"You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.\");\n    }\n\n    var rOpts = rendererDefaults(options);\n    rOpts.cy = cy;\n    cy._private.renderer = new RendererProto(rOpts);\n    this.notify('init');\n  },\n  destroyRenderer: function destroyRenderer() {\n    var cy = this;\n    cy.notify('destroy'); // destroy the renderer\n\n    var domEle = cy.container();\n\n    if (domEle) {\n      domEle._cyreg = null;\n\n      while (domEle.childNodes.length > 0) {\n        domEle.removeChild(domEle.childNodes[0]);\n      }\n    }\n\n    cy._private.renderer = null; // to be extra safe, remove the ref\n\n    cy.mutableElements().forEach(function (ele) {\n      var _p = ele._private;\n      _p.rscratch = {};\n      _p.rstyle = {};\n      _p.animation.current = [];\n      _p.animation.queue = [];\n    });\n  },\n  onRender: function onRender(fn) {\n    return this.on('render', fn);\n  },\n  offRender: function offRender(fn) {\n    return this.off('render', fn);\n  }\n};\ncorefn$5.invalidateDimensions = corefn$5.resize;\n\nvar corefn$6 = {\n  // get a collection\n  // - empty collection on no args\n  // - collection of elements in the graph on selector arg\n  // - guarantee a returned collection when elements or collection specified\n  collection: function collection(eles, opts) {\n    if (string(eles)) {\n      return this.$(eles);\n    } else if (elementOrCollection(eles)) {\n      return eles.collection();\n    } else if (array(eles)) {\n      return new Collection(this, eles, opts);\n    }\n\n    return new Collection(this);\n  },\n  nodes: function nodes(selector) {\n    var nodes = this.$(function (ele) {\n      return ele.isNode();\n    });\n\n    if (selector) {\n      return nodes.filter(selector);\n    }\n\n    return nodes;\n  },\n  edges: function edges(selector) {\n    var edges = this.$(function (ele) {\n      return ele.isEdge();\n    });\n\n    if (selector) {\n      return edges.filter(selector);\n    }\n\n    return edges;\n  },\n  // search the graph like jQuery\n  $: function $(selector) {\n    var eles = this._private.elements;\n\n    if (selector) {\n      return eles.filter(selector);\n    } else {\n      return eles.spawnSelf();\n    }\n  },\n  mutableElements: function mutableElements() {\n    return this._private.elements;\n  }\n}; // aliases\n\ncorefn$6.elements = corefn$6.filter = corefn$6.$;\n\nvar styfn = {}; // keys for style blocks, e.g. ttfftt\n\nvar TRUE = 't';\nvar FALSE = 'f'; // (potentially expensive calculation)\n// apply the style to the element based on\n// - its bypass\n// - what selectors match it\n\nstyfn.apply = function (eles) {\n  var self = this;\n  var _p = self._private;\n  var cy = _p.cy;\n  var updatedEles = cy.collection();\n\n  for (var ie = 0; ie < eles.length; ie++) {\n    var ele = eles[ie];\n    var cxtMeta = self.getContextMeta(ele);\n\n    if (cxtMeta.empty) {\n      continue;\n    }\n\n    var cxtStyle = self.getContextStyle(cxtMeta);\n    var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);\n\n    if (ele._private.appliedInitStyle) {\n      self.updateTransitions(ele, app.diffProps);\n    } else {\n      ele._private.appliedInitStyle = true;\n    }\n\n    var hintsDiff = self.updateStyleHints(ele);\n\n    if (hintsDiff) {\n      updatedEles.push(ele);\n    }\n  } // for elements\n\n\n  return updatedEles;\n};\n\nstyfn.getPropertiesDiff = function (oldCxtKey, newCxtKey) {\n  var self = this;\n  var cache = self._private.propDiffs = self._private.propDiffs || {};\n  var dualCxtKey = oldCxtKey + '-' + newCxtKey;\n  var cachedVal = cache[dualCxtKey];\n\n  if (cachedVal) {\n    return cachedVal;\n  }\n\n  var diffProps = [];\n  var addedProp = {};\n\n  for (var i = 0; i < self.length; i++) {\n    var cxt = self[i];\n    var oldHasCxt = oldCxtKey[i] === TRUE;\n    var newHasCxt = newCxtKey[i] === TRUE;\n    var cxtHasDiffed = oldHasCxt !== newHasCxt;\n    var cxtHasMappedProps = cxt.mappedProperties.length > 0;\n\n    if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {\n      var props = void 0;\n\n      if (cxtHasDiffed && cxtHasMappedProps) {\n        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties\n      } else if (cxtHasDiffed) {\n        props = cxt.properties; // need to check them all\n      } else if (cxtHasMappedProps) {\n        props = cxt.mappedProperties; // only need to check mapped\n      }\n\n      for (var j = 0; j < props.length; j++) {\n        var prop = props[j];\n        var name = prop.name; // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter\n        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result\n        // is cached)\n\n        var laterCxtOverrides = false;\n\n        for (var k = i + 1; k < self.length; k++) {\n          var laterCxt = self[k];\n          var hasLaterCxt = newCxtKey[k] === TRUE;\n\n          if (!hasLaterCxt) {\n            continue;\n          } // can't override unless the context is active\n\n\n          laterCxtOverrides = laterCxt.properties[prop.name] != null;\n\n          if (laterCxtOverrides) {\n            break;\n          } // exit early as long as one later context overrides\n\n        }\n\n        if (!addedProp[name] && !laterCxtOverrides) {\n          addedProp[name] = true;\n          diffProps.push(name);\n        }\n      } // for props\n\n    } // if\n\n  } // for contexts\n\n\n  cache[dualCxtKey] = diffProps;\n  return diffProps;\n};\n\nstyfn.getContextMeta = function (ele) {\n  var self = this;\n  var cxtKey = '';\n  var diffProps;\n  var prevKey = ele._private.styleCxtKey || ''; // get the cxt key\n\n  for (var i = 0; i < self.length; i++) {\n    var context = self[i];\n    var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'\n\n    if (contextSelectorMatches) {\n      cxtKey += TRUE;\n    } else {\n      cxtKey += FALSE;\n    }\n  } // for context\n\n\n  diffProps = self.getPropertiesDiff(prevKey, cxtKey);\n  ele._private.styleCxtKey = cxtKey;\n  return {\n    key: cxtKey,\n    diffPropNames: diffProps,\n    empty: diffProps.length === 0\n  };\n}; // gets a computed ele style object based on matched contexts\n\n\nstyfn.getContextStyle = function (cxtMeta) {\n  var cxtKey = cxtMeta.key;\n  var self = this;\n  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {}; // if already computed style, returned cached copy\n\n  if (cxtStyles[cxtKey]) {\n    return cxtStyles[cxtKey];\n  }\n\n  var style = {\n    _private: {\n      key: cxtKey\n    }\n  };\n\n  for (var i = 0; i < self.length; i++) {\n    var cxt = self[i];\n    var hasCxt = cxtKey[i] === TRUE;\n\n    if (!hasCxt) {\n      continue;\n    }\n\n    for (var j = 0; j < cxt.properties.length; j++) {\n      var prop = cxt.properties[j];\n      style[prop.name] = prop;\n    }\n  }\n\n  cxtStyles[cxtKey] = style;\n  return style;\n};\n\nstyfn.applyContextStyle = function (cxtMeta, cxtStyle, ele) {\n  var self = this;\n  var diffProps = cxtMeta.diffPropNames;\n  var retDiffProps = {};\n  var types = self.types;\n\n  for (var i = 0; i < diffProps.length; i++) {\n    var diffPropName = diffProps[i];\n    var cxtProp = cxtStyle[diffPropName];\n    var eleProp = ele.pstyle(diffPropName);\n\n    if (!cxtProp) {\n      // no context prop means delete\n      if (!eleProp) {\n        continue; // no existing prop means nothing needs to be removed\n        // nb affects initial application on mapped values like control-point-distances\n      } else if (eleProp.bypass) {\n        cxtProp = {\n          name: diffPropName,\n          deleteBypassed: true\n        };\n      } else {\n        cxtProp = {\n          name: diffPropName,\n          \"delete\": true\n        };\n      }\n    } // save cycles when the context prop doesn't need to be applied\n\n\n    if (eleProp === cxtProp) {\n      continue;\n    } // save cycles when a mapped context prop doesn't need to be applied\n\n\n    if (cxtProp.mapped === types.fn // context prop is function mapper\n    && eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)\n    && eleProp.mapping != null // ele prop is a concrete value from from a mapper\n    && eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper\n    ) {\n        // NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)\n        var mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy\n\n        var fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss\n\n        if (fnValue === mapping.prevFnValue) {\n          continue;\n        }\n      }\n\n    var retDiffProp = retDiffProps[diffPropName] = {\n      prev: eleProp\n    };\n    self.applyParsedProperty(ele, cxtProp);\n    retDiffProp.next = ele.pstyle(diffPropName);\n\n    if (retDiffProp.next && retDiffProp.next.bypass) {\n      retDiffProp.next = retDiffProp.next.bypassed;\n    }\n  }\n\n  return {\n    diffProps: retDiffProps\n  };\n};\n\nstyfn.updateStyleHints = function (ele) {\n  var _p = ele._private;\n  var self = this;\n  var propNames = self.propertyGroupNames;\n  var propGrKeys = self.propertyGroupKeys;\n\n  var propHash = function propHash(ele, propNames, seedKey) {\n    return self.getPropertiesHash(ele, propNames, seedKey);\n  };\n\n  var oldStyleKey = _p.styleKey;\n\n  if (ele.removed()) {\n    return false;\n  }\n\n  var isNode = _p.group === 'nodes'; // get the style key hashes per prop group\n  // but lazily -- only use non-default prop values to reduce the number of hashes\n  //\n\n  var overriddenStyles = ele._private.style;\n  propNames = Object.keys(overriddenStyles);\n\n  for (var i = 0; i < propGrKeys.length; i++) {\n    var grKey = propGrKeys[i];\n    _p.styleKeys[grKey] = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];\n  }\n\n  var updateGrKey1 = function updateGrKey1(val, grKey) {\n    return _p.styleKeys[grKey][0] = hashInt(val, _p.styleKeys[grKey][0]);\n  };\n\n  var updateGrKey2 = function updateGrKey2(val, grKey) {\n    return _p.styleKeys[grKey][1] = hashIntAlt(val, _p.styleKeys[grKey][1]);\n  };\n\n  var updateGrKey = function updateGrKey(val, grKey) {\n    updateGrKey1(val, grKey);\n    updateGrKey2(val, grKey);\n  };\n\n  var updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {\n    for (var j = 0; j < strVal.length; j++) {\n      var ch = strVal.charCodeAt(j);\n      updateGrKey1(ch, grKey);\n      updateGrKey2(ch, grKey);\n    }\n  }; // - hashing works on 32 bit ints b/c we use bitwise ops\n  // - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)\n  // - raise up small numbers so more significant digits are seen by hashing\n  // - make small numbers larger than a normal value to avoid collisions\n  // - works in practice and it's relatively cheap\n\n\n  var N = 2000000000;\n\n  var cleanNum = function cleanNum(val) {\n    return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;\n  };\n\n  for (var _i = 0; _i < propNames.length; _i++) {\n    var name = propNames[_i];\n    var parsedProp = overriddenStyles[name];\n\n    if (parsedProp == null) {\n      continue;\n    }\n\n    var propInfo = this.properties[name];\n    var type = propInfo.type;\n    var _grKey = propInfo.groupKey;\n    var normalizedNumberVal = void 0;\n\n    if (propInfo.hashOverride != null) {\n      normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);\n    } else if (parsedProp.pfValue != null) {\n      normalizedNumberVal = parsedProp.pfValue;\n    } // might not be a number if it allows enums\n\n\n    var numberVal = propInfo.enums == null ? parsedProp.value : null;\n    var haveNormNum = normalizedNumberVal != null;\n    var haveUnitedNum = numberVal != null;\n    var haveNum = haveNormNum || haveUnitedNum;\n    var units = parsedProp.units; // numbers are cheaper to hash than strings\n    // 1 hash op vs n hash ops (for length n string)\n\n    if (type.number && haveNum && !type.multiple) {\n      var v = haveNormNum ? normalizedNumberVal : numberVal;\n      updateGrKey(cleanNum(v), _grKey);\n\n      if (!haveNormNum && units != null) {\n        updateGrKeyWStr(units, _grKey);\n      }\n    } else {\n      updateGrKeyWStr(parsedProp.strValue, _grKey);\n    }\n  } // overall style key\n  //\n\n\n  var hash = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];\n\n  for (var _i2 = 0; _i2 < propGrKeys.length; _i2++) {\n    var _grKey2 = propGrKeys[_i2];\n    var grHash = _p.styleKeys[_grKey2];\n    hash[0] = hashInt(grHash[0], hash[0]);\n    hash[1] = hashIntAlt(grHash[1], hash[1]);\n  }\n\n  _p.styleKey = combineHashes(hash[0], hash[1]); // label dims\n  //\n\n  var sk = _p.styleKeys;\n  _p.labelDimsKey = combineHashesArray(sk.labelDimensions);\n  var labelKeys = propHash(ele, ['label'], sk.labelDimensions);\n  _p.labelKey = combineHashesArray(labelKeys);\n  _p.labelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, labelKeys));\n\n  if (!isNode) {\n    var sourceLabelKeys = propHash(ele, ['source-label'], sk.labelDimensions);\n    _p.sourceLabelKey = combineHashesArray(sourceLabelKeys);\n    _p.sourceLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, sourceLabelKeys));\n    var targetLabelKeys = propHash(ele, ['target-label'], sk.labelDimensions);\n    _p.targetLabelKey = combineHashesArray(targetLabelKeys);\n    _p.targetLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, targetLabelKeys));\n  } // node\n  //\n\n\n  if (isNode) {\n    var _p$styleKeys = _p.styleKeys,\n        nodeBody = _p$styleKeys.nodeBody,\n        nodeBorder = _p$styleKeys.nodeBorder,\n        backgroundImage = _p$styleKeys.backgroundImage,\n        compound = _p$styleKeys.compound,\n        pie = _p$styleKeys.pie;\n    var nodeKeys = [nodeBody, nodeBorder, backgroundImage, compound, pie].filter(function (k) {\n      return k != null;\n    }).reduce(hashArrays, [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT]);\n    _p.nodeKey = combineHashesArray(nodeKeys);\n    _p.hasPie = pie != null && pie[0] !== DEFAULT_HASH_SEED && pie[1] !== DEFAULT_HASH_SEED_ALT;\n  }\n\n  return oldStyleKey !== _p.styleKey;\n};\n\nstyfn.clearStyleHints = function (ele) {\n  var _p = ele._private;\n  _p.styleCxtKey = '';\n  _p.styleKeys = {};\n  _p.styleKey = null;\n  _p.labelKey = null;\n  _p.labelStyleKey = null;\n  _p.sourceLabelKey = null;\n  _p.sourceLabelStyleKey = null;\n  _p.targetLabelKey = null;\n  _p.targetLabelStyleKey = null;\n  _p.nodeKey = null;\n  _p.hasPie = null;\n}; // apply a property to the style (for internal use)\n// returns whether application was successful\n//\n// now, this function flattens the property, and here's how:\n//\n// for parsedProp:{ bypass: true, deleteBypass: true }\n// no property is generated, instead the bypass property in the\n// element's style is replaced by what's pointed to by the `bypassed`\n// field in the bypass property (i.e. restoring the property the\n// bypass was overriding)\n//\n// for parsedProp:{ mapped: truthy }\n// the generated flattenedProp:{ mapping: prop }\n//\n// for parsedProp:{ bypass: true }\n// the generated flattenedProp:{ bypassed: parsedProp }\n\n\nstyfn.applyParsedProperty = function (ele, parsedProp) {\n  var self = this;\n  var prop = parsedProp;\n  var style = ele._private.style;\n  var flatProp;\n  var types = self.types;\n  var type = self.properties[prop.name].type;\n  var propIsBypass = prop.bypass;\n  var origProp = style[prop.name];\n  var origPropIsBypass = origProp && origProp.bypass;\n  var _p = ele._private;\n  var flatPropMapping = 'mapping';\n\n  var getVal = function getVal(p) {\n    if (p == null) {\n      return null;\n    } else if (p.pfValue != null) {\n      return p.pfValue;\n    } else {\n      return p.value;\n    }\n  };\n\n  var checkTriggers = function checkTriggers() {\n    var fromVal = getVal(origProp);\n    var toVal = getVal(prop);\n    self.checkTriggers(ele, prop.name, fromVal, toVal);\n  };\n\n  if (prop && prop.name.substr(0, 3) === 'pie') {\n    warn('The pie style properties are deprecated.  Create charts using background images instead.');\n  } // edge sanity checks to prevent the client from making serious mistakes\n\n\n  if (parsedProp.name === 'curve-style' && ele.isEdge() && ( // loops must be bundled beziers\n  parsedProp.value !== 'bezier' && ele.isLoop() || // edges connected to compound nodes can not be haystacks\n  parsedProp.value === 'haystack' && (ele.source().isParent() || ele.target().isParent()))) {\n    prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);\n  }\n\n  if (prop[\"delete\"]) {\n    // delete the property and use the default value on falsey value\n    style[prop.name] = undefined;\n    checkTriggers();\n    return true;\n  }\n\n  if (prop.deleteBypassed) {\n    // delete the property that the\n    if (!origProp) {\n      checkTriggers();\n      return true; // can't delete if no prop\n    } else if (origProp.bypass) {\n      // delete bypassed\n      origProp.bypassed = undefined;\n      checkTriggers();\n      return true;\n    } else {\n      return false; // we're unsuccessful deleting the bypassed\n    }\n  } // check if we need to delete the current bypass\n\n\n  if (prop.deleteBypass) {\n    // then this property is just here to indicate we need to delete\n    if (!origProp) {\n      checkTriggers();\n      return true; // property is already not defined\n    } else if (origProp.bypass) {\n      // then replace the bypass property with the original\n      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)\n      style[prop.name] = origProp.bypassed;\n      checkTriggers();\n      return true;\n    } else {\n      return false; // we're unsuccessful deleting the bypass\n    }\n  }\n\n  var printMappingErr = function printMappingErr() {\n    warn('Do not assign mappings to elements without corresponding data (i.e. ele `' + ele.id() + '` has no mapping for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');\n  }; // put the property in the style objects\n\n\n  switch (prop.mapped) {\n    // flatten the property if mapped\n    case types.mapData:\n      {\n        // flatten the field (e.g. data.foo.bar)\n        var fields = prop.field.split('.');\n        var fieldVal = _p.data;\n\n        for (var i = 0; i < fields.length && fieldVal; i++) {\n          var field = fields[i];\n          fieldVal = fieldVal[field];\n        }\n\n        if (fieldVal == null) {\n          printMappingErr();\n          return false;\n        }\n\n        var percent;\n\n        if (!number(fieldVal)) {\n          // then don't apply and fall back on the existing style\n          warn('Do not use continuous mappers without specifying numeric data (i.e. `' + prop.field + ': ' + fieldVal + '` for `' + ele.id() + '` is non-numeric)');\n          return false;\n        } else {\n          var fieldWidth = prop.fieldMax - prop.fieldMin;\n\n          if (fieldWidth === 0) {\n            // safety check -- not strictly necessary as no props of zero range should be passed here\n            percent = 0;\n          } else {\n            percent = (fieldVal - prop.fieldMin) / fieldWidth;\n          }\n        } // make sure to bound percent value\n\n\n        if (percent < 0) {\n          percent = 0;\n        } else if (percent > 1) {\n          percent = 1;\n        }\n\n        if (type.color) {\n          var r1 = prop.valueMin[0];\n          var r2 = prop.valueMax[0];\n          var g1 = prop.valueMin[1];\n          var g2 = prop.valueMax[1];\n          var b1 = prop.valueMin[2];\n          var b2 = prop.valueMax[2];\n          var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];\n          var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];\n          var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];\n          flatProp = {\n            // colours are simple, so just create the flat property instead of expensive string parsing\n            bypass: prop.bypass,\n            // we're a bypass if the mapping property is a bypass\n            name: prop.name,\n            value: clr,\n            strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'\n          };\n        } else if (type.number) {\n          var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;\n          flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);\n        } else {\n          return false; // can only map to colours and numbers\n        }\n\n        if (!flatProp) {\n          // if we can't flatten the property, then don't apply the property and fall back on the existing style\n          printMappingErr();\n          return false;\n        }\n\n        flatProp.mapping = prop; // keep a reference to the mapping\n\n        prop = flatProp; // the flattened (mapped) property is the one we want\n\n        break;\n      }\n    // direct mapping\n\n    case types.data:\n      {\n        // flatten the field (e.g. data.foo.bar)\n        var _fields = prop.field.split('.');\n\n        var _fieldVal = _p.data;\n\n        for (var _i3 = 0; _i3 < _fields.length && _fieldVal; _i3++) {\n          var _field = _fields[_i3];\n          _fieldVal = _fieldVal[_field];\n        }\n\n        if (_fieldVal != null) {\n          flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);\n        }\n\n        if (!flatProp) {\n          // if we can't flatten the property, then don't apply and fall back on the existing style\n          printMappingErr();\n          return false;\n        }\n\n        flatProp.mapping = prop; // keep a reference to the mapping\n\n        prop = flatProp; // the flattened (mapped) property is the one we want\n\n        break;\n      }\n\n    case types.fn:\n      {\n        var fn = prop.value;\n        var fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function\n\n        prop.prevFnValue = fnRetVal;\n\n        if (fnRetVal == null) {\n          warn('Custom function mappers may not return null (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is null)');\n          return false;\n        }\n\n        flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);\n\n        if (!flatProp) {\n          warn('Custom function mappers may not return invalid values for the property type (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is invalid)');\n          return false;\n        }\n\n        flatProp.mapping = copy(prop); // keep a reference to the mapping\n\n        prop = flatProp; // the flattened (mapped) property is the one we want\n\n        break;\n      }\n\n    case undefined:\n      break;\n    // just set the property\n\n    default:\n      return false;\n    // not a valid mapping\n  } // if the property is a bypass property, then link the resultant property to the original one\n\n\n  if (propIsBypass) {\n    if (origPropIsBypass) {\n      // then this bypass overrides the existing one\n      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass\n    } else {\n      // then link the orig prop to the new bypass\n      prop.bypassed = origProp;\n    }\n\n    style[prop.name] = prop; // and set\n  } else {\n    // prop is not bypass\n    if (origPropIsBypass) {\n      // then keep the orig prop (since it's a bypass) and link to the new prop\n      origProp.bypassed = prop;\n    } else {\n      // then just replace the old prop with the new one\n      style[prop.name] = prop;\n    }\n  }\n\n  checkTriggers();\n  return true;\n};\n\nstyfn.cleanElements = function (eles, keepBypasses) {\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    this.clearStyleHints(ele);\n    ele.dirtyCompoundBoundsCache();\n    ele.dirtyBoundingBoxCache();\n\n    if (!keepBypasses) {\n      ele._private.style = {};\n    } else {\n      var style = ele._private.style;\n      var propNames = Object.keys(style);\n\n      for (var j = 0; j < propNames.length; j++) {\n        var propName = propNames[j];\n        var eleProp = style[propName];\n\n        if (eleProp != null) {\n          if (eleProp.bypass) {\n            eleProp.bypassed = null;\n          } else {\n            style[propName] = null;\n          }\n        }\n      }\n    }\n  }\n}; // updates the visual style for all elements (useful for manual style modification after init)\n\n\nstyfn.update = function () {\n  var cy = this._private.cy;\n  var eles = cy.mutableElements();\n  eles.updateStyle();\n}; // diffProps : { name => { prev, next } }\n\n\nstyfn.updateTransitions = function (ele, diffProps) {\n  var self = this;\n  var _p = ele._private;\n  var props = ele.pstyle('transition-property').value;\n  var duration = ele.pstyle('transition-duration').pfValue;\n  var delay = ele.pstyle('transition-delay').pfValue;\n\n  if (props.length > 0 && duration > 0) {\n    var style = {}; // build up the style to animate towards\n\n    var anyPrev = false;\n\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      var styProp = ele.pstyle(prop);\n      var diffProp = diffProps[prop];\n\n      if (!diffProp) {\n        continue;\n      }\n\n      var prevProp = diffProp.prev;\n      var fromProp = prevProp;\n      var toProp = diffProp.next != null ? diffProp.next : styProp;\n      var diff = false;\n      var initVal = void 0;\n      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)\n\n      if (!fromProp) {\n        continue;\n      } // consider px values\n\n\n      if (number(fromProp.pfValue) && number(toProp.pfValue)) {\n        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy\n\n        initVal = fromProp.pfValue + initDt * diff; // consider numerical values\n      } else if (number(fromProp.value) && number(toProp.value)) {\n        diff = toProp.value - fromProp.value; // nonzero is truthy\n\n        initVal = fromProp.value + initDt * diff; // consider colour values\n      } else if (array(fromProp.value) && array(toProp.value)) {\n        diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];\n        initVal = fromProp.strValue;\n      } // the previous value is good for an animation only if it's different\n\n\n      if (diff) {\n        style[prop] = toProp.strValue; // to val\n\n        this.applyBypass(ele, prop, initVal); // from val\n\n        anyPrev = true;\n      }\n    } // end if props allow ani\n    // can't transition if there's nothing previous to transition from\n\n\n    if (!anyPrev) {\n      return;\n    }\n\n    _p.transitioning = true;\n    new Promise$1(function (resolve) {\n      if (delay > 0) {\n        ele.delayAnimation(delay).play().promise().then(resolve);\n      } else {\n        resolve();\n      }\n    }).then(function () {\n      return ele.animation({\n        style: style,\n        duration: duration,\n        easing: ele.pstyle('transition-timing-function').value,\n        queue: false\n      }).play().promise();\n    }).then(function () {\n      // if( !isBypass ){\n      self.removeBypasses(ele, props);\n      ele.emitAndNotify('style'); // }\n\n      _p.transitioning = false;\n    });\n  } else if (_p.transitioning) {\n    this.removeBypasses(ele, props);\n    ele.emitAndNotify('style');\n    _p.transitioning = false;\n  }\n};\n\nstyfn.checkTrigger = function (ele, name, fromValue, toValue, getTrigger, onTrigger) {\n  var prop = this.properties[name];\n  var triggerCheck = getTrigger(prop);\n\n  if (triggerCheck != null && triggerCheck(fromValue, toValue)) {\n    onTrigger(prop);\n  }\n};\n\nstyfn.checkZOrderTrigger = function (ele, name, fromValue, toValue) {\n  var _this = this;\n\n  this.checkTrigger(ele, name, fromValue, toValue, function (prop) {\n    return prop.triggersZOrder;\n  }, function () {\n    _this._private.cy.notify('zorder', ele);\n  });\n};\n\nstyfn.checkBoundsTrigger = function (ele, name, fromValue, toValue) {\n  this.checkTrigger(ele, name, fromValue, toValue, function (prop) {\n    return prop.triggersBounds;\n  }, function (prop) {\n    ele.dirtyCompoundBoundsCache();\n    ele.dirtyBoundingBoxCache(); // if the prop change makes the bb of pll bezier edges invalid,\n    // then dirty the pll edge bb cache as well\n\n    if ( // only for beziers -- so performance of other edges isn't affected\n    name === 'curve-style' && (fromValue === 'bezier' || toValue === 'bezier') && prop.triggersBoundsOfParallelBeziers) {\n      ele.parallelEdges().forEach(function (pllEdge) {\n        if (pllEdge.isBundledBezier()) {\n          pllEdge.dirtyBoundingBoxCache();\n        }\n      });\n    }\n  });\n};\n\nstyfn.checkTriggers = function (ele, name, fromValue, toValue) {\n  ele.dirtyStyleCache();\n  this.checkZOrderTrigger(ele, name, fromValue, toValue);\n  this.checkBoundsTrigger(ele, name, fromValue, toValue);\n};\n\nvar styfn$1 = {}; // bypasses are applied to an existing style on an element, and just tacked on temporarily\n// returns true iff application was successful for at least 1 specified property\n\nstyfn$1.applyBypass = function (eles, name, value, updateTransitions) {\n  var self = this;\n  var props = [];\n  var isBypass = true; // put all the properties (can specify one or many) in an array after parsing them\n\n  if (name === '*' || name === '**') {\n    // apply to all property names\n    if (value !== undefined) {\n      for (var i = 0; i < self.properties.length; i++) {\n        var prop = self.properties[i];\n        var _name = prop.name;\n        var parsedProp = this.parse(_name, value, true);\n\n        if (parsedProp) {\n          props.push(parsedProp);\n        }\n      }\n    }\n  } else if (string(name)) {\n    // then parse the single property\n    var _parsedProp = this.parse(name, value, true);\n\n    if (_parsedProp) {\n      props.push(_parsedProp);\n    }\n  } else if (plainObject(name)) {\n    // then parse each property\n    var specifiedProps = name;\n    updateTransitions = value;\n    var names = Object.keys(specifiedProps);\n\n    for (var _i = 0; _i < names.length; _i++) {\n      var _name2 = names[_i];\n      var _value = specifiedProps[_name2];\n\n      if (_value === undefined) {\n        // try camel case name too\n        _value = specifiedProps[dash2camel(_name2)];\n      }\n\n      if (_value !== undefined) {\n        var _parsedProp2 = this.parse(_name2, _value, true);\n\n        if (_parsedProp2) {\n          props.push(_parsedProp2);\n        }\n      }\n    }\n  } else {\n    // can't do anything without well defined properties\n    return false;\n  } // we've failed if there are no valid properties\n\n\n  if (props.length === 0) {\n    return false;\n  } // now, apply the bypass properties on the elements\n\n\n  var ret = false; // return true if at least one succesful bypass applied\n\n  for (var _i2 = 0; _i2 < eles.length; _i2++) {\n    // for each ele\n    var ele = eles[_i2];\n    var diffProps = {};\n    var diffProp = void 0;\n\n    for (var j = 0; j < props.length; j++) {\n      // for each prop\n      var _prop = props[j];\n\n      if (updateTransitions) {\n        var prevProp = ele.pstyle(_prop.name);\n        diffProp = diffProps[_prop.name] = {\n          prev: prevProp\n        };\n      }\n\n      ret = this.applyParsedProperty(ele, copy(_prop)) || ret;\n\n      if (updateTransitions) {\n        diffProp.next = ele.pstyle(_prop.name);\n      }\n    } // for props\n\n\n    if (ret) {\n      this.updateStyleHints(ele);\n    }\n\n    if (updateTransitions) {\n      this.updateTransitions(ele, diffProps, isBypass);\n    }\n  } // for eles\n\n\n  return ret;\n}; // only useful in specific cases like animation\n\n\nstyfn$1.overrideBypass = function (eles, name, value) {\n  name = camel2dash(name);\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    var prop = ele._private.style[name];\n    var type = this.properties[name].type;\n    var isColor = type.color;\n    var isMulti = type.mutiple;\n    var oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;\n\n    if (!prop || !prop.bypass) {\n      // need a bypass if one doesn't exist\n      this.applyBypass(ele, name, value);\n    } else {\n      prop.value = value;\n\n      if (prop.pfValue != null) {\n        prop.pfValue = value;\n      }\n\n      if (isColor) {\n        prop.strValue = 'rgb(' + value.join(',') + ')';\n      } else if (isMulti) {\n        prop.strValue = value.join(' ');\n      } else {\n        prop.strValue = '' + value;\n      }\n\n      this.updateStyleHints(ele);\n    }\n\n    this.checkTriggers(ele, name, oldValue, value);\n  }\n};\n\nstyfn$1.removeAllBypasses = function (eles, updateTransitions) {\n  return this.removeBypasses(eles, this.propertyNames, updateTransitions);\n};\n\nstyfn$1.removeBypasses = function (eles, props, updateTransitions) {\n  var isBypass = true;\n\n  for (var j = 0; j < eles.length; j++) {\n    var ele = eles[j];\n    var diffProps = {};\n\n    for (var i = 0; i < props.length; i++) {\n      var name = props[i];\n      var prop = this.properties[name];\n      var prevProp = ele.pstyle(prop.name);\n\n      if (!prevProp || !prevProp.bypass) {\n        // if a bypass doesn't exist for the prop, nothing needs to be removed\n        continue;\n      }\n\n      var value = ''; // empty => remove bypass\n\n      var parsedProp = this.parse(name, value, true);\n      var diffProp = diffProps[prop.name] = {\n        prev: prevProp\n      };\n      this.applyParsedProperty(ele, parsedProp);\n      diffProp.next = ele.pstyle(prop.name);\n    } // for props\n\n\n    this.updateStyleHints(ele);\n\n    if (updateTransitions) {\n      this.updateTransitions(ele, diffProps, isBypass);\n    }\n  } // for eles\n\n};\n\nvar styfn$2 = {}; // gets what an em size corresponds to in pixels relative to a dom element\n\nstyfn$2.getEmSizeInPixels = function () {\n  var px = this.containerCss('font-size');\n\n  if (px != null) {\n    return parseFloat(px);\n  } else {\n    return 1; // for headless\n  }\n}; // gets css property from the core container\n\n\nstyfn$2.containerCss = function (propName) {\n  var cy = this._private.cy;\n  var domElement = cy.container();\n\n  if (window$1 && domElement && window$1.getComputedStyle) {\n    return window$1.getComputedStyle(domElement).getPropertyValue(propName);\n  }\n};\n\nvar styfn$3 = {}; // gets the rendered style for an element\n\nstyfn$3.getRenderedStyle = function (ele, prop) {\n  if (prop) {\n    return this.getStylePropertyValue(ele, prop, true);\n  } else {\n    return this.getRawStyle(ele, true);\n  }\n}; // gets the raw style for an element\n\n\nstyfn$3.getRawStyle = function (ele, isRenderedVal) {\n  var self = this;\n  ele = ele[0]; // insure it's an element\n\n  if (ele) {\n    var rstyle = {};\n\n    for (var i = 0; i < self.properties.length; i++) {\n      var prop = self.properties[i];\n      var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);\n\n      if (val != null) {\n        rstyle[prop.name] = val;\n        rstyle[dash2camel(prop.name)] = val;\n      }\n    }\n\n    return rstyle;\n  }\n};\n\nstyfn$3.getIndexedStyle = function (ele, property, subproperty, index) {\n  var pstyle = ele.pstyle(property)[subproperty][index];\n  return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];\n};\n\nstyfn$3.getStylePropertyValue = function (ele, propName, isRenderedVal) {\n  var self = this;\n  ele = ele[0]; // insure it's an element\n\n  if (ele) {\n    var prop = self.properties[propName];\n\n    if (prop.alias) {\n      prop = prop.pointsTo;\n    }\n\n    var type = prop.type;\n    var styleProp = ele.pstyle(prop.name);\n\n    if (styleProp) {\n      var value = styleProp.value,\n          units = styleProp.units,\n          strValue = styleProp.strValue;\n\n      if (isRenderedVal && type.number && value != null && number(value)) {\n        var zoom = ele.cy().zoom();\n\n        var getRenderedValue = function getRenderedValue(val) {\n          return val * zoom;\n        };\n\n        var getValueStringWithUnits = function getValueStringWithUnits(val, units) {\n          return getRenderedValue(val) + units;\n        };\n\n        var isArrayValue = array(value);\n        var haveUnits = isArrayValue ? units.every(function (u) {\n          return u != null;\n        }) : units != null;\n\n        if (haveUnits) {\n          if (isArrayValue) {\n            return value.map(function (v, i) {\n              return getValueStringWithUnits(v, units[i]);\n            }).join(' ');\n          } else {\n            return getValueStringWithUnits(value, units);\n          }\n        } else {\n          if (isArrayValue) {\n            return value.map(function (v) {\n              return string(v) ? v : '' + getRenderedValue(v);\n            }).join(' ');\n          } else {\n            return '' + getRenderedValue(value);\n          }\n        }\n      } else if (strValue != null) {\n        return strValue;\n      }\n    }\n\n    return null;\n  }\n};\n\nstyfn$3.getAnimationStartStyle = function (ele, aniProps) {\n  var rstyle = {};\n\n  for (var i = 0; i < aniProps.length; i++) {\n    var aniProp = aniProps[i];\n    var name = aniProp.name;\n    var styleProp = ele.pstyle(name);\n\n    if (styleProp !== undefined) {\n      // then make a prop of it\n      if (plainObject(styleProp)) {\n        styleProp = this.parse(name, styleProp.strValue);\n      } else {\n        styleProp = this.parse(name, styleProp);\n      }\n    }\n\n    if (styleProp) {\n      rstyle[name] = styleProp;\n    }\n  }\n\n  return rstyle;\n};\n\nstyfn$3.getPropsList = function (propsObj) {\n  var self = this;\n  var rstyle = [];\n  var style = propsObj;\n  var props = self.properties;\n\n  if (style) {\n    var names = Object.keys(style);\n\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      var val = style[name];\n      var prop = props[name] || props[camel2dash(name)];\n      var styleProp = this.parse(prop.name, val);\n\n      if (styleProp) {\n        rstyle.push(styleProp);\n      }\n    }\n  }\n\n  return rstyle;\n};\n\nstyfn$3.getNonDefaultPropertiesHash = function (ele, propNames, seed) {\n  var hash = seed.slice();\n  var name, val, strVal, chVal;\n  var i, j;\n\n  for (i = 0; i < propNames.length; i++) {\n    name = propNames[i];\n    val = ele.pstyle(name, false);\n\n    if (val == null) {\n      continue;\n    } else if (val.pfValue != null) {\n      hash[0] = hashInt(chVal, hash[0]);\n      hash[1] = hashIntAlt(chVal, hash[1]);\n    } else {\n      strVal = val.strValue;\n\n      for (j = 0; j < strVal.length; j++) {\n        chVal = strVal.charCodeAt(j);\n        hash[0] = hashInt(chVal, hash[0]);\n        hash[1] = hashIntAlt(chVal, hash[1]);\n      }\n    }\n  }\n\n  return hash;\n};\n\nstyfn$3.getPropertiesHash = styfn$3.getNonDefaultPropertiesHash;\n\nvar styfn$4 = {};\n\nstyfn$4.appendFromJson = function (json) {\n  var style = this;\n\n  for (var i = 0; i < json.length; i++) {\n    var context = json[i];\n    var selector = context.selector;\n    var props = context.style || context.css;\n    var names = Object.keys(props);\n    style.selector(selector); // apply selector\n\n    for (var j = 0; j < names.length; j++) {\n      var name = names[j];\n      var value = props[name];\n      style.css(name, value); // apply property\n    }\n  }\n\n  return style;\n}; // accessible cy.style() function\n\n\nstyfn$4.fromJson = function (json) {\n  var style = this;\n  style.resetToDefault();\n  style.appendFromJson(json);\n  return style;\n}; // get json from cy.style() api\n\n\nstyfn$4.json = function () {\n  var json = [];\n\n  for (var i = this.defaultLength; i < this.length; i++) {\n    var cxt = this[i];\n    var selector = cxt.selector;\n    var props = cxt.properties;\n    var css = {};\n\n    for (var j = 0; j < props.length; j++) {\n      var prop = props[j];\n      css[prop.name] = prop.strValue;\n    }\n\n    json.push({\n      selector: !selector ? 'core' : selector.toString(),\n      style: css\n    });\n  }\n\n  return json;\n};\n\nvar styfn$5 = {};\n\nstyfn$5.appendFromString = function (string) {\n  var self = this;\n  var style = this;\n  var remaining = '' + string;\n  var selAndBlockStr;\n  var blockRem;\n  var propAndValStr; // remove comments from the style string\n\n  remaining = remaining.replace(/[/][*](\\s|.)+?[*][/]/g, '');\n\n  function removeSelAndBlockFromRemaining() {\n    // remove the parsed selector and block from the remaining text to parse\n    if (remaining.length > selAndBlockStr.length) {\n      remaining = remaining.substr(selAndBlockStr.length);\n    } else {\n      remaining = '';\n    }\n  }\n\n  function removePropAndValFromRem() {\n    // remove the parsed property and value from the remaining block text to parse\n    if (blockRem.length > propAndValStr.length) {\n      blockRem = blockRem.substr(propAndValStr.length);\n    } else {\n      blockRem = '';\n    }\n  }\n\n  for (;;) {\n    var nothingLeftToParse = remaining.match(/^\\s*$/);\n\n    if (nothingLeftToParse) {\n      break;\n    }\n\n    var selAndBlock = remaining.match(/^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/);\n\n    if (!selAndBlock) {\n      warn('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);\n      break;\n    }\n\n    selAndBlockStr = selAndBlock[0]; // parse the selector\n\n    var selectorStr = selAndBlock[1];\n\n    if (selectorStr !== 'core') {\n      var selector = new Selector(selectorStr);\n\n      if (selector.invalid) {\n        warn('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr); // skip this selector and block\n\n        removeSelAndBlockFromRemaining();\n        continue;\n      }\n    } // parse the block of properties and values\n\n\n    var blockStr = selAndBlock[2];\n    var invalidBlock = false;\n    blockRem = blockStr;\n    var props = [];\n\n    for (;;) {\n      var _nothingLeftToParse = blockRem.match(/^\\s*$/);\n\n      if (_nothingLeftToParse) {\n        break;\n      }\n\n      var propAndVal = blockRem.match(/^\\s*(.+?)\\s*:\\s*(.+?)\\s*;/);\n\n      if (!propAndVal) {\n        warn('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);\n        invalidBlock = true;\n        break;\n      }\n\n      propAndValStr = propAndVal[0];\n      var propStr = propAndVal[1];\n      var valStr = propAndVal[2];\n      var prop = self.properties[propStr];\n\n      if (!prop) {\n        warn('Skipping property: Invalid property name in: ' + propAndValStr); // skip this property in the block\n\n        removePropAndValFromRem();\n        continue;\n      }\n\n      var parsedProp = style.parse(propStr, valStr);\n\n      if (!parsedProp) {\n        warn('Skipping property: Invalid property definition in: ' + propAndValStr); // skip this property in the block\n\n        removePropAndValFromRem();\n        continue;\n      }\n\n      props.push({\n        name: propStr,\n        val: valStr\n      });\n      removePropAndValFromRem();\n    }\n\n    if (invalidBlock) {\n      removeSelAndBlockFromRemaining();\n      break;\n    } // put the parsed block in the style\n\n\n    style.selector(selectorStr);\n\n    for (var i = 0; i < props.length; i++) {\n      var _prop = props[i];\n      style.css(_prop.name, _prop.val);\n    }\n\n    removeSelAndBlockFromRemaining();\n  }\n\n  return style;\n};\n\nstyfn$5.fromString = function (string) {\n  var style = this;\n  style.resetToDefault();\n  style.appendFromString(string);\n  return style;\n};\n\nvar styfn$6 = {};\n\n(function () {\n  var number = number$1;\n  var rgba = rgbaNoBackRefs;\n  var hsla = hslaNoBackRefs;\n  var hex3$1 = hex3;\n  var hex6$1 = hex6;\n\n  var data = function data(prefix) {\n    return '^' + prefix + '\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$';\n  };\n\n  var mapData = function mapData(prefix) {\n    var mapArg = number + '|\\\\w+|' + rgba + '|' + hsla + '|' + hex3$1 + '|' + hex6$1;\n    return '^' + prefix + '\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(' + number + ')\\\\s*\\\\,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + mapArg + ')\\\\s*\\\\,\\\\s*(' + mapArg + ')\\\\)$';\n  };\n\n  var urlRegexes = ['^url\\\\s*\\\\(\\\\s*[\\'\"]?(.+?)[\\'\"]?\\\\s*\\\\)$', '^(none)$', '^(.+)$']; // each visual style property has a type and needs to be validated according to it\n\n  styfn$6.types = {\n    time: {\n      number: true,\n      min: 0,\n      units: 's|ms',\n      implicitUnits: 'ms'\n    },\n    percent: {\n      number: true,\n      min: 0,\n      max: 100,\n      units: '%',\n      implicitUnits: '%'\n    },\n    percentages: {\n      number: true,\n      min: 0,\n      max: 100,\n      units: '%',\n      implicitUnits: '%',\n      multiple: true\n    },\n    zeroOneNumber: {\n      number: true,\n      min: 0,\n      max: 1,\n      unitless: true\n    },\n    zeroOneNumbers: {\n      number: true,\n      min: 0,\n      max: 1,\n      unitless: true,\n      multiple: true\n    },\n    nOneOneNumber: {\n      number: true,\n      min: -1,\n      max: 1,\n      unitless: true\n    },\n    nonNegativeInt: {\n      number: true,\n      min: 0,\n      integer: true,\n      unitless: true\n    },\n    position: {\n      enums: ['parent', 'origin']\n    },\n    nodeSize: {\n      number: true,\n      min: 0,\n      enums: ['label']\n    },\n    number: {\n      number: true,\n      unitless: true\n    },\n    numbers: {\n      number: true,\n      unitless: true,\n      multiple: true\n    },\n    positiveNumber: {\n      number: true,\n      unitless: true,\n      min: 0,\n      strictMin: true\n    },\n    size: {\n      number: true,\n      min: 0\n    },\n    bidirectionalSize: {\n      number: true\n    },\n    // allows negative\n    bidirectionalSizeMaybePercent: {\n      number: true,\n      allowPercent: true\n    },\n    // allows negative\n    bidirectionalSizes: {\n      number: true,\n      multiple: true\n    },\n    // allows negative\n    sizeMaybePercent: {\n      number: true,\n      min: 0,\n      allowPercent: true\n    },\n    axisDirection: {\n      enums: ['horizontal', 'leftward', 'rightward', 'vertical', 'upward', 'downward', 'auto']\n    },\n    paddingRelativeTo: {\n      enums: ['width', 'height', 'average', 'min', 'max']\n    },\n    bgWH: {\n      number: true,\n      min: 0,\n      allowPercent: true,\n      enums: ['auto'],\n      multiple: true\n    },\n    bgPos: {\n      number: true,\n      allowPercent: true,\n      multiple: true\n    },\n    bgRelativeTo: {\n      enums: ['inner', 'include-padding'],\n      multiple: true\n    },\n    bgRepeat: {\n      enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'],\n      multiple: true\n    },\n    bgFit: {\n      enums: ['none', 'contain', 'cover'],\n      multiple: true\n    },\n    bgCrossOrigin: {\n      enums: ['anonymous', 'use-credentials'],\n      multiple: true\n    },\n    bgClip: {\n      enums: ['none', 'node'],\n      multiple: true\n    },\n    bgContainment: {\n      enums: ['inside', 'over'],\n      multiple: true\n    },\n    color: {\n      color: true\n    },\n    colors: {\n      color: true,\n      multiple: true\n    },\n    fill: {\n      enums: ['solid', 'linear-gradient', 'radial-gradient']\n    },\n    bool: {\n      enums: ['yes', 'no']\n    },\n    bools: {\n      enums: ['yes', 'no'],\n      multiple: true\n    },\n    lineStyle: {\n      enums: ['solid', 'dotted', 'dashed']\n    },\n    lineCap: {\n      enums: ['butt', 'round', 'square']\n    },\n    borderStyle: {\n      enums: ['solid', 'dotted', 'dashed', 'double']\n    },\n    curveStyle: {\n      enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments', 'straight', 'taxi']\n    },\n    fontFamily: {\n      regex: '^([\\\\w- \\\\\"]+(?:\\\\s*,\\\\s*[\\\\w- \\\\\"]+)*)$'\n    },\n    fontStyle: {\n      enums: ['italic', 'normal', 'oblique']\n    },\n    fontWeight: {\n      enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900]\n    },\n    textDecoration: {\n      enums: ['none', 'underline', 'overline', 'line-through']\n    },\n    textTransform: {\n      enums: ['none', 'uppercase', 'lowercase']\n    },\n    textWrap: {\n      enums: ['none', 'wrap', 'ellipsis']\n    },\n    textOverflowWrap: {\n      enums: ['whitespace', 'anywhere']\n    },\n    textBackgroundShape: {\n      enums: ['rectangle', 'roundrectangle', 'round-rectangle']\n    },\n    nodeShape: {\n      enums: ['rectangle', 'roundrectangle', 'round-rectangle', 'cutrectangle', 'cut-rectangle', 'bottomroundrectangle', 'bottom-round-rectangle', 'barrel', 'ellipse', 'triangle', 'round-triangle', 'square', 'pentagon', 'round-pentagon', 'hexagon', 'round-hexagon', 'concavehexagon', 'concave-hexagon', 'heptagon', 'round-heptagon', 'octagon', 'round-octagon', 'tag', 'round-tag', 'star', 'diamond', 'round-diamond', 'vee', 'rhomboid', 'polygon']\n    },\n    compoundIncludeLabels: {\n      enums: ['include', 'exclude']\n    },\n    arrowShape: {\n      enums: ['tee', 'triangle', 'triangle-tee', 'circle-triangle', 'triangle-cross', 'triangle-backcurve', 'vee', 'square', 'circle', 'diamond', 'chevron', 'none']\n    },\n    arrowFill: {\n      enums: ['filled', 'hollow']\n    },\n    display: {\n      enums: ['element', 'none']\n    },\n    visibility: {\n      enums: ['hidden', 'visible']\n    },\n    zCompoundDepth: {\n      enums: ['bottom', 'orphan', 'auto', 'top']\n    },\n    zIndexCompare: {\n      enums: ['auto', 'manual']\n    },\n    valign: {\n      enums: ['top', 'center', 'bottom']\n    },\n    halign: {\n      enums: ['left', 'center', 'right']\n    },\n    justification: {\n      enums: ['left', 'center', 'right', 'auto']\n    },\n    text: {\n      string: true\n    },\n    data: {\n      mapping: true,\n      regex: data('data')\n    },\n    layoutData: {\n      mapping: true,\n      regex: data('layoutData')\n    },\n    scratch: {\n      mapping: true,\n      regex: data('scratch')\n    },\n    mapData: {\n      mapping: true,\n      regex: mapData('mapData')\n    },\n    mapLayoutData: {\n      mapping: true,\n      regex: mapData('mapLayoutData')\n    },\n    mapScratch: {\n      mapping: true,\n      regex: mapData('mapScratch')\n    },\n    fn: {\n      mapping: true,\n      fn: true\n    },\n    url: {\n      regexes: urlRegexes,\n      singleRegexMatchValue: true\n    },\n    urls: {\n      regexes: urlRegexes,\n      singleRegexMatchValue: true,\n      multiple: true\n    },\n    propList: {\n      propList: true\n    },\n    angle: {\n      number: true,\n      units: 'deg|rad',\n      implicitUnits: 'rad'\n    },\n    textRotation: {\n      number: true,\n      units: 'deg|rad',\n      implicitUnits: 'rad',\n      enums: ['none', 'autorotate']\n    },\n    polygonPointList: {\n      number: true,\n      multiple: true,\n      evenMultiple: true,\n      min: -1,\n      max: 1,\n      unitless: true\n    },\n    edgeDistances: {\n      enums: ['intersection', 'node-position']\n    },\n    edgeEndpoint: {\n      number: true,\n      multiple: true,\n      units: '%|px|em|deg|rad',\n      implicitUnits: 'px',\n      enums: ['inside-to-node', 'outside-to-node', 'outside-to-node-or-label', 'outside-to-line', 'outside-to-line-or-label'],\n      singleEnum: true,\n      validate: function validate(valArr, unitsArr) {\n        switch (valArr.length) {\n          case 2:\n            // can be % or px only\n            return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';\n\n          case 1:\n            // can be enum, deg, or rad only\n            return string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';\n\n          default:\n            return false;\n        }\n      }\n    },\n    easing: {\n      regexes: ['^(spring)\\\\s*\\\\(\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*\\\\)$', '^(cubic-bezier)\\\\s*\\\\(\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*\\\\)$'],\n      enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']\n    },\n    gradientDirection: {\n      enums: ['to-bottom', 'to-top', 'to-left', 'to-right', 'to-bottom-right', 'to-bottom-left', 'to-top-right', 'to-top-left', 'to-right-bottom', 'to-left-bottom', 'to-right-top', 'to-left-top']\n    },\n    boundsExpansion: {\n      number: true,\n      multiple: true,\n      min: 0,\n      validate: function validate(valArr) {\n        var length = valArr.length;\n        return length === 1 || length === 2 || length === 4;\n      }\n    }\n  };\n  var diff = {\n    zeroNonZero: function zeroNonZero(val1, val2) {\n      if ((val1 == null || val2 == null) && val1 !== val2) {\n        return true; // null cases could represent any value\n      }\n\n      if (val1 == 0 && val2 != 0) {\n        return true;\n      } else if (val1 != 0 && val2 == 0) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n    any: function any(val1, val2) {\n      return val1 != val2;\n    },\n    emptyNonEmpty: function emptyNonEmpty(str1, str2) {\n      var empty1 = emptyString(str1);\n      var empty2 = emptyString(str2);\n      return empty1 && !empty2 || !empty1 && empty2;\n    }\n  }; // define visual style properties\n  //\n  // - n.b. adding a new group of props may require updates to updateStyleHints()\n  // - adding new props to an existing group gets handled automatically\n\n  var t = styfn$6.types;\n  var mainLabel = [{\n    name: 'label',\n    type: t.text,\n    triggersBounds: diff.any,\n    triggersZOrder: diff.emptyNonEmpty\n  }, {\n    name: 'text-rotation',\n    type: t.textRotation,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-margin-x',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-margin-y',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }];\n  var sourceLabel = [{\n    name: 'source-label',\n    type: t.text,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-text-rotation',\n    type: t.textRotation,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-text-margin-x',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-text-margin-y',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-text-offset',\n    type: t.size,\n    triggersBounds: diff.any\n  }];\n  var targetLabel = [{\n    name: 'target-label',\n    type: t.text,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-text-rotation',\n    type: t.textRotation,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-text-margin-x',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-text-margin-y',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-text-offset',\n    type: t.size,\n    triggersBounds: diff.any\n  }];\n  var labelDimensions = [{\n    name: 'font-family',\n    type: t.fontFamily,\n    triggersBounds: diff.any\n  }, {\n    name: 'font-style',\n    type: t.fontStyle,\n    triggersBounds: diff.any\n  }, {\n    name: 'font-weight',\n    type: t.fontWeight,\n    triggersBounds: diff.any\n  }, {\n    name: 'font-size',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-transform',\n    type: t.textTransform,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-wrap',\n    type: t.textWrap,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-overflow-wrap',\n    type: t.textOverflowWrap,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-max-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-outline-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'line-height',\n    type: t.positiveNumber,\n    triggersBounds: diff.any\n  }];\n  var commonLabel = [{\n    name: 'text-valign',\n    type: t.valign,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-halign',\n    type: t.halign,\n    triggersBounds: diff.any\n  }, {\n    name: 'color',\n    type: t.color\n  }, {\n    name: 'text-outline-color',\n    type: t.color\n  }, {\n    name: 'text-outline-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'text-background-color',\n    type: t.color\n  }, {\n    name: 'text-background-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'text-background-padding',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-border-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'text-border-color',\n    type: t.color\n  }, {\n    name: 'text-border-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-border-style',\n    type: t.borderStyle,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-background-shape',\n    type: t.textBackgroundShape,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-justification',\n    type: t.justification\n  }];\n  var behavior = [{\n    name: 'events',\n    type: t.bool\n  }, {\n    name: 'text-events',\n    type: t.bool\n  }];\n  var visibility = [{\n    name: 'display',\n    type: t.display,\n    triggersZOrder: diff.any,\n    triggersBounds: diff.any,\n    triggersBoundsOfParallelBeziers: true\n  }, {\n    name: 'visibility',\n    type: t.visibility,\n    triggersZOrder: diff.any\n  }, {\n    name: 'opacity',\n    type: t.zeroOneNumber,\n    triggersZOrder: diff.zeroNonZero\n  }, {\n    name: 'text-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'min-zoomed-font-size',\n    type: t.size\n  }, {\n    name: 'z-compound-depth',\n    type: t.zCompoundDepth,\n    triggersZOrder: diff.any\n  }, {\n    name: 'z-index-compare',\n    type: t.zIndexCompare,\n    triggersZOrder: diff.any\n  }, {\n    name: 'z-index',\n    type: t.nonNegativeInt,\n    triggersZOrder: diff.any\n  }];\n  var overlay = [{\n    name: 'overlay-padding',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'overlay-color',\n    type: t.color\n  }, {\n    name: 'overlay-opacity',\n    type: t.zeroOneNumber,\n    triggersBounds: diff.zeroNonZero\n  }];\n  var transition = [{\n    name: 'transition-property',\n    type: t.propList\n  }, {\n    name: 'transition-duration',\n    type: t.time\n  }, {\n    name: 'transition-delay',\n    type: t.time\n  }, {\n    name: 'transition-timing-function',\n    type: t.easing\n  }];\n\n  var nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {\n    if (parsedProp.value === 'label') {\n      return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)\n    } else {\n      return parsedProp.pfValue;\n    }\n  };\n\n  var nodeBody = [{\n    name: 'height',\n    type: t.nodeSize,\n    triggersBounds: diff.any,\n    hashOverride: nodeSizeHashOverride\n  }, {\n    name: 'width',\n    type: t.nodeSize,\n    triggersBounds: diff.any,\n    hashOverride: nodeSizeHashOverride\n  }, {\n    name: 'shape',\n    type: t.nodeShape,\n    triggersBounds: diff.any\n  }, {\n    name: 'shape-polygon-points',\n    type: t.polygonPointList,\n    triggersBounds: diff.any\n  }, {\n    name: 'background-color',\n    type: t.color\n  }, {\n    name: 'background-fill',\n    type: t.fill\n  }, {\n    name: 'background-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'background-blacken',\n    type: t.nOneOneNumber\n  }, {\n    name: 'background-gradient-stop-colors',\n    type: t.colors\n  }, {\n    name: 'background-gradient-stop-positions',\n    type: t.percentages\n  }, {\n    name: 'background-gradient-direction',\n    type: t.gradientDirection\n  }, {\n    name: 'padding',\n    type: t.sizeMaybePercent,\n    triggersBounds: diff.any\n  }, {\n    name: 'padding-relative-to',\n    type: t.paddingRelativeTo,\n    triggersBounds: diff.any\n  }, {\n    name: 'bounds-expansion',\n    type: t.boundsExpansion,\n    triggersBounds: diff.any\n  }];\n  var nodeBorder = [{\n    name: 'border-color',\n    type: t.color\n  }, {\n    name: 'border-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'border-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'border-style',\n    type: t.borderStyle\n  }];\n  var backgroundImage = [{\n    name: 'background-image',\n    type: t.urls\n  }, {\n    name: 'background-image-crossorigin',\n    type: t.bgCrossOrigin\n  }, {\n    name: 'background-image-opacity',\n    type: t.zeroOneNumbers\n  }, {\n    name: 'background-image-containment',\n    type: t.bgContainment\n  }, {\n    name: 'background-image-smoothing',\n    type: t.bools\n  }, {\n    name: 'background-position-x',\n    type: t.bgPos\n  }, {\n    name: 'background-position-y',\n    type: t.bgPos\n  }, {\n    name: 'background-width-relative-to',\n    type: t.bgRelativeTo\n  }, {\n    name: 'background-height-relative-to',\n    type: t.bgRelativeTo\n  }, {\n    name: 'background-repeat',\n    type: t.bgRepeat\n  }, {\n    name: 'background-fit',\n    type: t.bgFit\n  }, {\n    name: 'background-clip',\n    type: t.bgClip\n  }, {\n    name: 'background-width',\n    type: t.bgWH\n  }, {\n    name: 'background-height',\n    type: t.bgWH\n  }, {\n    name: 'background-offset-x',\n    type: t.bgPos\n  }, {\n    name: 'background-offset-y',\n    type: t.bgPos\n  }];\n  var compound = [{\n    name: 'position',\n    type: t.position,\n    triggersBounds: diff.any\n  }, {\n    name: 'compound-sizing-wrt-labels',\n    type: t.compoundIncludeLabels,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-width-bias-left',\n    type: t.sizeMaybePercent,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-width-bias-right',\n    type: t.sizeMaybePercent,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-height',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-height-bias-top',\n    type: t.sizeMaybePercent,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-height-bias-bottom',\n    type: t.sizeMaybePercent,\n    triggersBounds: diff.any\n  }];\n  var edgeLine = [{\n    name: 'line-style',\n    type: t.lineStyle\n  }, {\n    name: 'line-color',\n    type: t.color\n  }, {\n    name: 'line-fill',\n    type: t.fill\n  }, {\n    name: 'line-cap',\n    type: t.lineCap\n  }, {\n    name: 'line-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'line-dash-pattern',\n    type: t.numbers\n  }, {\n    name: 'line-dash-offset',\n    type: t.number\n  }, {\n    name: 'line-gradient-stop-colors',\n    type: t.colors\n  }, {\n    name: 'line-gradient-stop-positions',\n    type: t.percentages\n  }, {\n    name: 'curve-style',\n    type: t.curveStyle,\n    triggersBounds: diff.any,\n    triggersBoundsOfParallelBeziers: true\n  }, {\n    name: 'haystack-radius',\n    type: t.zeroOneNumber,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-endpoint',\n    type: t.edgeEndpoint,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-endpoint',\n    type: t.edgeEndpoint,\n    triggersBounds: diff.any\n  }, {\n    name: 'control-point-step-size',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'control-point-distances',\n    type: t.bidirectionalSizes,\n    triggersBounds: diff.any\n  }, {\n    name: 'control-point-weights',\n    type: t.numbers,\n    triggersBounds: diff.any\n  }, {\n    name: 'segment-distances',\n    type: t.bidirectionalSizes,\n    triggersBounds: diff.any\n  }, {\n    name: 'segment-weights',\n    type: t.numbers,\n    triggersBounds: diff.any\n  }, {\n    name: 'taxi-turn',\n    type: t.bidirectionalSizeMaybePercent,\n    triggersBounds: diff.any\n  }, {\n    name: 'taxi-turn-min-distance',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'taxi-direction',\n    type: t.axisDirection,\n    triggersBounds: diff.any\n  }, {\n    name: 'edge-distances',\n    type: t.edgeDistances,\n    triggersBounds: diff.any\n  }, {\n    name: 'arrow-scale',\n    type: t.positiveNumber,\n    triggersBounds: diff.any\n  }, {\n    name: 'loop-direction',\n    type: t.angle,\n    triggersBounds: diff.any\n  }, {\n    name: 'loop-sweep',\n    type: t.angle,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-distance-from-node',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-distance-from-node',\n    type: t.size,\n    triggersBounds: diff.any\n  }];\n  var ghost = [{\n    name: 'ghost',\n    type: t.bool,\n    triggersBounds: diff.any\n  }, {\n    name: 'ghost-offset-x',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'ghost-offset-y',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'ghost-opacity',\n    type: t.zeroOneNumber\n  }];\n  var core = [{\n    name: 'selection-box-color',\n    type: t.color\n  }, {\n    name: 'selection-box-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'selection-box-border-color',\n    type: t.color\n  }, {\n    name: 'selection-box-border-width',\n    type: t.size\n  }, {\n    name: 'active-bg-color',\n    type: t.color\n  }, {\n    name: 'active-bg-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'active-bg-size',\n    type: t.size\n  }, {\n    name: 'outside-texture-bg-color',\n    type: t.color\n  }, {\n    name: 'outside-texture-bg-opacity',\n    type: t.zeroOneNumber\n  }]; // pie backgrounds for nodes\n\n  var pie = [];\n  styfn$6.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)\n\n  pie.push({\n    name: 'pie-size',\n    type: t.sizeMaybePercent\n  });\n\n  for (var i = 1; i <= styfn$6.pieBackgroundN; i++) {\n    pie.push({\n      name: 'pie-' + i + '-background-color',\n      type: t.color\n    });\n    pie.push({\n      name: 'pie-' + i + '-background-size',\n      type: t.percent\n    });\n    pie.push({\n      name: 'pie-' + i + '-background-opacity',\n      type: t.zeroOneNumber\n    });\n  } // edge arrows\n\n\n  var edgeArrow = [];\n  var arrowPrefixes = styfn$6.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];\n  [{\n    name: 'arrow-shape',\n    type: t.arrowShape,\n    triggersBounds: diff.any\n  }, {\n    name: 'arrow-color',\n    type: t.color\n  }, {\n    name: 'arrow-fill',\n    type: t.arrowFill\n  }].forEach(function (prop) {\n    arrowPrefixes.forEach(function (prefix) {\n      var name = prefix + '-' + prop.name;\n      var type = prop.type,\n          triggersBounds = prop.triggersBounds;\n      edgeArrow.push({\n        name: name,\n        type: type,\n        triggersBounds: triggersBounds\n      });\n    });\n  }, {});\n  var props = styfn$6.properties = [].concat(behavior, transition, visibility, overlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, backgroundImage, pie, compound, edgeLine, edgeArrow, core);\n  var propGroups = styfn$6.propertyGroups = {\n    // common to all eles\n    behavior: behavior,\n    transition: transition,\n    visibility: visibility,\n    overlay: overlay,\n    ghost: ghost,\n    // labels\n    commonLabel: commonLabel,\n    labelDimensions: labelDimensions,\n    mainLabel: mainLabel,\n    sourceLabel: sourceLabel,\n    targetLabel: targetLabel,\n    // node props\n    nodeBody: nodeBody,\n    nodeBorder: nodeBorder,\n    backgroundImage: backgroundImage,\n    pie: pie,\n    compound: compound,\n    // edge props\n    edgeLine: edgeLine,\n    edgeArrow: edgeArrow,\n    core: core\n  };\n  var propGroupNames = styfn$6.propertyGroupNames = {};\n  var propGroupKeys = styfn$6.propertyGroupKeys = Object.keys(propGroups);\n  propGroupKeys.forEach(function (key) {\n    propGroupNames[key] = propGroups[key].map(function (prop) {\n      return prop.name;\n    });\n    propGroups[key].forEach(function (prop) {\n      return prop.groupKey = key;\n    });\n  }); // define aliases\n\n  var aliases = styfn$6.aliases = [{\n    name: 'content',\n    pointsTo: 'label'\n  }, {\n    name: 'control-point-distance',\n    pointsTo: 'control-point-distances'\n  }, {\n    name: 'control-point-weight',\n    pointsTo: 'control-point-weights'\n  }, {\n    name: 'edge-text-rotation',\n    pointsTo: 'text-rotation'\n  }, {\n    name: 'padding-left',\n    pointsTo: 'padding'\n  }, {\n    name: 'padding-right',\n    pointsTo: 'padding'\n  }, {\n    name: 'padding-top',\n    pointsTo: 'padding'\n  }, {\n    name: 'padding-bottom',\n    pointsTo: 'padding'\n  }]; // list of property names\n\n  styfn$6.propertyNames = props.map(function (p) {\n    return p.name;\n  }); // allow access of properties by name ( e.g. style.properties.height )\n\n  for (var _i = 0; _i < props.length; _i++) {\n    var prop = props[_i];\n    props[prop.name] = prop; // allow lookup by name\n  } // map aliases\n\n\n  for (var _i2 = 0; _i2 < aliases.length; _i2++) {\n    var alias = aliases[_i2];\n    var pointsToProp = props[alias.pointsTo];\n    var aliasProp = {\n      name: alias.name,\n      alias: true,\n      pointsTo: pointsToProp\n    }; // add alias prop for parsing\n\n    props.push(aliasProp);\n    props[alias.name] = aliasProp; // allow lookup by name\n  }\n})();\n\nstyfn$6.getDefaultProperty = function (name) {\n  return this.getDefaultProperties()[name];\n};\n\nstyfn$6.getDefaultProperties = function () {\n  var _p = this._private;\n\n  if (_p.defaultProperties != null) {\n    return _p.defaultProperties;\n  }\n\n  var rawProps = extend({\n    // core props\n    'selection-box-color': '#ddd',\n    'selection-box-opacity': 0.65,\n    'selection-box-border-color': '#aaa',\n    'selection-box-border-width': 1,\n    'active-bg-color': 'black',\n    'active-bg-opacity': 0.15,\n    'active-bg-size': 30,\n    'outside-texture-bg-color': '#000',\n    'outside-texture-bg-opacity': 0.125,\n    // common node/edge props\n    'events': 'yes',\n    'text-events': 'no',\n    'text-valign': 'top',\n    'text-halign': 'center',\n    'text-justification': 'auto',\n    'line-height': 1,\n    'color': '#000',\n    'text-outline-color': '#000',\n    'text-outline-width': 0,\n    'text-outline-opacity': 1,\n    'text-opacity': 1,\n    'text-decoration': 'none',\n    'text-transform': 'none',\n    'text-wrap': 'none',\n    'text-overflow-wrap': 'whitespace',\n    'text-max-width': 9999,\n    'text-background-color': '#000',\n    'text-background-opacity': 0,\n    'text-background-shape': 'rectangle',\n    'text-background-padding': 0,\n    'text-border-opacity': 0,\n    'text-border-width': 0,\n    'text-border-style': 'solid',\n    'text-border-color': '#000',\n    'font-family': 'Helvetica Neue, Helvetica, sans-serif',\n    'font-style': 'normal',\n    'font-weight': 'normal',\n    'font-size': 16,\n    'min-zoomed-font-size': 0,\n    'text-rotation': 'none',\n    'source-text-rotation': 'none',\n    'target-text-rotation': 'none',\n    'visibility': 'visible',\n    'display': 'element',\n    'opacity': 1,\n    'z-compound-depth': 'auto',\n    'z-index-compare': 'auto',\n    'z-index': 0,\n    'label': '',\n    'text-margin-x': 0,\n    'text-margin-y': 0,\n    'source-label': '',\n    'source-text-offset': 0,\n    'source-text-margin-x': 0,\n    'source-text-margin-y': 0,\n    'target-label': '',\n    'target-text-offset': 0,\n    'target-text-margin-x': 0,\n    'target-text-margin-y': 0,\n    'overlay-opacity': 0,\n    'overlay-color': '#000',\n    'overlay-padding': 10,\n    'transition-property': 'none',\n    'transition-duration': 0,\n    'transition-delay': 0,\n    'transition-timing-function': 'linear',\n    // node props\n    'background-blacken': 0,\n    'background-color': '#999',\n    'background-fill': 'solid',\n    'background-opacity': 1,\n    'background-image': 'none',\n    'background-image-crossorigin': 'anonymous',\n    'background-image-opacity': 1,\n    'background-image-containment': 'inside',\n    'background-image-smoothing': 'yes',\n    'background-position-x': '50%',\n    'background-position-y': '50%',\n    'background-offset-x': 0,\n    'background-offset-y': 0,\n    'background-width-relative-to': 'include-padding',\n    'background-height-relative-to': 'include-padding',\n    'background-repeat': 'no-repeat',\n    'background-fit': 'none',\n    'background-clip': 'node',\n    'background-width': 'auto',\n    'background-height': 'auto',\n    'border-color': '#000',\n    'border-opacity': 1,\n    'border-width': 0,\n    'border-style': 'solid',\n    'height': 30,\n    'width': 30,\n    'shape': 'ellipse',\n    'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',\n    'bounds-expansion': 0,\n    // node gradient\n    'background-gradient-direction': 'to-bottom',\n    'background-gradient-stop-colors': '#999',\n    'background-gradient-stop-positions': '0%',\n    // ghost props\n    'ghost': 'no',\n    'ghost-offset-y': 0,\n    'ghost-offset-x': 0,\n    'ghost-opacity': 0,\n    // compound props\n    'padding': 0,\n    'padding-relative-to': 'width',\n    'position': 'origin',\n    'compound-sizing-wrt-labels': 'include',\n    'min-width': 0,\n    'min-width-bias-left': 0,\n    'min-width-bias-right': 0,\n    'min-height': 0,\n    'min-height-bias-top': 0,\n    'min-height-bias-bottom': 0\n  }, {\n    // node pie bg\n    'pie-size': '100%'\n  }, [{\n    name: 'pie-{{i}}-background-color',\n    value: 'black'\n  }, {\n    name: 'pie-{{i}}-background-size',\n    value: '0%'\n  }, {\n    name: 'pie-{{i}}-background-opacity',\n    value: 1\n  }].reduce(function (css, prop) {\n    for (var i = 1; i <= styfn$6.pieBackgroundN; i++) {\n      var name = prop.name.replace('{{i}}', i);\n      var val = prop.value;\n      css[name] = val;\n    }\n\n    return css;\n  }, {}), {\n    // edge props\n    'line-style': 'solid',\n    'line-color': '#999',\n    'line-fill': 'solid',\n    'line-cap': 'butt',\n    'line-opacity': 1,\n    'line-gradient-stop-colors': '#999',\n    'line-gradient-stop-positions': '0%',\n    'control-point-step-size': 40,\n    'control-point-weights': 0.5,\n    'segment-weights': 0.5,\n    'segment-distances': 20,\n    'taxi-turn': '50%',\n    'taxi-turn-min-distance': 10,\n    'taxi-direction': 'auto',\n    'edge-distances': 'intersection',\n    'curve-style': 'haystack',\n    'haystack-radius': 0,\n    'arrow-scale': 1,\n    'loop-direction': '-45deg',\n    'loop-sweep': '-90deg',\n    'source-distance-from-node': 0,\n    'target-distance-from-node': 0,\n    'source-endpoint': 'outside-to-node',\n    'target-endpoint': 'outside-to-node',\n    'line-dash-pattern': [6, 3],\n    'line-dash-offset': 0\n  }, [{\n    name: 'arrow-shape',\n    value: 'none'\n  }, {\n    name: 'arrow-color',\n    value: '#999'\n  }, {\n    name: 'arrow-fill',\n    value: 'filled'\n  }].reduce(function (css, prop) {\n    styfn$6.arrowPrefixes.forEach(function (prefix) {\n      var name = prefix + '-' + prop.name;\n      var val = prop.value;\n      css[name] = val;\n    });\n    return css;\n  }, {}));\n  var parsedProps = {};\n\n  for (var i = 0; i < this.properties.length; i++) {\n    var prop = this.properties[i];\n\n    if (prop.pointsTo) {\n      continue;\n    }\n\n    var name = prop.name;\n    var val = rawProps[name];\n    var parsedProp = this.parse(name, val);\n    parsedProps[name] = parsedProp;\n  }\n\n  _p.defaultProperties = parsedProps;\n  return _p.defaultProperties;\n};\n\nstyfn$6.addDefaultStylesheet = function () {\n  this.selector(':parent').css({\n    'shape': 'rectangle',\n    'padding': 10,\n    'background-color': '#eee',\n    'border-color': '#ccc',\n    'border-width': 1\n  }).selector('edge').css({\n    'width': 3\n  }).selector(':loop').css({\n    'curve-style': 'bezier'\n  }).selector('edge:compound').css({\n    'curve-style': 'bezier',\n    'source-endpoint': 'outside-to-line',\n    'target-endpoint': 'outside-to-line'\n  }).selector(':selected').css({\n    'background-color': '#0169D9',\n    'line-color': '#0169D9',\n    'source-arrow-color': '#0169D9',\n    'target-arrow-color': '#0169D9',\n    'mid-source-arrow-color': '#0169D9',\n    'mid-target-arrow-color': '#0169D9'\n  }).selector(':parent:selected').css({\n    'background-color': '#CCE1F9',\n    'border-color': '#aec8e5'\n  }).selector(':active').css({\n    'overlay-color': 'black',\n    'overlay-padding': 10,\n    'overlay-opacity': 0.25\n  });\n  this.defaultLength = this.length;\n};\n\nvar styfn$7 = {}; // a caching layer for property parsing\n\nstyfn$7.parse = function (name, value, propIsBypass, propIsFlat) {\n  var self = this; // function values can't be cached in all cases, and there isn't much benefit of caching them anyway\n\n  if (fn(value)) {\n    return self.parseImplWarn(name, value, propIsBypass, propIsFlat);\n  }\n\n  var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;\n  var bypassKey = propIsBypass ? 't' : 'f';\n  var valueKey = '' + value;\n  var argHash = hashStrings(name, valueKey, bypassKey, flatKey);\n  var propCache = self.propCache = self.propCache || [];\n  var ret;\n\n  if (!(ret = propCache[argHash])) {\n    ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);\n  } // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden\n  // - mappings can't be shared b/c mappings are per-element\n\n\n  if (propIsBypass || propIsFlat === 'mapping') {\n    // need a copy since props are mutated later in their lifecycles\n    ret = copy(ret);\n\n    if (ret) {\n      ret.value = copy(ret.value); // because it could be an array, e.g. colour\n    }\n  }\n\n  return ret;\n};\n\nstyfn$7.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {\n  var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);\n\n  if (!prop && value != null) {\n    warn(\"The style property `\".concat(name, \": \").concat(value, \"` is invalid\"));\n  }\n\n  if (prop && (prop.name === 'width' || prop.name === 'height') && value === 'label') {\n    warn('The style value of `label` is deprecated for `' + prop.name + '`');\n  }\n\n  return prop;\n}; // parse a property; return null on invalid; return parsed property otherwise\n// fields :\n// - name : the name of the property\n// - value : the parsed, native-typed value of the property\n// - strValue : a string value that represents the property value in valid css\n// - bypass : true iff the property is a bypass property\n\n\nstyfn$7.parseImpl = function (name, value, propIsBypass, propIsFlat) {\n  var self = this;\n  name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')\n\n  var property = self.properties[name];\n  var passedValue = value;\n  var types = self.types;\n\n  if (!property) {\n    return null;\n  } // return null on property of unknown name\n\n\n  if (value === undefined) {\n    return null;\n  } // can't assign undefined\n  // the property may be an alias\n\n\n  if (property.alias) {\n    property = property.pointsTo;\n    name = property.name;\n  }\n\n  var valueIsString = string(value);\n\n  if (valueIsString) {\n    // trim the value to make parsing easier\n    value = value.trim();\n  }\n\n  var type = property.type;\n\n  if (!type) {\n    return null;\n  } // no type, no luck\n  // check if bypass is null or empty string (i.e. indication to delete bypass property)\n\n\n  if (propIsBypass && (value === '' || value === null)) {\n    return {\n      name: name,\n      value: value,\n      bypass: true,\n      deleteBypass: true\n    };\n  } // check if value is a function used as a mapper\n\n\n  if (fn(value)) {\n    return {\n      name: name,\n      value: value,\n      strValue: 'fn',\n      mapped: types.fn,\n      bypass: propIsBypass\n    };\n  } // check if value is mapped\n\n\n  var data, mapData;\n\n  if (!valueIsString || propIsFlat || value.length < 7 || value[1] !== 'a') ; else if (value.length >= 7 && value[0] === 'd' && (data = new RegExp(types.data.regex).exec(value))) {\n    if (propIsBypass) {\n      return false;\n    } // mappers not allowed in bypass\n\n\n    var mapped = types.data;\n    return {\n      name: name,\n      value: data,\n      strValue: '' + value,\n      mapped: mapped,\n      field: data[1],\n      bypass: propIsBypass\n    };\n  } else if (value.length >= 10 && value[0] === 'm' && (mapData = new RegExp(types.mapData.regex).exec(value))) {\n    if (propIsBypass) {\n      return false;\n    } // mappers not allowed in bypass\n\n\n    if (type.multiple) {\n      return false;\n    } // impossible to map to num\n\n\n    var _mapped = types.mapData; // we can map only if the type is a colour or a number\n\n    if (!(type.color || type.number)) {\n      return false;\n    }\n\n    var valueMin = this.parse(name, mapData[4]); // parse to validate\n\n    if (!valueMin || valueMin.mapped) {\n      return false;\n    } // can't be invalid or mapped\n\n\n    var valueMax = this.parse(name, mapData[5]); // parse to validate\n\n    if (!valueMax || valueMax.mapped) {\n      return false;\n    } // can't be invalid or mapped\n    // check if valueMin and valueMax are the same\n\n\n    if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {\n      warn('`' + name + ': ' + value + '` is not a valid mapper because the output range is zero; converting to `' + name + ': ' + valueMin.strValue + '`');\n      return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range\n    } else if (type.color) {\n      var c1 = valueMin.value;\n      var c2 = valueMax.value;\n      var same = c1[0] === c2[0] // red\n      && c1[1] === c2[1] // green\n      && c1[2] === c2[2] // blue\n      && ( // optional alpha\n      c1[3] === c2[3] // same alpha outright\n      || (c1[3] == null || c1[3] === 1) && ( // full opacity for colour 1?\n      c2[3] == null || c2[3] === 1) // full opacity for colour 2?\n      );\n\n      if (same) {\n        return false;\n      } // can't make a mapper without a range\n\n    }\n\n    return {\n      name: name,\n      value: mapData,\n      strValue: '' + value,\n      mapped: _mapped,\n      field: mapData[1],\n      fieldMin: parseFloat(mapData[2]),\n      // min & max are numeric\n      fieldMax: parseFloat(mapData[3]),\n      valueMin: valueMin.value,\n      valueMax: valueMax.value,\n      bypass: propIsBypass\n    };\n  }\n\n  if (type.multiple && propIsFlat !== 'multiple') {\n    var vals;\n\n    if (valueIsString) {\n      vals = value.split(/\\s+/);\n    } else if (array(value)) {\n      vals = value;\n    } else {\n      vals = [value];\n    }\n\n    if (type.evenMultiple && vals.length % 2 !== 0) {\n      return null;\n    }\n\n    var valArr = [];\n    var unitsArr = [];\n    var pfValArr = [];\n    var strVal = '';\n    var hasEnum = false;\n\n    for (var i = 0; i < vals.length; i++) {\n      var p = self.parse(name, vals[i], propIsBypass, 'multiple');\n      hasEnum = hasEnum || string(p.value);\n      valArr.push(p.value);\n      pfValArr.push(p.pfValue != null ? p.pfValue : p.value);\n      unitsArr.push(p.units);\n      strVal += (i > 0 ? ' ' : '') + p.strValue;\n    }\n\n    if (type.validate && !type.validate(valArr, unitsArr)) {\n      return null;\n    }\n\n    if (type.singleEnum && hasEnum) {\n      if (valArr.length === 1 && string(valArr[0])) {\n        return {\n          name: name,\n          value: valArr[0],\n          strValue: valArr[0],\n          bypass: propIsBypass\n        };\n      } else {\n        return null;\n      }\n    }\n\n    return {\n      name: name,\n      value: valArr,\n      pfValue: pfValArr,\n      strValue: strVal,\n      bypass: propIsBypass,\n      units: unitsArr\n    };\n  } // several types also allow enums\n\n\n  var checkEnums = function checkEnums() {\n    for (var _i = 0; _i < type.enums.length; _i++) {\n      var en = type.enums[_i];\n\n      if (en === value) {\n        return {\n          name: name,\n          value: value,\n          strValue: '' + value,\n          bypass: propIsBypass\n        };\n      }\n    }\n\n    return null;\n  }; // check the type and return the appropriate object\n\n\n  if (type.number) {\n    var units;\n    var implicitUnits = 'px'; // not set => px\n\n    if (type.units) {\n      // use specified units if set\n      units = type.units;\n    }\n\n    if (type.implicitUnits) {\n      implicitUnits = type.implicitUnits;\n    }\n\n    if (!type.unitless) {\n      if (valueIsString) {\n        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\\\%' : '');\n\n        if (units) {\n          unitsRegex = units;\n        } // only allow explicit units if so set\n\n\n        var match = value.match('^(' + number$1 + ')(' + unitsRegex + ')?' + '$');\n\n        if (match) {\n          value = match[1];\n          units = match[2] || implicitUnits;\n        }\n      } else if (!units || type.implicitUnits) {\n        units = implicitUnits; // implicitly px if unspecified\n      }\n    }\n\n    value = parseFloat(value); // if not a number and enums not allowed, then the value is invalid\n\n    if (isNaN(value) && type.enums === undefined) {\n      return null;\n    } // check if this number type also accepts special keywords in place of numbers\n    // (i.e. `left`, `auto`, etc)\n\n\n    if (isNaN(value) && type.enums !== undefined) {\n      value = passedValue;\n      return checkEnums();\n    } // check if value must be an integer\n\n\n    if (type.integer && !integer(value)) {\n      return null;\n    } // check value is within range\n\n\n    if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {\n      return null;\n    }\n\n    var ret = {\n      name: name,\n      value: value,\n      strValue: '' + value + (units ? units : ''),\n      units: units,\n      bypass: propIsBypass\n    }; // normalise value in pixels\n\n    if (type.unitless || units !== 'px' && units !== 'em') {\n      ret.pfValue = value;\n    } else {\n      ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;\n    } // normalise value in ms\n\n\n    if (units === 'ms' || units === 's') {\n      ret.pfValue = units === 'ms' ? value : 1000 * value;\n    } // normalise value in rad\n\n\n    if (units === 'deg' || units === 'rad') {\n      ret.pfValue = units === 'rad' ? value : deg2rad(value);\n    } // normalize value in %\n\n\n    if (units === '%') {\n      ret.pfValue = value / 100;\n    }\n\n    return ret;\n  } else if (type.propList) {\n    var props = [];\n    var propsStr = '' + value;\n\n    if (propsStr === 'none') ; else {\n      // go over each prop\n      var propsSplit = propsStr.split(/\\s*,\\s*|\\s+/);\n\n      for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {\n        var propName = propsSplit[_i2].trim();\n\n        if (self.properties[propName]) {\n          props.push(propName);\n        } else {\n          warn('`' + propName + '` is not a valid property name');\n        }\n      }\n\n      if (props.length === 0) {\n        return null;\n      }\n    }\n\n    return {\n      name: name,\n      value: props,\n      strValue: props.length === 0 ? 'none' : props.join(' '),\n      bypass: propIsBypass\n    };\n  } else if (type.color) {\n    var tuple = color2tuple(value);\n\n    if (!tuple) {\n      return null;\n    }\n\n    return {\n      name: name,\n      value: tuple,\n      pfValue: tuple,\n      strValue: 'rgb(' + tuple[0] + ',' + tuple[1] + ',' + tuple[2] + ')',\n      // n.b. no spaces b/c of multiple support\n      bypass: propIsBypass\n    };\n  } else if (type.regex || type.regexes) {\n    // first check enums\n    if (type.enums) {\n      var enumProp = checkEnums();\n\n      if (enumProp) {\n        return enumProp;\n      }\n    }\n\n    var regexes = type.regexes ? type.regexes : [type.regex];\n\n    for (var _i3 = 0; _i3 < regexes.length; _i3++) {\n      var regex = new RegExp(regexes[_i3]); // make a regex from the type string\n\n      var m = regex.exec(value);\n\n      if (m) {\n        // regex matches\n        return {\n          name: name,\n          value: type.singleRegexMatchValue ? m[1] : m,\n          strValue: '' + value,\n          bypass: propIsBypass\n        };\n      }\n    }\n\n    return null; // didn't match any\n  } else if (type.string) {\n    // just return\n    return {\n      name: name,\n      value: '' + value,\n      strValue: '' + value,\n      bypass: propIsBypass\n    };\n  } else if (type.enums) {\n    // check enums last because it's a combo type in others\n    return checkEnums();\n  } else {\n    return null; // not a type we can handle\n  }\n};\n\nvar Style = function Style(cy) {\n  if (!(this instanceof Style)) {\n    return new Style(cy);\n  }\n\n  if (!core(cy)) {\n    error('A style must have a core reference');\n    return;\n  }\n\n  this._private = {\n    cy: cy,\n    coreStyle: {}\n  };\n  this.length = 0;\n  this.resetToDefault();\n};\n\nvar styfn$8 = Style.prototype;\n\nstyfn$8.instanceString = function () {\n  return 'style';\n}; // remove all contexts\n\n\nstyfn$8.clear = function () {\n  var _p = this._private;\n  var cy = _p.cy;\n  var eles = cy.elements();\n\n  for (var i = 0; i < this.length; i++) {\n    this[i] = undefined;\n  }\n\n  this.length = 0;\n  _p.contextStyles = {};\n  _p.propDiffs = {};\n  this.cleanElements(eles, true);\n  eles.forEach(function (ele) {\n    var ele_p = ele[0]._private;\n    ele_p.styleDirty = true;\n    ele_p.appliedInitStyle = false;\n  });\n  return this; // chaining\n};\n\nstyfn$8.resetToDefault = function () {\n  this.clear();\n  this.addDefaultStylesheet();\n  return this;\n}; // builds a style object for the 'core' selector\n\n\nstyfn$8.core = function (propName) {\n  return this._private.coreStyle[propName] || this.getDefaultProperty(propName);\n}; // create a new context from the specified selector string and switch to that context\n\n\nstyfn$8.selector = function (selectorStr) {\n  // 'core' is a special case and does not need a selector\n  var selector = selectorStr === 'core' ? null : new Selector(selectorStr);\n  var i = this.length++; // new context means new index\n\n  this[i] = {\n    selector: selector,\n    properties: [],\n    mappedProperties: [],\n    index: i\n  };\n  return this; // chaining\n}; // add one or many css rules to the current context\n\n\nstyfn$8.css = function () {\n  var self = this;\n  var args = arguments;\n\n  if (args.length === 1) {\n    var map = args[0];\n\n    for (var i = 0; i < self.properties.length; i++) {\n      var prop = self.properties[i];\n      var mapVal = map[prop.name];\n\n      if (mapVal === undefined) {\n        mapVal = map[dash2camel(prop.name)];\n      }\n\n      if (mapVal !== undefined) {\n        this.cssRule(prop.name, mapVal);\n      }\n    }\n  } else if (args.length === 2) {\n    this.cssRule(args[0], args[1]);\n  } // do nothing if args are invalid\n\n\n  return this; // chaining\n};\n\nstyfn$8.style = styfn$8.css; // add a single css rule to the current context\n\nstyfn$8.cssRule = function (name, value) {\n  // name-value pair\n  var property = this.parse(name, value); // add property to current context if valid\n\n  if (property) {\n    var i = this.length - 1;\n    this[i].properties.push(property);\n    this[i].properties[property.name] = property; // allow access by name as well\n\n    if (property.name.match(/pie-(\\d+)-background-size/) && property.value) {\n      this._private.hasPie = true;\n    }\n\n    if (property.mapped) {\n      this[i].mappedProperties.push(property);\n    } // add to core style if necessary\n\n\n    var currentSelectorIsCore = !this[i].selector;\n\n    if (currentSelectorIsCore) {\n      this._private.coreStyle[property.name] = property;\n    }\n  }\n\n  return this; // chaining\n};\n\nstyfn$8.append = function (style) {\n  if (stylesheet(style)) {\n    style.appendToStyle(this);\n  } else if (array(style)) {\n    this.appendFromJson(style);\n  } else if (string(style)) {\n    this.appendFromString(style);\n  } // you probably wouldn't want to append a Style, since you'd duplicate the default parts\n\n\n  return this;\n}; // static function\n\n\nStyle.fromJson = function (cy, json) {\n  var style = new Style(cy);\n  style.fromJson(json);\n  return style;\n};\n\nStyle.fromString = function (cy, string) {\n  return new Style(cy).fromString(string);\n};\n\n[styfn, styfn$1, styfn$2, styfn$3, styfn$4, styfn$5, styfn$6, styfn$7].forEach(function (props) {\n  extend(styfn$8, props);\n});\nStyle.types = styfn$8.types;\nStyle.properties = styfn$8.properties;\nStyle.propertyGroups = styfn$8.propertyGroups;\nStyle.propertyGroupNames = styfn$8.propertyGroupNames;\nStyle.propertyGroupKeys = styfn$8.propertyGroupKeys;\n\nvar corefn$7 = {\n  style: function style(newStyle) {\n    if (newStyle) {\n      var s = this.setStyle(newStyle);\n      s.update();\n    }\n\n    return this._private.style;\n  },\n  setStyle: function setStyle(style) {\n    var _p = this._private;\n\n    if (stylesheet(style)) {\n      _p.style = style.generateStyle(this);\n    } else if (array(style)) {\n      _p.style = Style.fromJson(this, style);\n    } else if (string(style)) {\n      _p.style = Style.fromString(this, style);\n    } else {\n      _p.style = Style(this);\n    }\n\n    return _p.style;\n  },\n  // e.g. cy.data() changed => recalc ele mappers\n  updateStyle: function updateStyle() {\n    this.mutableElements().updateStyle(); // just send to all eles\n  }\n};\n\nvar defaultSelectionType = 'single';\nvar corefn$8 = {\n  autolock: function autolock(bool) {\n    if (bool !== undefined) {\n      this._private.autolock = bool ? true : false;\n    } else {\n      return this._private.autolock;\n    }\n\n    return this; // chaining\n  },\n  autoungrabify: function autoungrabify(bool) {\n    if (bool !== undefined) {\n      this._private.autoungrabify = bool ? true : false;\n    } else {\n      return this._private.autoungrabify;\n    }\n\n    return this; // chaining\n  },\n  autounselectify: function autounselectify(bool) {\n    if (bool !== undefined) {\n      this._private.autounselectify = bool ? true : false;\n    } else {\n      return this._private.autounselectify;\n    }\n\n    return this; // chaining\n  },\n  selectionType: function selectionType(selType) {\n    var _p = this._private;\n\n    if (_p.selectionType == null) {\n      _p.selectionType = defaultSelectionType;\n    }\n\n    if (selType !== undefined) {\n      if (selType === 'additive' || selType === 'single') {\n        _p.selectionType = selType;\n      }\n    } else {\n      return _p.selectionType;\n    }\n\n    return this;\n  },\n  panningEnabled: function panningEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.panningEnabled = bool ? true : false;\n    } else {\n      return this._private.panningEnabled;\n    }\n\n    return this; // chaining\n  },\n  userPanningEnabled: function userPanningEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.userPanningEnabled = bool ? true : false;\n    } else {\n      return this._private.userPanningEnabled;\n    }\n\n    return this; // chaining\n  },\n  zoomingEnabled: function zoomingEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.zoomingEnabled = bool ? true : false;\n    } else {\n      return this._private.zoomingEnabled;\n    }\n\n    return this; // chaining\n  },\n  userZoomingEnabled: function userZoomingEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.userZoomingEnabled = bool ? true : false;\n    } else {\n      return this._private.userZoomingEnabled;\n    }\n\n    return this; // chaining\n  },\n  boxSelectionEnabled: function boxSelectionEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.boxSelectionEnabled = bool ? true : false;\n    } else {\n      return this._private.boxSelectionEnabled;\n    }\n\n    return this; // chaining\n  },\n  pan: function pan() {\n    var args = arguments;\n    var pan = this._private.pan;\n    var dim, val, dims, x, y;\n\n    switch (args.length) {\n      case 0:\n        // .pan()\n        return pan;\n\n      case 1:\n        if (string(args[0])) {\n          // .pan('x')\n          dim = args[0];\n          return pan[dim];\n        } else if (plainObject(args[0])) {\n          // .pan({ x: 0, y: 100 })\n          if (!this._private.panningEnabled) {\n            return this;\n          }\n\n          dims = args[0];\n          x = dims.x;\n          y = dims.y;\n\n          if (number(x)) {\n            pan.x = x;\n          }\n\n          if (number(y)) {\n            pan.y = y;\n          }\n\n          this.emit('pan viewport');\n        }\n\n        break;\n\n      case 2:\n        // .pan('x', 100)\n        if (!this._private.panningEnabled) {\n          return this;\n        }\n\n        dim = args[0];\n        val = args[1];\n\n        if ((dim === 'x' || dim === 'y') && number(val)) {\n          pan[dim] = val;\n        }\n\n        this.emit('pan viewport');\n        break;\n      // invalid\n    }\n\n    this.notify('viewport');\n    return this; // chaining\n  },\n  panBy: function panBy(arg0, arg1) {\n    var args = arguments;\n    var pan = this._private.pan;\n    var dim, val, dims, x, y;\n\n    if (!this._private.panningEnabled) {\n      return this;\n    }\n\n    switch (args.length) {\n      case 1:\n        if (plainObject(arg0)) {\n          // .panBy({ x: 0, y: 100 })\n          dims = args[0];\n          x = dims.x;\n          y = dims.y;\n\n          if (number(x)) {\n            pan.x += x;\n          }\n\n          if (number(y)) {\n            pan.y += y;\n          }\n\n          this.emit('pan viewport');\n        }\n\n        break;\n\n      case 2:\n        // .panBy('x', 100)\n        dim = arg0;\n        val = arg1;\n\n        if ((dim === 'x' || dim === 'y') && number(val)) {\n          pan[dim] += val;\n        }\n\n        this.emit('pan viewport');\n        break;\n      // invalid\n    }\n\n    this.notify('viewport');\n    return this; // chaining\n  },\n  fit: function fit(elements, padding) {\n    var viewportState = this.getFitViewport(elements, padding);\n\n    if (viewportState) {\n      var _p = this._private;\n      _p.zoom = viewportState.zoom;\n      _p.pan = viewportState.pan;\n      this.emit('pan zoom viewport');\n      this.notify('viewport');\n    }\n\n    return this; // chaining\n  },\n  getFitViewport: function getFitViewport(elements, padding) {\n    if (number(elements) && padding === undefined) {\n      // elements is optional\n      padding = elements;\n      elements = undefined;\n    }\n\n    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n      return;\n    }\n\n    var bb;\n\n    if (string(elements)) {\n      var sel = elements;\n      elements = this.$(sel);\n    } else if (boundingBox(elements)) {\n      // assume bb\n      var bbe = elements;\n      bb = {\n        x1: bbe.x1,\n        y1: bbe.y1,\n        x2: bbe.x2,\n        y2: bbe.y2\n      };\n      bb.w = bb.x2 - bb.x1;\n      bb.h = bb.y2 - bb.y1;\n    } else if (!elementOrCollection(elements)) {\n      elements = this.mutableElements();\n    }\n\n    if (elementOrCollection(elements) && elements.empty()) {\n      return;\n    } // can't fit to nothing\n\n\n    bb = bb || elements.boundingBox();\n    var w = this.width();\n    var h = this.height();\n    var zoom;\n    padding = number(padding) ? padding : 0;\n\n    if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {\n      zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h); // crop zoom\n\n      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n      var pan = {\n        // now pan to middle\n        x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n        y: (h - zoom * (bb.y1 + bb.y2)) / 2\n      };\n      return {\n        zoom: zoom,\n        pan: pan\n      };\n    }\n\n    return;\n  },\n  zoomRange: function zoomRange(min, max) {\n    var _p = this._private;\n\n    if (max == null) {\n      var opts = min;\n      min = opts.min;\n      max = opts.max;\n    }\n\n    if (number(min) && number(max) && min <= max) {\n      _p.minZoom = min;\n      _p.maxZoom = max;\n    } else if (number(min) && max === undefined && min <= _p.maxZoom) {\n      _p.minZoom = min;\n    } else if (number(max) && min === undefined && max >= _p.minZoom) {\n      _p.maxZoom = max;\n    }\n\n    return this;\n  },\n  minZoom: function minZoom(zoom) {\n    if (zoom === undefined) {\n      return this._private.minZoom;\n    } else {\n      return this.zoomRange({\n        min: zoom\n      });\n    }\n  },\n  maxZoom: function maxZoom(zoom) {\n    if (zoom === undefined) {\n      return this._private.maxZoom;\n    } else {\n      return this.zoomRange({\n        max: zoom\n      });\n    }\n  },\n  getZoomedViewport: function getZoomedViewport(params) {\n    var _p = this._private;\n    var currentPan = _p.pan;\n    var currentZoom = _p.zoom;\n    var pos; // in rendered px\n\n    var zoom;\n    var bail = false;\n\n    if (!_p.zoomingEnabled) {\n      // zooming disabled\n      bail = true;\n    }\n\n    if (number(params)) {\n      // then set the zoom\n      zoom = params;\n    } else if (plainObject(params)) {\n      // then zoom about a point\n      zoom = params.level;\n\n      if (params.position != null) {\n        pos = modelToRenderedPosition(params.position, currentZoom, currentPan);\n      } else if (params.renderedPosition != null) {\n        pos = params.renderedPosition;\n      }\n\n      if (pos != null && !_p.panningEnabled) {\n        // panning disabled\n        bail = true;\n      }\n    } // crop zoom\n\n\n    zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;\n    zoom = zoom < _p.minZoom ? _p.minZoom : zoom; // can't zoom with invalid params\n\n    if (bail || !number(zoom) || zoom === currentZoom || pos != null && (!number(pos.x) || !number(pos.y))) {\n      return null;\n    }\n\n    if (pos != null) {\n      // set zoom about position\n      var pan1 = currentPan;\n      var zoom1 = currentZoom;\n      var zoom2 = zoom;\n      var pan2 = {\n        x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,\n        y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y\n      };\n      return {\n        zoomed: true,\n        panned: true,\n        zoom: zoom2,\n        pan: pan2\n      };\n    } else {\n      // just set the zoom\n      return {\n        zoomed: true,\n        panned: false,\n        zoom: zoom,\n        pan: currentPan\n      };\n    }\n  },\n  zoom: function zoom(params) {\n    if (params === undefined) {\n      // get\n      return this._private.zoom;\n    } else {\n      // set\n      var vp = this.getZoomedViewport(params);\n      var _p = this._private;\n\n      if (vp == null || !vp.zoomed) {\n        return this;\n      }\n\n      _p.zoom = vp.zoom;\n\n      if (vp.panned) {\n        _p.pan.x = vp.pan.x;\n        _p.pan.y = vp.pan.y;\n      }\n\n      this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');\n      this.notify('viewport');\n      return this; // chaining\n    }\n  },\n  viewport: function viewport(opts) {\n    var _p = this._private;\n    var zoomDefd = true;\n    var panDefd = true;\n    var events = []; // to trigger\n\n    var zoomFailed = false;\n    var panFailed = false;\n\n    if (!opts) {\n      return this;\n    }\n\n    if (!number(opts.zoom)) {\n      zoomDefd = false;\n    }\n\n    if (!plainObject(opts.pan)) {\n      panDefd = false;\n    }\n\n    if (!zoomDefd && !panDefd) {\n      return this;\n    }\n\n    if (zoomDefd) {\n      var z = opts.zoom;\n\n      if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {\n        zoomFailed = true;\n      } else {\n        _p.zoom = z;\n        events.push('zoom');\n      }\n    }\n\n    if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {\n      var p = opts.pan;\n\n      if (number(p.x)) {\n        _p.pan.x = p.x;\n        panFailed = false;\n      }\n\n      if (number(p.y)) {\n        _p.pan.y = p.y;\n        panFailed = false;\n      }\n\n      if (!panFailed) {\n        events.push('pan');\n      }\n    }\n\n    if (events.length > 0) {\n      events.push('viewport');\n      this.emit(events.join(' '));\n      this.notify('viewport');\n    }\n\n    return this; // chaining\n  },\n  center: function center(elements) {\n    var pan = this.getCenterPan(elements);\n\n    if (pan) {\n      this._private.pan = pan;\n      this.emit('pan viewport');\n      this.notify('viewport');\n    }\n\n    return this; // chaining\n  },\n  getCenterPan: function getCenterPan(elements, zoom) {\n    if (!this._private.panningEnabled) {\n      return;\n    }\n\n    if (string(elements)) {\n      var selector = elements;\n      elements = this.mutableElements().filter(selector);\n    } else if (!elementOrCollection(elements)) {\n      elements = this.mutableElements();\n    }\n\n    if (elements.length === 0) {\n      return;\n    } // can't centre pan to nothing\n\n\n    var bb = elements.boundingBox();\n    var w = this.width();\n    var h = this.height();\n    zoom = zoom === undefined ? this._private.zoom : zoom;\n    var pan = {\n      // middle\n      x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n      y: (h - zoom * (bb.y1 + bb.y2)) / 2\n    };\n    return pan;\n  },\n  reset: function reset() {\n    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n      return this;\n    }\n\n    this.viewport({\n      pan: {\n        x: 0,\n        y: 0\n      },\n      zoom: 1\n    });\n    return this; // chaining\n  },\n  invalidateSize: function invalidateSize() {\n    this._private.sizeCache = null;\n  },\n  size: function size() {\n    var _p = this._private;\n    var container = _p.container;\n    return _p.sizeCache = _p.sizeCache || (container ? function () {\n      var style = window$1.getComputedStyle(container);\n\n      var val = function val(name) {\n        return parseFloat(style.getPropertyValue(name));\n      };\n\n      return {\n        width: container.clientWidth - val('padding-left') - val('padding-right'),\n        height: container.clientHeight - val('padding-top') - val('padding-bottom')\n      };\n    }() : {\n      // fallback if no container (not 0 b/c can be used for dividing etc)\n      width: 1,\n      height: 1\n    });\n  },\n  width: function width() {\n    return this.size().width;\n  },\n  height: function height() {\n    return this.size().height;\n  },\n  extent: function extent() {\n    var pan = this._private.pan;\n    var zoom = this._private.zoom;\n    var rb = this.renderedExtent();\n    var b = {\n      x1: (rb.x1 - pan.x) / zoom,\n      x2: (rb.x2 - pan.x) / zoom,\n      y1: (rb.y1 - pan.y) / zoom,\n      y2: (rb.y2 - pan.y) / zoom\n    };\n    b.w = b.x2 - b.x1;\n    b.h = b.y2 - b.y1;\n    return b;\n  },\n  renderedExtent: function renderedExtent() {\n    var width = this.width();\n    var height = this.height();\n    return {\n      x1: 0,\n      y1: 0,\n      x2: width,\n      y2: height,\n      w: width,\n      h: height\n    };\n  }\n}; // aliases\n\ncorefn$8.centre = corefn$8.center; // backwards compatibility\n\ncorefn$8.autolockNodes = corefn$8.autolock;\ncorefn$8.autoungrabifyNodes = corefn$8.autoungrabify;\n\nvar fn$6 = {\n  data: define$3.data({\n    field: 'data',\n    bindingEvent: 'data',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'data',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true,\n    updateStyle: true\n  }),\n  removeData: define$3.removeData({\n    field: 'data',\n    event: 'data',\n    triggerFnName: 'trigger',\n    triggerEvent: true,\n    updateStyle: true\n  }),\n  scratch: define$3.data({\n    field: 'scratch',\n    bindingEvent: 'scratch',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'scratch',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true,\n    updateStyle: true\n  }),\n  removeScratch: define$3.removeData({\n    field: 'scratch',\n    event: 'scratch',\n    triggerFnName: 'trigger',\n    triggerEvent: true,\n    updateStyle: true\n  })\n}; // aliases\n\nfn$6.attr = fn$6.data;\nfn$6.removeAttr = fn$6.removeData;\n\nvar Core = function Core(opts) {\n  var cy = this;\n  opts = extend({}, opts);\n  var container = opts.container; // allow for passing a wrapped jquery object\n  // e.g. cytoscape({ container: $('#cy') })\n\n  if (container && !htmlElement(container) && htmlElement(container[0])) {\n    container = container[0];\n  }\n\n  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery\n\n  reg = reg || {};\n\n  if (reg && reg.cy) {\n    reg.cy.destroy();\n    reg = {}; // old instance => replace reg completely\n  }\n\n  var readies = reg.readies = reg.readies || [];\n\n  if (container) {\n    container._cyreg = reg;\n  } // make sure container assoc'd reg points to this cy\n\n\n  reg.cy = cy;\n  var head = window$1 !== undefined && container !== undefined && !opts.headless;\n  var options = opts;\n  options.layout = extend({\n    name: head ? 'grid' : 'null'\n  }, options.layout);\n  options.renderer = extend({\n    name: head ? 'canvas' : 'null'\n  }, options.renderer);\n\n  var defVal = function defVal(def, val, altVal) {\n    if (val !== undefined) {\n      return val;\n    } else if (altVal !== undefined) {\n      return altVal;\n    } else {\n      return def;\n    }\n  };\n\n  var _p = this._private = {\n    container: container,\n    // html dom ele container\n    ready: false,\n    // whether ready has been triggered\n    options: options,\n    // cached options\n    elements: new Collection(this),\n    // elements in the graph\n    listeners: [],\n    // list of listeners\n    aniEles: new Collection(this),\n    // elements being animated\n    data: options.data || {},\n    // data for the core\n    scratch: {},\n    // scratch object for core\n    layout: null,\n    renderer: null,\n    destroyed: false,\n    // whether destroy was called\n    notificationsEnabled: true,\n    // whether notifications are sent to the renderer\n    minZoom: 1e-50,\n    maxZoom: 1e50,\n    zoomingEnabled: defVal(true, options.zoomingEnabled),\n    userZoomingEnabled: defVal(true, options.userZoomingEnabled),\n    panningEnabled: defVal(true, options.panningEnabled),\n    userPanningEnabled: defVal(true, options.userPanningEnabled),\n    boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),\n    autolock: defVal(false, options.autolock, options.autolockNodes),\n    autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),\n    autounselectify: defVal(false, options.autounselectify),\n    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,\n    zoom: number(options.zoom) ? options.zoom : 1,\n    pan: {\n      x: plainObject(options.pan) && number(options.pan.x) ? options.pan.x : 0,\n      y: plainObject(options.pan) && number(options.pan.y) ? options.pan.y : 0\n    },\n    animation: {\n      // object for currently-running animations\n      current: [],\n      queue: []\n    },\n    hasCompoundNodes: false\n  };\n\n  this.createEmitter(); // set selection type\n\n  this.selectionType(options.selectionType); // init zoom bounds\n\n  this.zoomRange({\n    min: options.minZoom,\n    max: options.maxZoom\n  });\n\n  var loadExtData = function loadExtData(extData, next) {\n    var anyIsPromise = extData.some(promise);\n\n    if (anyIsPromise) {\n      return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init\n    } else {\n      next(extData); // exec synchronously for convenience\n    }\n  }; // start with the default stylesheet so we have something before loading an external stylesheet\n\n\n  if (_p.styleEnabled) {\n    cy.setStyle([]);\n  } // create the renderer\n\n\n  var rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options\n\n  cy.initRenderer(rendererOptions);\n\n  var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {\n    cy.notifications(false); // remove old elements\n\n    var oldEles = cy.mutableElements();\n\n    if (oldEles.length > 0) {\n      oldEles.remove();\n    }\n\n    if (elements != null) {\n      if (plainObject(elements) || array(elements)) {\n        cy.add(elements);\n      }\n    }\n\n    cy.one('layoutready', function (e) {\n      cy.notifications(true);\n      cy.emit(e); // we missed this event by turning notifications off, so pass it on\n\n      cy.one('load', onload);\n      cy.emitAndNotify('load');\n    }).one('layoutstop', function () {\n      cy.one('done', ondone);\n      cy.emit('done');\n    });\n    var layoutOpts = extend({}, cy._private.options.layout);\n    layoutOpts.eles = cy.elements();\n    cy.layout(layoutOpts).run();\n  };\n\n  loadExtData([options.style, options.elements], function (thens) {\n    var initStyle = thens[0];\n    var initEles = thens[1]; // init style\n\n    if (_p.styleEnabled) {\n      cy.style().append(initStyle);\n    } // initial load\n\n\n    setElesAndLayout(initEles, function () {\n      // onready\n      cy.startAnimationLoop();\n      _p.ready = true; // if a ready callback is specified as an option, the bind it\n\n      if (fn(options.ready)) {\n        cy.on('ready', options.ready);\n      } // bind all the ready handlers registered before creating this instance\n\n\n      for (var i = 0; i < readies.length; i++) {\n        var fn$1 = readies[i];\n        cy.on('ready', fn$1);\n      }\n\n      if (reg) {\n        reg.readies = [];\n      } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc\n\n\n      cy.emit('ready');\n    }, options.done);\n  });\n};\n\nvar corefn$9 = Core.prototype; // short alias\n\nextend(corefn$9, {\n  instanceString: function instanceString() {\n    return 'core';\n  },\n  isReady: function isReady() {\n    return this._private.ready;\n  },\n  destroyed: function destroyed() {\n    return this._private.destroyed;\n  },\n  ready: function ready(fn) {\n    if (this.isReady()) {\n      this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event\n    } else {\n      this.on('ready', fn);\n    }\n\n    return this;\n  },\n  destroy: function destroy() {\n    var cy = this;\n    if (cy.destroyed()) return;\n    cy.stopAnimationLoop();\n    cy.destroyRenderer();\n    this.emit('destroy');\n    cy._private.destroyed = true;\n    return cy;\n  },\n  hasElementWithId: function hasElementWithId(id) {\n    return this._private.elements.hasElementWithId(id);\n  },\n  getElementById: function getElementById(id) {\n    return this._private.elements.getElementById(id);\n  },\n  hasCompoundNodes: function hasCompoundNodes() {\n    return this._private.hasCompoundNodes;\n  },\n  headless: function headless() {\n    return this._private.renderer.isHeadless();\n  },\n  styleEnabled: function styleEnabled() {\n    return this._private.styleEnabled;\n  },\n  addToPool: function addToPool(eles) {\n    this._private.elements.merge(eles);\n\n    return this; // chaining\n  },\n  removeFromPool: function removeFromPool(eles) {\n    this._private.elements.unmerge(eles);\n\n    return this;\n  },\n  container: function container() {\n    return this._private.container || null;\n  },\n  mount: function mount(container) {\n    if (container == null) {\n      return;\n    }\n\n    var cy = this;\n    var _p = cy._private;\n    var options = _p.options;\n\n    if (!htmlElement(container) && htmlElement(container[0])) {\n      container = container[0];\n    }\n\n    cy.stopAnimationLoop();\n    cy.destroyRenderer();\n    _p.container = container;\n    _p.styleEnabled = true;\n    cy.invalidateSize();\n    cy.initRenderer(extend({}, options, options.renderer, {\n      // allow custom renderer name to be re-used, otherwise use canvas\n      name: options.renderer.name === 'null' ? 'canvas' : options.renderer.name\n    }));\n    cy.startAnimationLoop();\n    cy.style(options.style);\n    cy.emit('mount');\n    return cy;\n  },\n  unmount: function unmount() {\n    var cy = this;\n    cy.stopAnimationLoop();\n    cy.destroyRenderer();\n    cy.initRenderer({\n      name: 'null'\n    });\n    cy.emit('unmount');\n    return cy;\n  },\n  options: function options() {\n    return copy(this._private.options);\n  },\n  json: function json(obj) {\n    var cy = this;\n    var _p = cy._private;\n    var eles = cy.mutableElements();\n\n    var getFreshRef = function getFreshRef(ele) {\n      return cy.getElementById(ele.id());\n    };\n\n    if (plainObject(obj)) {\n      // set\n      cy.startBatch();\n\n      if (obj.elements) {\n        var idInJson = {};\n\n        var updateEles = function updateEles(jsons, gr) {\n          var toAdd = [];\n          var toMod = [];\n\n          for (var i = 0; i < jsons.length; i++) {\n            var json = jsons[i];\n\n            if (!json.data.id) {\n              warn('cy.json() cannot handle elements without an ID attribute');\n              continue;\n            }\n\n            var id = '' + json.data.id; // id must be string\n\n            var ele = cy.getElementById(id);\n            idInJson[id] = true;\n\n            if (ele.length !== 0) {\n              // existing element should be updated\n              toMod.push({\n                ele: ele,\n                json: json\n              });\n            } else {\n              // otherwise should be added\n              if (gr) {\n                json.group = gr;\n                toAdd.push(json);\n              } else {\n                toAdd.push(json);\n              }\n            }\n          }\n\n          cy.add(toAdd);\n\n          for (var _i = 0; _i < toMod.length; _i++) {\n            var _toMod$_i = toMod[_i],\n                _ele = _toMod$_i.ele,\n                _json = _toMod$_i.json;\n\n            _ele.json(_json);\n          }\n        };\n\n        if (array(obj.elements)) {\n          // elements: []\n          updateEles(obj.elements);\n        } else {\n          // elements: { nodes: [], edges: [] }\n          var grs = ['nodes', 'edges'];\n\n          for (var i = 0; i < grs.length; i++) {\n            var gr = grs[i];\n            var elements = obj.elements[gr];\n\n            if (array(elements)) {\n              updateEles(elements, gr);\n            }\n          }\n        }\n\n        var parentsToRemove = cy.collection();\n        eles.filter(function (ele) {\n          return !idInJson[ele.id()];\n        }).forEach(function (ele) {\n          if (ele.isParent()) {\n            parentsToRemove.merge(ele);\n          } else {\n            ele.remove();\n          }\n        }); // so that children are not removed w/parent\n\n        parentsToRemove.forEach(function (ele) {\n          return ele.children().move({\n            parent: null\n          });\n        }); // intermediate parents may be moved by prior line, so make sure we remove by fresh refs\n\n        parentsToRemove.forEach(function (ele) {\n          return getFreshRef(ele).remove();\n        });\n      }\n\n      if (obj.style) {\n        cy.style(obj.style);\n      }\n\n      if (obj.zoom != null && obj.zoom !== _p.zoom) {\n        cy.zoom(obj.zoom);\n      }\n\n      if (obj.pan) {\n        if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {\n          cy.pan(obj.pan);\n        }\n      }\n\n      if (obj.data) {\n        cy.data(obj.data);\n      }\n\n      var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify'];\n\n      for (var _i2 = 0; _i2 < fields.length; _i2++) {\n        var f = fields[_i2];\n\n        if (obj[f] != null) {\n          cy[f](obj[f]);\n        }\n      }\n\n      cy.endBatch();\n      return this; // chaining\n    } else {\n      // get\n      var flat = !!obj;\n      var json = {};\n\n      if (flat) {\n        json.elements = this.elements().map(function (ele) {\n          return ele.json();\n        });\n      } else {\n        json.elements = {};\n        eles.forEach(function (ele) {\n          var group = ele.group();\n\n          if (!json.elements[group]) {\n            json.elements[group] = [];\n          }\n\n          json.elements[group].push(ele.json());\n        });\n      }\n\n      if (this._private.styleEnabled) {\n        json.style = cy.style().json();\n      }\n\n      json.data = copy(cy.data());\n      var options = _p.options;\n      json.zoomingEnabled = _p.zoomingEnabled;\n      json.userZoomingEnabled = _p.userZoomingEnabled;\n      json.zoom = _p.zoom;\n      json.minZoom = _p.minZoom;\n      json.maxZoom = _p.maxZoom;\n      json.panningEnabled = _p.panningEnabled;\n      json.userPanningEnabled = _p.userPanningEnabled;\n      json.pan = copy(_p.pan);\n      json.boxSelectionEnabled = _p.boxSelectionEnabled;\n      json.renderer = copy(options.renderer);\n      json.hideEdgesOnViewport = options.hideEdgesOnViewport;\n      json.textureOnViewport = options.textureOnViewport;\n      json.wheelSensitivity = options.wheelSensitivity;\n      json.motionBlur = options.motionBlur;\n      return json;\n    }\n  }\n});\ncorefn$9.$id = corefn$9.getElementById;\n[corefn, corefn$1, elesfn$v, corefn$2, corefn$3, corefn$4, corefn$5, corefn$6, corefn$7, corefn$8, fn$6].forEach(function (props) {\n  extend(corefn$9, props);\n});\n\n/* eslint-disable no-unused-vars */\n\nvar defaults$9 = {\n  fit: true,\n  // whether to fit the viewport to the graph\n  directed: false,\n  // whether the tree is directed downwards (or edges can point in any direction if false)\n  padding: 30,\n  // padding on fit\n  circle: false,\n  // put depths in concentric circles if true, put depths top down if false\n  grid: false,\n  // whether to create an even grid into which the DAG is placed (circle:false only)\n  spacingFactor: 1.75,\n  // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)\n  boundingBox: undefined,\n  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true,\n  // prevents node overlap, may overflow boundingBox if not enough space\n  nodeDimensionsIncludeLabels: false,\n  // Excludes the label when calculating node bounding boxes for the layout algorithm\n  roots: undefined,\n  // the roots of the trees\n  maximal: false,\n  // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only)\n  animate: false,\n  // whether to transition the node positions\n  animationDuration: 500,\n  // duration of animation in ms if enabled\n  animationEasing: undefined,\n  // easing of animation if enabled,\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined,\n  // callback on layoutready\n  stop: undefined,\n  // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts\n\n};\n/* eslint-enable */\n\nvar getInfo = function getInfo(ele) {\n  return ele.scratch('breadthfirst');\n};\n\nvar setInfo = function setInfo(ele, obj) {\n  return ele.scratch('breadthfirst', obj);\n};\n\nfunction BreadthFirstLayout(options) {\n  this.options = extend({}, defaults$9, options);\n}\n\nBreadthFirstLayout.prototype.run = function () {\n  var params = this.options;\n  var options = params;\n  var cy = params.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes().filter(function (n) {\n    return !n.isParent();\n  });\n  var graph = eles;\n  var directed = options.directed;\n  var maximal = options.maximal || options.maximalAdjustments > 0; // maximalAdjustments for compat. w/ old code\n\n  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0,\n    y1: 0,\n    w: cy.width(),\n    h: cy.height()\n  });\n  var roots;\n\n  if (elementOrCollection(options.roots)) {\n    roots = options.roots;\n  } else if (array(options.roots)) {\n    var rootsArray = [];\n\n    for (var i = 0; i < options.roots.length; i++) {\n      var id = options.roots[i];\n      var ele = cy.getElementById(id);\n      rootsArray.push(ele);\n    }\n\n    roots = cy.collection(rootsArray);\n  } else if (string(options.roots)) {\n    roots = cy.$(options.roots);\n  } else {\n    if (directed) {\n      roots = nodes.roots();\n    } else {\n      var components = eles.components();\n      roots = cy.collection();\n\n      var _loop = function _loop(_i) {\n        var comp = components[_i];\n        var maxDegree = comp.maxDegree(false);\n        var compRoots = comp.filter(function (ele) {\n          return ele.degree(false) === maxDegree;\n        });\n        roots = roots.add(compRoots);\n      };\n\n      for (var _i = 0; _i < components.length; _i++) {\n        _loop(_i);\n      }\n    }\n  }\n\n  var depths = [];\n  var foundByBfs = {};\n\n  var addToDepth = function addToDepth(ele, d) {\n    if (depths[d] == null) {\n      depths[d] = [];\n    }\n\n    var i = depths[d].length;\n    depths[d].push(ele);\n    setInfo(ele, {\n      index: i,\n      depth: d\n    });\n  };\n\n  var changeDepth = function changeDepth(ele, newDepth) {\n    var _getInfo = getInfo(ele),\n        depth = _getInfo.depth,\n        index = _getInfo.index;\n\n    depths[depth][index] = null;\n    addToDepth(ele, newDepth);\n  }; // find the depths of the nodes\n\n\n  graph.bfs({\n    roots: roots,\n    directed: options.directed,\n    visit: function visit(node, edge, pNode, i, depth) {\n      var ele = node[0];\n      var id = ele.id();\n      addToDepth(ele, depth);\n      foundByBfs[id] = true;\n    }\n  }); // check for nodes not found by bfs\n\n  var orphanNodes = [];\n\n  for (var _i2 = 0; _i2 < nodes.length; _i2++) {\n    var _ele = nodes[_i2];\n\n    if (foundByBfs[_ele.id()]) {\n      continue;\n    } else {\n      orphanNodes.push(_ele);\n    }\n  } // assign the nodes a depth and index\n\n\n  var assignDepthsAt = function assignDepthsAt(i) {\n    var eles = depths[i];\n\n    for (var j = 0; j < eles.length; j++) {\n      var _ele2 = eles[j];\n\n      if (_ele2 == null) {\n        eles.splice(j, 1);\n        j--;\n        continue;\n      }\n\n      setInfo(_ele2, {\n        depth: i,\n        index: j\n      });\n    }\n  };\n\n  var assignDepths = function assignDepths() {\n    for (var _i3 = 0; _i3 < depths.length; _i3++) {\n      assignDepthsAt(_i3);\n    }\n  };\n\n  var adjustMaximally = function adjustMaximally(ele, shifted) {\n    var eInfo = getInfo(ele);\n    var incomers = ele.incomers().filter(function (el) {\n      return el.isNode() && eles.has(el);\n    });\n    var maxDepth = -1;\n    var id = ele.id();\n\n    for (var k = 0; k < incomers.length; k++) {\n      var incmr = incomers[k];\n      var iInfo = getInfo(incmr);\n      maxDepth = Math.max(maxDepth, iInfo.depth);\n    }\n\n    if (eInfo.depth <= maxDepth) {\n      if (shifted[id]) {\n        return null;\n      }\n\n      changeDepth(ele, maxDepth + 1);\n      shifted[id] = true;\n      return true;\n    }\n\n    return false;\n  }; // for the directed case, try to make the edges all go down (i.e. depth i => depth i + 1)\n\n\n  if (directed && maximal) {\n    var Q = [];\n    var shifted = {};\n\n    var enqueue = function enqueue(n) {\n      return Q.push(n);\n    };\n\n    var dequeue = function dequeue() {\n      return Q.shift();\n    };\n\n    nodes.forEach(function (n) {\n      return Q.push(n);\n    });\n\n    while (Q.length > 0) {\n      var _ele3 = dequeue();\n\n      var didShift = adjustMaximally(_ele3, shifted);\n\n      if (didShift) {\n        _ele3.outgoers().filter(function (el) {\n          return el.isNode() && eles.has(el);\n        }).forEach(enqueue);\n      } else if (didShift === null) {\n        warn('Detected double maximal shift for node `' + _ele3.id() + '`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.');\n        break; // exit on failure\n      }\n    }\n  }\n\n  assignDepths(); // clear holes\n  // find min distance we need to leave between nodes\n\n  var minDistance = 0;\n\n  if (options.avoidOverlap) {\n    for (var _i4 = 0; _i4 < nodes.length; _i4++) {\n      var n = nodes[_i4];\n      var nbb = n.layoutDimensions(options);\n      var w = nbb.w;\n      var h = nbb.h;\n      minDistance = Math.max(minDistance, w, h);\n    }\n  } // get the weighted percent for an element based on its connectivity to other levels\n\n\n  var cachedWeightedPercent = {};\n\n  var getWeightedPercent = function getWeightedPercent(ele) {\n    if (cachedWeightedPercent[ele.id()]) {\n      return cachedWeightedPercent[ele.id()];\n    }\n\n    var eleDepth = getInfo(ele).depth;\n    var neighbors = ele.neighborhood();\n    var percent = 0;\n    var samples = 0;\n\n    for (var _i5 = 0; _i5 < neighbors.length; _i5++) {\n      var neighbor = neighbors[_i5];\n\n      if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) {\n        continue;\n      }\n\n      var bf = getInfo(neighbor);\n\n      if (bf == null) {\n        continue;\n      }\n\n      var index = bf.index;\n      var depth = bf.depth; // unassigned neighbours shouldn't affect the ordering\n\n      if (index == null || depth == null) {\n        continue;\n      }\n\n      var nDepth = depths[depth].length;\n\n      if (depth < eleDepth) {\n        // only get influenced by elements above\n        percent += index / nDepth;\n        samples++;\n      }\n    }\n\n    samples = Math.max(1, samples);\n    percent = percent / samples;\n\n    if (samples === 0) {\n      // put lone nodes at the start\n      percent = 0;\n    }\n\n    cachedWeightedPercent[ele.id()] = percent;\n    return percent;\n  }; // rearrange the indices in each depth level based on connectivity\n\n\n  var sortFn = function sortFn(a, b) {\n    var apct = getWeightedPercent(a);\n    var bpct = getWeightedPercent(b);\n    var diff = apct - bpct;\n\n    if (diff === 0) {\n      return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons\n    } else {\n      return diff;\n    }\n  }; // sort each level to make connected nodes closer\n\n\n  for (var _i6 = 0; _i6 < depths.length; _i6++) {\n    depths[_i6].sort(sortFn);\n\n    assignDepthsAt(_i6);\n  } // assign orphan nodes to a new top-level depth\n\n\n  var orphanDepth = [];\n\n  for (var _i7 = 0; _i7 < orphanNodes.length; _i7++) {\n    orphanDepth.push(orphanNodes[_i7]);\n  }\n\n  depths.unshift(orphanDepth);\n  assignDepths();\n  var biggestDepthSize = 0;\n\n  for (var _i8 = 0; _i8 < depths.length; _i8++) {\n    biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);\n  }\n\n  var center = {\n    x: bb.x1 + bb.w / 2,\n    y: bb.x1 + bb.h / 2\n  };\n  var maxDepthSize = depths.reduce(function (max, eles) {\n    return Math.max(max, eles.length);\n  }, 0);\n\n  var getPosition = function getPosition(ele) {\n    var _getInfo2 = getInfo(ele),\n        depth = _getInfo2.depth,\n        index = _getInfo2.index;\n\n    var depthSize = depths[depth].length;\n    var distanceX = Math.max(bb.w / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);\n    var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);\n    var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);\n    radiusStepSize = Math.max(radiusStepSize, minDistance);\n\n    if (!options.circle) {\n      var epos = {\n        x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n        y: (depth + 1) * distanceY\n      };\n      return epos;\n    } else {\n      var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);\n      var theta = 2 * Math.PI / depths[depth].length * index;\n\n      if (depth === 0 && depths[0].length === 1) {\n        radius = 1;\n      }\n\n      return {\n        x: center.x + radius * Math.cos(theta),\n        y: center.y + radius * Math.sin(theta)\n      };\n    }\n  };\n\n  eles.nodes().layoutPositions(this, options, getPosition);\n  return this; // chaining\n};\n\nvar defaults$a = {\n  fit: true,\n  // whether to fit the viewport to the graph\n  padding: 30,\n  // the padding on fit\n  boundingBox: undefined,\n  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true,\n  // prevents node overlap, may overflow boundingBox and radius if not enough space\n  nodeDimensionsIncludeLabels: false,\n  // Excludes the label when calculating node bounding boxes for the layout algorithm\n  spacingFactor: undefined,\n  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n  radius: undefined,\n  // the radius of the circle\n  startAngle: 3 / 2 * Math.PI,\n  // where nodes start in radians\n  sweep: undefined,\n  // how many radians should be between the first and last node (defaults to full circle)\n  clockwise: true,\n  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n  sort: undefined,\n  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n  animate: false,\n  // whether to transition the node positions\n  animationDuration: 500,\n  // duration of animation in ms if enabled\n  animationEasing: undefined,\n  // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined,\n  // callback on layoutready\n  stop: undefined,\n  // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts \n\n};\n\nfunction CircleLayout(options) {\n  this.options = extend({}, defaults$a, options);\n}\n\nCircleLayout.prototype.run = function () {\n  var params = this.options;\n  var options = params;\n  var cy = params.cy;\n  var eles = options.eles;\n  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n  var nodes = eles.nodes().not(':parent');\n\n  if (options.sort) {\n    nodes = nodes.sort(options.sort);\n  }\n\n  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0,\n    y1: 0,\n    w: cy.width(),\n    h: cy.height()\n  });\n  var center = {\n    x: bb.x1 + bb.w / 2,\n    y: bb.y1 + bb.h / 2\n  };\n  var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;\n  var dTheta = sweep / Math.max(1, nodes.length - 1);\n  var r;\n  var minDistance = 0;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    var nbb = n.layoutDimensions(options);\n    var w = nbb.w;\n    var h = nbb.h;\n    minDistance = Math.max(minDistance, w, h);\n  }\n\n  if (number(options.radius)) {\n    r = options.radius;\n  } else if (nodes.length <= 1) {\n    r = 0;\n  } else {\n    r = Math.min(bb.h, bb.w) / 2 - minDistance;\n  } // calculate the radius\n\n\n  if (nodes.length > 1 && options.avoidOverlap) {\n    // but only if more than one node (can't overlap)\n    minDistance *= 1.75; // just to have some nice spacing\n\n    var dcos = Math.cos(dTheta) - Math.cos(0);\n    var dsin = Math.sin(dTheta) - Math.sin(0);\n    var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n    r = Math.max(rMin, r);\n  }\n\n  var getPos = function getPos(ele, i) {\n    var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);\n    var rx = r * Math.cos(theta);\n    var ry = r * Math.sin(theta);\n    var pos = {\n      x: center.x + rx,\n      y: center.y + ry\n    };\n    return pos;\n  };\n\n  eles.nodes().layoutPositions(this, options, getPos);\n  return this; // chaining\n};\n\nvar defaults$b = {\n  fit: true,\n  // whether to fit the viewport to the graph\n  padding: 30,\n  // the padding on fit\n  startAngle: 3 / 2 * Math.PI,\n  // where nodes start in radians\n  sweep: undefined,\n  // how many radians should be between the first and last node (defaults to full circle)\n  clockwise: true,\n  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n  equidistant: false,\n  // whether levels have an equal radial distance betwen them, may cause bounding box overflow\n  minNodeSpacing: 10,\n  // min spacing between outside of nodes (used for radius adjustment)\n  boundingBox: undefined,\n  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true,\n  // prevents node overlap, may overflow boundingBox if not enough space\n  nodeDimensionsIncludeLabels: false,\n  // Excludes the label when calculating node bounding boxes for the layout algorithm\n  height: undefined,\n  // height of layout area (overrides container height)\n  width: undefined,\n  // width of layout area (overrides container width)\n  spacingFactor: undefined,\n  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n  concentric: function concentric(node) {\n    // returns numeric value for each node, placing higher nodes in levels towards the centre\n    return node.degree();\n  },\n  levelWidth: function levelWidth(nodes) {\n    // the variation of concentric values in each level\n    return nodes.maxDegree() / 4;\n  },\n  animate: false,\n  // whether to transition the node positions\n  animationDuration: 500,\n  // duration of animation in ms if enabled\n  animationEasing: undefined,\n  // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined,\n  // callback on layoutready\n  stop: undefined,\n  // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts\n\n};\n\nfunction ConcentricLayout(options) {\n  this.options = extend({}, defaults$b, options);\n}\n\nConcentricLayout.prototype.run = function () {\n  var params = this.options;\n  var options = params;\n  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n  var cy = params.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes().not(':parent');\n  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0,\n    y1: 0,\n    w: cy.width(),\n    h: cy.height()\n  });\n  var center = {\n    x: bb.x1 + bb.w / 2,\n    y: bb.y1 + bb.h / 2\n  };\n  var nodeValues = []; // { node, value }\n\n  var maxNodeSize = 0;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var value = void 0; // calculate the node value\n\n    value = options.concentric(node);\n    nodeValues.push({\n      value: value,\n      node: node\n    }); // for style mapping\n\n    node._private.scratch.concentric = value;\n  } // in case we used the `concentric` in style\n\n\n  nodes.updateStyle(); // calculate max size now based on potentially updated mappers\n\n  for (var _i = 0; _i < nodes.length; _i++) {\n    var _node = nodes[_i];\n\n    var nbb = _node.layoutDimensions(options);\n\n    maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);\n  } // sort node values in descreasing order\n\n\n  nodeValues.sort(function (a, b) {\n    return b.value - a.value;\n  });\n  var levelWidth = options.levelWidth(nodes); // put the values into levels\n\n  var levels = [[]];\n  var currentLevel = levels[0];\n\n  for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {\n    var val = nodeValues[_i2];\n\n    if (currentLevel.length > 0) {\n      var diff = Math.abs(currentLevel[0].value - val.value);\n\n      if (diff >= levelWidth) {\n        currentLevel = [];\n        levels.push(currentLevel);\n      }\n    }\n\n    currentLevel.push(val);\n  } // create positions from levels\n\n\n  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes\n\n  if (!options.avoidOverlap) {\n    // then strictly constrain to bb\n    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n    var maxR = Math.min(bb.w, bb.h) / 2 - minDist;\n    var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);\n    minDist = Math.min(minDist, rStep);\n  } // find the metrics for each level\n\n\n  var r = 0;\n\n  for (var _i3 = 0; _i3 < levels.length; _i3++) {\n    var level = levels[_i3];\n    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;\n    var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius\n\n    if (level.length > 1 && options.avoidOverlap) {\n      // but only if more than one node (can't overlap)\n      var dcos = Math.cos(dTheta) - Math.cos(0);\n      var dsin = Math.sin(dTheta) - Math.sin(0);\n      var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n      r = Math.max(rMin, r);\n    }\n\n    level.r = r;\n    r += minDist;\n  }\n\n  if (options.equidistant) {\n    var rDeltaMax = 0;\n    var _r = 0;\n\n    for (var _i4 = 0; _i4 < levels.length; _i4++) {\n      var _level = levels[_i4];\n      var rDelta = _level.r - _r;\n      rDeltaMax = Math.max(rDeltaMax, rDelta);\n    }\n\n    _r = 0;\n\n    for (var _i5 = 0; _i5 < levels.length; _i5++) {\n      var _level2 = levels[_i5];\n\n      if (_i5 === 0) {\n        _r = _level2.r;\n      }\n\n      _level2.r = _r;\n      _r += rDeltaMax;\n    }\n  } // calculate the node positions\n\n\n  var pos = {}; // id => position\n\n  for (var _i6 = 0; _i6 < levels.length; _i6++) {\n    var _level3 = levels[_i6];\n    var _dTheta = _level3.dTheta;\n    var _r2 = _level3.r;\n\n    for (var j = 0; j < _level3.length; j++) {\n      var _val = _level3[j];\n      var theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;\n      var p = {\n        x: center.x + _r2 * Math.cos(theta),\n        y: center.y + _r2 * Math.sin(theta)\n      };\n      pos[_val.node.id()] = p;\n    }\n  } // position the nodes\n\n\n  eles.nodes().layoutPositions(this, options, function (ele) {\n    var id = ele.id();\n    return pos[id];\n  });\n  return this; // chaining\n};\n\n/*\nThe CoSE layout was written by Gerardo Huck.\nhttps://www.linkedin.com/in/gerardohuck/\n\nBased on the following article:\nhttp://dl.acm.org/citation.cfm?id=1498047\n\nModifications tracked on Github.\n*/\nvar DEBUG;\n/**\n * @brief :  default layout options\n */\n\nvar defaults$c = {\n  // Called on `layoutready`\n  ready: function ready() {},\n  // Called on `layoutstop`\n  stop: function stop() {},\n  // Whether to animate while running the layout\n  // true : Animate continuously as the layout is running\n  // false : Just show the end result\n  // 'end' : Animate with the end result, from the initial positions to the end positions\n  animate: true,\n  // Easing of the animation for animate:'end'\n  animationEasing: undefined,\n  // The duration of the animation for animate:'end'\n  animationDuration: undefined,\n  // A function that determines whether the node should be animated\n  // All nodes animated by default on animate enabled\n  // Non-animated nodes are positioned immediately when the layout starts\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // The layout animates only after this many milliseconds for animate:true\n  // (prevents flashing on fast runs)\n  animationThreshold: 250,\n  // Number of iterations between consecutive screen positions update\n  refresh: 20,\n  // Whether to fit the network view after when done\n  fit: true,\n  // Padding on fit\n  padding: 30,\n  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  boundingBox: undefined,\n  // Excludes the label when calculating node bounding boxes for the layout algorithm\n  nodeDimensionsIncludeLabels: false,\n  // Randomize the initial positions of the nodes (true) or use existing positions (false)\n  randomize: false,\n  // Extra spacing between components in non-compound graphs\n  componentSpacing: 40,\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: function nodeRepulsion(node) {\n    return 2048;\n  },\n  // Node repulsion (overlapping) multiplier\n  nodeOverlap: 4,\n  // Ideal edge (non nested) length\n  idealEdgeLength: function idealEdgeLength(edge) {\n    return 32;\n  },\n  // Divisor to compute edge forces\n  edgeElasticity: function edgeElasticity(edge) {\n    return 32;\n  },\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 1.2,\n  // Gravity force (constant)\n  gravity: 1,\n  // Maximum number of iterations to perform\n  numIter: 1000,\n  // Initial temperature (maximum node displacement)\n  initialTemp: 1000,\n  // Cooling factor (how the temperature is reduced between consecutive iterations\n  coolingFactor: 0.99,\n  // Lower temperature threshold (below this point the layout will end)\n  minTemp: 1.0\n};\n/**\n * @brief       : constructor\n * @arg options : object containing layout options\n */\n\nfunction CoseLayout(options) {\n  this.options = extend({}, defaults$c, options);\n  this.options.layout = this;\n}\n/**\n * @brief : runs the layout\n */\n\n\nCoseLayout.prototype.run = function () {\n  var options = this.options;\n  var cy = options.cy;\n  var layout = this;\n  layout.stopped = false;\n\n  if (options.animate === true || options.animate === false) {\n    layout.emit({\n      type: 'layoutstart',\n      layout: layout\n    });\n  } // Set DEBUG - Global variable\n\n\n  if (true === options.debug) {\n    DEBUG = true;\n  } else {\n    DEBUG = false;\n  } // Initialize layout info\n\n\n  var layoutInfo = createLayoutInfo(cy, layout, options); // Show LayoutInfo contents if debugging\n\n  if (DEBUG) {\n    printLayoutInfo(layoutInfo);\n  } // If required, randomize node positions\n\n\n  if (options.randomize) {\n    randomizePositions(layoutInfo);\n  }\n\n  var startTime = performanceNow();\n\n  var refresh = function refresh() {\n    refreshPositions(layoutInfo, cy, options); // Fit the graph if necessary\n\n    if (true === options.fit) {\n      cy.fit(options.padding);\n    }\n  };\n\n  var mainLoop = function mainLoop(i) {\n    if (layout.stopped || i >= options.numIter) {\n      // logDebug(\"Layout manually stopped. Stopping computation in step \" + i);\n      return false;\n    } // Do one step in the phisical simulation\n\n\n    step$1(layoutInfo, options); // Update temperature\n\n    layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor; // logDebug(\"New temperature: \" + layoutInfo.temperature);\n\n    if (layoutInfo.temperature < options.minTemp) {\n      // logDebug(\"Temperature drop below minimum threshold. Stopping computation in step \" + i);\n      return false;\n    }\n\n    return true;\n  };\n\n  var done = function done() {\n    if (options.animate === true || options.animate === false) {\n      refresh(); // Layout has finished\n\n      layout.one('layoutstop', options.stop);\n      layout.emit({\n        type: 'layoutstop',\n        layout: layout\n      });\n    } else {\n      var nodes = options.eles.nodes();\n      var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n      nodes.layoutPositions(layout, options, getScaledPos);\n    }\n  };\n\n  var i = 0;\n  var loopRet = true;\n\n  if (options.animate === true) {\n    var frame = function frame() {\n      var f = 0;\n\n      while (loopRet && f < options.refresh) {\n        loopRet = mainLoop(i);\n        i++;\n        f++;\n      }\n\n      if (!loopRet) {\n        // it's done\n        separateComponents(layoutInfo, options);\n        done();\n      } else {\n        var now = performanceNow();\n\n        if (now - startTime >= options.animationThreshold) {\n          refresh();\n        }\n\n        requestAnimationFrame(frame);\n      }\n    };\n\n    frame();\n  } else {\n    while (loopRet) {\n      loopRet = mainLoop(i);\n      i++;\n    }\n\n    separateComponents(layoutInfo, options);\n    done();\n  }\n\n  return this; // chaining\n};\n/**\n * @brief : called on continuous layouts to stop them before they finish\n */\n\n\nCoseLayout.prototype.stop = function () {\n  this.stopped = true;\n\n  if (this.thread) {\n    this.thread.stop();\n  }\n\n  this.emit('layoutstop');\n  return this; // chaining\n};\n\nCoseLayout.prototype.destroy = function () {\n  if (this.thread) {\n    this.thread.stop();\n  }\n\n  return this; // chaining\n};\n/**\n * @brief     : Creates an object which is contains all the data\n *              used in the layout process\n * @arg cy    : cytoscape.js object\n * @return    : layoutInfo object initialized\n */\n\n\nvar createLayoutInfo = function createLayoutInfo(cy, layout, options) {\n  // Shortcut\n  var edges = options.eles.edges();\n  var nodes = options.eles.nodes();\n  var layoutInfo = {\n    isCompound: cy.hasCompoundNodes(),\n    layoutNodes: [],\n    idToIndex: {},\n    nodeSize: nodes.size(),\n    graphSet: [],\n    indexToGraph: [],\n    layoutEdges: [],\n    edgeSize: edges.size(),\n    temperature: options.initialTemp,\n    clientWidth: cy.width(),\n    clientHeight: cy.width(),\n    boundingBox: makeBoundingBox(options.boundingBox ? options.boundingBox : {\n      x1: 0,\n      y1: 0,\n      w: cy.width(),\n      h: cy.height()\n    })\n  };\n  var components = options.eles.components();\n  var id2cmptId = {};\n\n  for (var i = 0; i < components.length; i++) {\n    var component = components[i];\n\n    for (var j = 0; j < component.length; j++) {\n      var node = component[j];\n      id2cmptId[node.id()] = i;\n    }\n  } // Iterate over all nodes, creating layout nodes\n\n\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = nodes[i];\n    var nbb = n.layoutDimensions(options);\n    var tempNode = {};\n    tempNode.isLocked = n.locked();\n    tempNode.id = n.data('id');\n    tempNode.parentId = n.data('parent');\n    tempNode.cmptId = id2cmptId[n.id()];\n    tempNode.children = [];\n    tempNode.positionX = n.position('x');\n    tempNode.positionY = n.position('y');\n    tempNode.offsetX = 0;\n    tempNode.offsetY = 0;\n    tempNode.height = nbb.w;\n    tempNode.width = nbb.h;\n    tempNode.maxX = tempNode.positionX + tempNode.width / 2;\n    tempNode.minX = tempNode.positionX - tempNode.width / 2;\n    tempNode.maxY = tempNode.positionY + tempNode.height / 2;\n    tempNode.minY = tempNode.positionY - tempNode.height / 2;\n    tempNode.padLeft = parseFloat(n.style('padding'));\n    tempNode.padRight = parseFloat(n.style('padding'));\n    tempNode.padTop = parseFloat(n.style('padding'));\n    tempNode.padBottom = parseFloat(n.style('padding')); // forces\n\n    tempNode.nodeRepulsion = fn(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion; // Add new node\n\n    layoutInfo.layoutNodes.push(tempNode); // Add entry to id-index map\n\n    layoutInfo.idToIndex[tempNode.id] = i;\n  } // Inline implementation of a queue, used for traversing the graph in BFS order\n\n\n  var queue = [];\n  var start = 0; // Points to the start the queue\n\n  var end = -1; // Points to the end of the queue\n\n  var tempGraph = []; // Second pass to add child information and\n  // initialize queue for hierarchical traversal\n\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = layoutInfo.layoutNodes[i];\n    var p_id = n.parentId; // Check if node n has a parent node\n\n    if (null != p_id) {\n      // Add node Id to parent's list of children\n      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);\n    } else {\n      // If a node doesn't have a parent, then it's in the root graph\n      queue[++end] = n.id;\n      tempGraph.push(n.id);\n    }\n  } // Add root graph to graphSet\n\n\n  layoutInfo.graphSet.push(tempGraph); // Traverse the graph, level by level,\n\n  while (start <= end) {\n    // Get the node to visit and remove it from queue\n    var node_id = queue[start++];\n    var node_ix = layoutInfo.idToIndex[node_id];\n    var node = layoutInfo.layoutNodes[node_ix];\n    var children = node.children;\n\n    if (children.length > 0) {\n      // Add children nodes as a new graph to graph set\n      layoutInfo.graphSet.push(children); // Add children to que queue to be visited\n\n      for (var i = 0; i < children.length; i++) {\n        queue[++end] = children[i];\n      }\n    }\n  } // Create indexToGraph map\n\n\n  for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n    var graph = layoutInfo.graphSet[i];\n\n    for (var j = 0; j < graph.length; j++) {\n      var index = layoutInfo.idToIndex[graph[j]];\n      layoutInfo.indexToGraph[index] = i;\n    }\n  } // Iterate over all edges, creating Layout Edges\n\n\n  for (var i = 0; i < layoutInfo.edgeSize; i++) {\n    var e = edges[i];\n    var tempEdge = {};\n    tempEdge.id = e.data('id');\n    tempEdge.sourceId = e.data('source');\n    tempEdge.targetId = e.data('target'); // Compute ideal length\n\n    var idealLength = fn(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;\n    var elasticity = fn(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity; // Check if it's an inter graph edge\n\n    var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];\n    var targetIx = layoutInfo.idToIndex[tempEdge.targetId];\n    var sourceGraph = layoutInfo.indexToGraph[sourceIx];\n    var targetGraph = layoutInfo.indexToGraph[targetIx];\n\n    if (sourceGraph != targetGraph) {\n      // Find lowest common graph ancestor\n      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo); // Compute sum of node depths, relative to lca graph\n\n      var lcaGraph = layoutInfo.graphSet[lca];\n      var depth = 0; // Source depth\n\n      var tempNode = layoutInfo.layoutNodes[sourceIx];\n\n      while (-1 === lcaGraph.indexOf(tempNode.id)) {\n        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n        depth++;\n      } // Target depth\n\n\n      tempNode = layoutInfo.layoutNodes[targetIx];\n\n      while (-1 === lcaGraph.indexOf(tempNode.id)) {\n        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n        depth++;\n      } // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +\n      //  \". Index: \" + lca + \" Contents: \" + lcaGraph.toString() +\n      //  \". Depth: \" + depth);\n      // Update idealLength\n\n\n      idealLength *= depth * options.nestingFactor;\n    }\n\n    tempEdge.idealLength = idealLength;\n    tempEdge.elasticity = elasticity;\n    layoutInfo.layoutEdges.push(tempEdge);\n  } // Finally, return layoutInfo object\n\n\n  return layoutInfo;\n};\n/**\n * @brief : This function finds the index of the lowest common\n *          graph ancestor between 2 nodes in the subtree\n *          (from the graph hierarchy induced tree) whose\n *          root is graphIx\n *\n * @arg node1: node1's ID\n * @arg node2: node2's ID\n * @arg layoutInfo: layoutInfo object\n *\n */\n\n\nvar findLCA = function findLCA(node1, node2, layoutInfo) {\n  // Find their common ancester, starting from the root graph\n  var res = findLCA_aux(node1, node2, 0, layoutInfo);\n\n  if (2 > res.count) {\n    // If aux function couldn't find the common ancester,\n    // then it is the root graph\